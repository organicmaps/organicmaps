#!/usr/bin/env python

# Copyright: Veniamin Gvozdikov and contributors
# License: GNU AGPL, version 3 or later; http://www.gnu.org/licenses/agpl.html

#
# To generate defines.hpp just execute command like below
#
# $ python generate_defines.py
#

from enum import Enum, unique

TEMPLATE = """/*
* Copyright: Veniamin Gvozdikov and contributors
* License: GNU AGPL, version 3 or later; http://www.gnu.org/licenses/agpl.html
*
*
* DO NOT EDIT THIS FILE USE codegen/generate_defines.py TO GENERATE NEW VERSION
*/

#pragma once

{data}
"""


@unique
class Consts(Enum):
    COUNTRIES_ROOT = "Countries"
    CROSS_MWM_OSM_WAYS_DIR = "cross_mwm_osm_ways"
    LOCALIZATION_DESCRIPTION_SUFFIX = " Description"
    PACKED_POLYGONS_INFO_TAG = "info"


@unique
class FileName(Enum):
    ADDR_INTERPOL = "addr_interpol.bin"
    BOUNDARY_POSTCODES = "boundary_postcodes.bin"
    BUILDING_PARTS_MAPPING = "building_parts_mapping.bin"
    CAMERAS_TO_WAYS = "cameras_to_ways.bin"
    CITY_BOUNDARIES_COLLECTOR = "city_boundaries_collector.bin"
    COUNTRIES = "countries.txt"
    COUNTRIES_META = "countries_meta.txt"
    GPS_TRACK = "gps_track.dat"
    LEAP_SPEEDS = "leap_speeds.json"
    MAPCSS_MAPPING = "mapcss-mapping.csv"
    MAXSPEEDS = "maxspeeds.csv"
    METALINES = "metalines.bin"
    MINI_ROUNDABOUTS = "mini_roundabouts.bin"
    MIXED_NODES = "mixed_nodes.txt"
    MIXED_TAGS = "mixed_tags.txt"
    NODES = "nodes.dat"
    PACKED_POLYGONS = "packed_polygons.bin"
    PRODUCTS_SETTINGS = "products_settings.json"
    RELATIONS = "relations.dat"
    REPLACED_TAGS = "replaced_tags.txt"
    RESTRICTIONS = "restrictions.csv"
    ROAD_ACCESS = "road_access.bin"
    SEARCH_BRAND_CATEGORIES = "categories_brands.txt"
    SEARCH_CATEGORIES = "categories.txt"
    SEARCH_CUISINE_CATEGORIES = "categories_cuisines.txt"
    SERVER_DATAVERSION = "data_version.json"
    SETTINGS = "settings.ini"
    SKIPPED_ELEMENTS = "skipped_elements.json"
    TOWNS = "towns.csv"
    WAYS = "ways.dat"
    WORLD = "World"
    WORLD_COASTS = "WorldCoasts"


@unique
class FileTag(Enum):
    ALTITUDES = "altitudes"
    CAMERAS_INFO = "speedcams"
    CENTERS = "centers"
    CITIES_BOUNDARIES = "cities_boundaries"
    CITY_ROADS = "city_roads"
    CROSS_MWM = "cross_mwm"
    DESCRIPTIONS = "descriptions"
    FEATURE2PLACE = "ft2place"
    FEATURE2STREET = "addr"
    FEATURES = "features"
    FEATURE_OFFSETS = "offs"
    FEATURE_TO_OSM = "feature_to_osm"
    GEOMETRY = "geom"
    HEADER = "header"
    INDEX = "idx"
    ISOLINES_INFO = "isolines_info"
    MAXSPEEDS = "maxspeeds"
    METADATA = "meta"
    METALINES = "metalines"
    POPULARITY_RANKS = "popularity"
    POSTCODES = "postcodes"
    POSTCODE_POINTS = "postcode_points"
    REGION_INFO = "rgninfo"
    RESTRICTIONS = "restrictions"
    ROAD_ACCESS = "roadaccess"
    ROUTING = "routing"
    ROUTING_WORLD = "routing_world"
    SEARCH_INDEX = "sdx"
    SEARCH_RANKS = "ranks"
    TRAFFIC_KEYS = "traffic"
    TRANSIT = "transit"
    TRANSIT_CROSS_MWM = "transit_cross_mwm"
    TRIANGLE = "trg"
    VERSION = "version"


@unique
class FileExtension(Enum):
    ARCHIVE_TRACKS = ".track"
    ARCHIVE_TRACKS_ZIPPED = ".track.zip"
    DATA = ".mwm"
    DATA_TMP = ".mwm.tmp"
    DIFF = ".mwmdiff"
    DIFF_APPLYING = ".diff.applying"
    DOWNLOADING = ".downloading"
    FONT = ".ttf"
    GEOM_INDEX_TMP = ".geomidx.tmp"
    ID2REL = ".id2rel"
    OFFSET = ".offs"
    OSM2FEATURE = ".osm2ft"
    OSM_DATA = ".osm"
    RAW_GEOM = ".rawgeom"
    READY = ".ready"
    RESUME = ".resume"
    STATS = ".stats"
    TEMP_ADDR = ".tempaddr"
    TMP = ".tmp"
    TRAFFIC = ".traffic"
    TRANSIT = ".transit.json"


class DefineGenerator:
    def __init__(self, filename):
        self.__filename = filename
        self.__enums = []

    def __generate(self):
        data = ""
        for e in self.__enums:
            data += f"// Generated defines from {e.__name__} enum\n"
            for record in e:
                if e.__name__.startswith("File"):
                    suffix = e.__name__.replace("File", "File_")
                    data += f"#define {record.name}_{suffix.upper()} \"{record.value}\"\n"
                else:
                    data += f"#define {record.name} \"{record.value}\"\n"
            data += "\n"
        return data

    def add(self, data):
        self.__enums.append(data)
        print(f"added: {data.__name__} to generation")
        return self

    def gen(self, stdout=False):
        print(f"start generation: {self.__filename}")
        data = TEMPLATE.format(data=self.__generate()).rstrip()

        if not stdout:
            with open(self.__filename, mode="w") as fh:
                fh.write(data)
            print(f"writing completed: {self.__filename}")
        else:
            print(TEMPLATE.format(data=data))


if __name__ == "__main__":
    DefineGenerator("defines.hpp") \
      .add(FileExtension) \
      .add(FileName) \
      .add(FileTag) \
      .add(Consts) \
      .gen()
