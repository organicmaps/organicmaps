<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.2">
<meta name="author" content="website, repository">
<title>pugixml 1.7 manual</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400">
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Remove the comments around the @import statement below when using this as a custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
[hidden],template{display:none}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
body{margin:0}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}
input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*:before,*:after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
#map_canvas img,#map_canvas embed,#map_canvas object,.map_canvas img,.map_canvas embed,.map_canvas object{max-width:none!important}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
.antialiased,body{-webkit-font-smoothing:antialiased}
img{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
p.lead,.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{font-size:1.21875em;line-height:1.6}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #ddddd8;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol,ul.no-bullet,ol.no-bullet{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.no-bullet{list-style:none}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite:before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media only screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7;font-weight:bold}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix:before,.clearfix:after,.float-group:before,.float-group:after{content:" ";display:table}
.clearfix:after,.float-group:after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
.keyseq{color:rgba(51,51,51,.8)}
kbd{display:inline-block;color:rgba(0,0,0,.8);font-size:.75em;line-height:1.4;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:-.15em .15em 0 .15em;padding:.2em .6em .2em .5em;vertical-align:middle;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menu{color:rgba(0,0,0,.8)}
b.button:before,b.button:after{position:relative;top:-1px;font-weight:400}
b.button:before{content:"[";padding:0 3px 0 2px}
b.button:after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header:before,#header:after,#content:before,#content:after,#footnotes:before,#footnotes:after,#footer:before,#footer:after{content:" ";display:table}
#header:after,#content:after,#footnotes:after,#footer:after{clear:both}
#content{margin-top:1.25em}
#content:before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #ddddd8}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #ddddd8;padding-bottom:8px}
#header .details{border-bottom:1px solid #ddddd8;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span:before{content:"\00a0\2013\00a0"}
#header .details br+span.author:before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark:before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber:after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #ddddd8;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #efefed;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media only screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #efefed;left:auto;right:0}}@media only screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
.sect1{padding-bottom:.625em}
@media only screen and (min-width:768px){.sect1{padding-bottom:1.25em}}.sect1+.sect1{border-top:1px solid #efefed}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor:before,h2>a.anchor:before,h3>a.anchor:before,#toctitle>a.anchor:before,.sidebarblock>.content>.title>a.anchor:before,h4>a.anchor:before,h5>a.anchor:before,h6>a.anchor:before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock>caption.title{white-space:nowrap;overflow:visible;max-width:0}
.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>.paragraph:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;padding:1em;font-size:.8125em}
.literalblock pre.nowrap,.literalblock pre[class].nowrap,.listingblock pre.nowrap,.listingblock pre[class].nowrap{overflow-x:auto;white-space:pre;word-wrap:normal}
@media only screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}@media only screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]:before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]:before{display:block}
.listingblock.terminal pre .command:before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt]):before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #ddddd8}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock blockquote p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote:before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.5em;margin-right:.5ex;text-align:right}
.quoteblock .quoteblock{margin-left:0;margin-right:0;padding:.5em 0;border-left:3px solid rgba(0,0,0,.6)}
.quoteblock .quoteblock blockquote{padding:0 0 0 .75em}
.quoteblock .quoteblock blockquote:before{display:none}
.verseblock{margin:0 1em 1.25em 1em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.05em;color:rgba(0,0,0,.6)}
.quoteblock.abstract{margin:0 0 1.25em 0;display:block}
.quoteblock.abstract blockquote,.quoteblock.abstract blockquote p{text-align:left;word-spacing:0}
.quoteblock.abstract blockquote:before,.quoteblock.abstract blockquote p:first-of-type:before{display:none}
table.tableblock{max-width:100%;border-collapse:separate}
table.tableblock td>.paragraph:last-child p>p:last-child,table.tableblock th>p:last-child,table.tableblock td>p:last-child{margin-bottom:0}
table.spread{width:100%}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all th.tableblock,table.grid-all td.tableblock{border-width:0 1px 1px 0}
table.grid-all tfoot>tr>th.tableblock,table.grid-all tfoot>tr>td.tableblock{border-width:1px 1px 0 0}
table.grid-cols th.tableblock,table.grid-cols td.tableblock{border-width:0 1px 0 0}
table.grid-all *>tr>.tableblock:last-child,table.grid-cols *>tr>.tableblock:last-child{border-right-width:0}
table.grid-rows th.tableblock,table.grid-rows td.tableblock{border-width:0 0 1px 0}
table.grid-all tbody>tr:last-child>th.tableblock,table.grid-all tbody>tr:last-child>td.tableblock,table.grid-all thead:last-child>tr>th.tableblock,table.grid-rows tbody>tr:last-child>th.tableblock,table.grid-rows tbody>tr:last-child>td.tableblock,table.grid-rows thead:last-child>tr>th.tableblock{border-bottom-width:0}
table.grid-rows tfoot>tr>th.tableblock,table.grid-rows tfoot>tr>td.tableblock{border-width:1px 0 0 0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot{border-width:1px 0}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.unstyled,ol.unnumbered,ul.checklist,ul.none{list-style-type:none}
ul.unstyled,ol.unnumbered,ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1em;font-size:.85em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{width:1em;position:relative;top:1px}
ul.inline{margin:0 auto .625em auto;margin-left:-1.375em;margin-right:0;padding:0;list-style:none;overflow:hidden}
ul.inline>li{list-style:none;float:left;margin-left:1.375em;display:block}
ul.inline>li>*{display:block}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1{padding-right:.75em;font-weight:bold}
td.hdlist1,td.hdlist2{vertical-align:top}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist>table tr>td:first-of-type{padding:0 .75em;line-height:1}
.colist>table tr>td:last-of-type{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left,.imageblock[style*="float: left"]{margin:.25em .625em 1.25em 0}
.imageblock.right,.imageblock[style*="float: right"]{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none}
span.footnote,span.footnoteref{vertical-align:super;font-size:.875em}
span.footnote a,span.footnoteref a{text-decoration:none}
span.footnote a:active,span.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em 0;border-width:1px 0 0 0}
#footnotes .footnote{padding:0 .375em;line-height:1.3;font-size:.875em;margin-left:1.2em;text-indent:-1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note:before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip:before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning:before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution:before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important:before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]:after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
h1,h2{letter-spacing:-.01em}
dt,th.tableblock,td.content{text-rendering:optimizeLegibility}
p,td.content{letter-spacing:-.01em}
p strong,td.content strong{letter-spacing:-.005em}
p,blockquote,dt,td.content{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@media print{@page{margin:1.25cm .75cm}
*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare):after,a[href^="https:"]:not(.bare):after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]:after{content:" (" attr(title) ")"}
pre,blockquote,tr,img{page-break-inside:avoid}
thead{display:table-header-group}
img{max-width:100%!important}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #ddddd8!important;padding-bottom:0!important}
.sect1{padding-bottom:0!important}
.sect1+.sect1{border:0!important}
#header>h1:first-child{margin-top:1.25rem}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em 0}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span:before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]:before{display:block}
#footer{background:none!important;padding:0 .9375em}
#footer-text{color:rgba(0,0,0,.6)!important;font-size:.9em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
</style>
<style>
.listingblock .pygments .hll { background-color: #ffffcc }
.listingblock .pygments  { background: #f8f8f8; }
.listingblock .pygments .tok-c { color: #408080; font-style: italic } /* Comment */
.listingblock .pygments .tok-err { border: 1px solid #FF0000 } /* Error */
.listingblock .pygments .tok-k { color: #008000; font-weight: bold } /* Keyword */
.listingblock .pygments .tok-o { color: #666666 } /* Operator */
.listingblock .pygments .tok-cm { color: #408080; font-style: italic } /* Comment.Multiline */
.listingblock .pygments .tok-cp { color: #BC7A00 } /* Comment.Preproc */
.listingblock .pygments .tok-c1 { color: #408080; font-style: italic } /* Comment.Single */
.listingblock .pygments .tok-cs { color: #408080; font-style: italic } /* Comment.Special */
.listingblock .pygments .tok-gd { color: #A00000 } /* Generic.Deleted */
.listingblock .pygments .tok-ge { font-style: italic } /* Generic.Emph */
.listingblock .pygments .tok-gr { color: #FF0000 } /* Generic.Error */
.listingblock .pygments .tok-gh { color: #000080; font-weight: bold } /* Generic.Heading */
.listingblock .pygments .tok-gi { color: #00A000 } /* Generic.Inserted */
.listingblock .pygments .tok-go { color: #888888 } /* Generic.Output */
.listingblock .pygments .tok-gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.listingblock .pygments .tok-gs { font-weight: bold } /* Generic.Strong */
.listingblock .pygments .tok-gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.listingblock .pygments .tok-gt { color: #0044DD } /* Generic.Traceback */
.listingblock .pygments .tok-kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.listingblock .pygments .tok-kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.listingblock .pygments .tok-kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.listingblock .pygments .tok-kp { color: #008000 } /* Keyword.Pseudo */
.listingblock .pygments .tok-kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.listingblock .pygments .tok-kt { color: #B00040 } /* Keyword.Type */
.listingblock .pygments .tok-m { color: #666666 } /* Literal.Number */
.listingblock .pygments .tok-s { color: #BA2121 } /* Literal.String */
.listingblock .pygments .tok-na { color: #7D9029 } /* Name.Attribute */
.listingblock .pygments .tok-nb { color: #008000 } /* Name.Builtin */
.listingblock .pygments .tok-nc { color: #0000FF; font-weight: bold } /* Name.Class */
.listingblock .pygments .tok-no { color: #880000 } /* Name.Constant */
.listingblock .pygments .tok-nd { color: #AA22FF } /* Name.Decorator */
.listingblock .pygments .tok-ni { color: #999999; font-weight: bold } /* Name.Entity */
.listingblock .pygments .tok-ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.listingblock .pygments .tok-nf { color: #0000FF } /* Name.Function */
.listingblock .pygments .tok-nl { color: #A0A000 } /* Name.Label */
.listingblock .pygments .tok-nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.listingblock .pygments .tok-nt { color: #008000; font-weight: bold } /* Name.Tag */
.listingblock .pygments .tok-nv { color: #19177C } /* Name.Variable */
.listingblock .pygments .tok-ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.listingblock .pygments .tok-w { color: #bbbbbb } /* Text.Whitespace */
.listingblock .pygments .tok-mb { color: #666666 } /* Literal.Number.Bin */
.listingblock .pygments .tok-mf { color: #666666 } /* Literal.Number.Float */
.listingblock .pygments .tok-mh { color: #666666 } /* Literal.Number.Hex */
.listingblock .pygments .tok-mi { color: #666666 } /* Literal.Number.Integer */
.listingblock .pygments .tok-mo { color: #666666 } /* Literal.Number.Oct */
.listingblock .pygments .tok-sb { color: #BA2121 } /* Literal.String.Backtick */
.listingblock .pygments .tok-sc { color: #BA2121 } /* Literal.String.Char */
.listingblock .pygments .tok-sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.listingblock .pygments .tok-s2 { color: #BA2121 } /* Literal.String.Double */
.listingblock .pygments .tok-se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.listingblock .pygments .tok-sh { color: #BA2121 } /* Literal.String.Heredoc */
.listingblock .pygments .tok-si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.listingblock .pygments .tok-sx { color: #008000 } /* Literal.String.Other */
.listingblock .pygments .tok-sr { color: #BB6688 } /* Literal.String.Regex */
.listingblock .pygments .tok-s1 { color: #BA2121 } /* Literal.String.Single */
.listingblock .pygments .tok-ss { color: #19177C } /* Literal.String.Symbol */
.listingblock .pygments .tok-bp { color: #008000 } /* Name.Builtin.Pseudo */
.listingblock .pygments .tok-vc { color: #19177C } /* Name.Variable.Class */
.listingblock .pygments .tok-vg { color: #19177C } /* Name.Variable.Global */
.listingblock .pygments .tok-vi { color: #19177C } /* Name.Variable.Instance */
.listingblock .pygments .tok-il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body class="article toc2 toc-right">
<div id="header">
<h1>pugixml 1.7 manual</h1>
<div class="details">
<span id="author" class="author">website</span><br>
<span id="email" class="email"><a href="http://pugixml.org" class="bare">http://pugixml.org</a></span><br>
<span id="author2" class="author">repository</span><br>
<span id="email2" class="email"><a href="http://github.com/zeux/pugixml" class="bare">http://github.com/zeux/pugixml</a></span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#overview">1. Overview</a>
<ul class="sectlevel2">
<li><a href="#overview.introduction">1.1. Introduction</a></li>
<li><a href="#overview.feedback">1.2. Feedback</a></li>
<li><a href="#overview.thanks">1.3. Acknowledgments</a></li>
<li><a href="#overview.license">1.4. License</a></li>
</ul>
</li>
<li><a href="#install">2. Installation</a>
<ul class="sectlevel2">
<li><a href="#install.getting">2.1. Getting pugixml</a></li>
<li><a href="#install.building">2.2. Building pugixml</a></li>
<li><a href="#install.portability">2.3. Portability</a></li>
</ul>
</li>
<li><a href="#dom">3. Document object model</a>
<ul class="sectlevel2">
<li><a href="#dom.tree">3.1. Tree structure</a></li>
<li><a href="#dom.cpp">3.2. C&#43;&#43; interface</a></li>
<li><a href="#dom.unicode">3.3. Unicode interface</a></li>
<li><a href="#dom.thread">3.4. Thread-safety guarantees</a></li>
<li><a href="#dom.exception">3.5. Exception guarantees</a></li>
<li><a href="#dom.memory">3.6. Memory management</a></li>
</ul>
</li>
<li><a href="#loading">4. Loading document</a>
<ul class="sectlevel2">
<li><a href="#loading.file">4.1. Loading document from file</a></li>
<li><a href="#loading.memory">4.2. Loading document from memory</a></li>
<li><a href="#loading.stream">4.3. Loading document from C&#43;&#43; IOstreams</a></li>
<li><a href="#loading.errors">4.4. Handling parsing errors</a></li>
<li><a href="#loading.options">4.5. Parsing options</a></li>
<li><a href="#loading.encoding">4.6. Encodings</a></li>
<li><a href="#loading.w3c">4.7. Conformance to W3C specification</a></li>
</ul>
</li>
<li><a href="#access">5. Accessing document data</a>
<ul class="sectlevel2">
<li><a href="#access.basic">5.1. Basic traversal functions</a></li>
<li><a href="#access.nodedata">5.2. Getting node data</a></li>
<li><a href="#access.attrdata">5.3. Getting attribute data</a></li>
<li><a href="#access.contents">5.4. Contents-based traversal functions</a></li>
<li><a href="#access.rangefor">5.5. Range-based for-loop support</a></li>
<li><a href="#access.iterators">5.6. Traversing node/attribute lists via iterators</a></li>
<li><a href="#access.walker">5.7. Recursive traversal with xml_tree_walker</a></li>
<li><a href="#access.predicate">5.8. Searching for nodes/attributes with predicates</a></li>
<li><a href="#access.text">5.9. Working with text contents</a></li>
<li><a href="#access.misc">5.10. Miscellaneous functions</a></li>
</ul>
</li>
<li><a href="#modify">6. Modifying document data</a>
<ul class="sectlevel2">
<li><a href="#modify.nodedata">6.1. Setting node data</a></li>
<li><a href="#modify.attrdata">6.2. Setting attribute data</a></li>
<li><a href="#modify.add">6.3. Adding nodes/attributes</a></li>
<li><a href="#modify.remove">6.4. Removing nodes/attributes</a></li>
<li><a href="#modify.text">6.5. Working with text contents</a></li>
<li><a href="#modify.clone">6.6. Cloning nodes/attributes</a></li>
<li><a href="#modify.move">6.7. Moving nodes</a></li>
<li><a href="#modify.fragments">6.8. Assembling document from fragments</a></li>
</ul>
</li>
<li><a href="#saving">7. Saving document</a>
<ul class="sectlevel2">
<li><a href="#saving.file">7.1. Saving document to a file</a></li>
<li><a href="#saving.stream">7.2. Saving document to C&#43;&#43; IOstreams</a></li>
<li><a href="#saving.writer">7.3. Saving document via writer interface</a></li>
<li><a href="#saving.subtree">7.4. Saving a single subtree</a></li>
<li><a href="#saving.options">7.5. Output options</a></li>
<li><a href="#saving.encoding">7.6. Encodings</a></li>
<li><a href="#saving.declaration">7.7. Customizing document declaration</a></li>
</ul>
</li>
<li><a href="#xpath">8. XPath</a>
<ul class="sectlevel2">
<li><a href="#xpath.types">8.1. XPath types</a></li>
<li><a href="#xpath.select">8.2. Selecting nodes via XPath expression</a></li>
<li><a href="#xpath.query">8.3. Using query objects</a></li>
<li><a href="#xpath.variables">8.4. Using variables</a></li>
<li><a href="#xpath.errors">8.5. Error handling</a></li>
<li><a href="#xpath.w3c">8.6. Conformance to W3C specification</a></li>
</ul>
</li>
<li><a href="#changes">9. Changelog</a>
<ul class="sectlevel2">
<li><a href="#v1.7">v1.7 <sup>19.10.2015</sup></a></li>
<li><a href="#v1.6">v1.6 <sup>10.04.2015</sup></a></li>
<li><a href="#v1.5">v1.5 <sup>27.11.2014</sup></a></li>
<li><a href="#v1.4">v1.4 <sup>27.02.2014</sup></a></li>
<li><a href="#v1.2">v1.2 <sup>1.05.2012</sup></a></li>
<li><a href="#v1.0">v1.0 <sup>1.11.2010</sup></a></li>
<li><a href="#v0.9">v0.9 <sup>1.07.2010</sup></a></li>
<li><a href="#v0.5">v0.5 <sup>8.11.2009</sup></a></li>
<li><a href="#v0.42">v0.42 <sup>17.09.2009</sup></a></li>
<li><a href="#v0.41">v0.41 <sup>8.02.2009</sup></a></li>
<li><a href="#v0.4">v0.4 <sup>18.01.2009</sup></a></li>
<li><a href="#v0.34">v0.34 <sup>31.10.2007</sup></a></li>
<li><a href="#v0.3">v0.3 <sup>21.02.2007</sup></a></li>
<li><a href="#v0.2">v0.2 <sup>6.11.2006</sup></a></li>
<li><a href="#v0.1">v0.1 <sup>15.07.2006</sup></a></li>
</ul>
</li>
<li><a href="#apiref">10. API Reference</a>
<ul class="sectlevel2">
<li><a href="#apiref.macros">10.1. Macros</a></li>
<li><a href="#apiref.types">10.2. Types</a></li>
<li><a href="#apiref.enums">10.3. Enumerations</a></li>
<li><a href="#apiref.constants">10.4. Constants</a></li>
<li><a href="#apiref.classes">10.5. Classes</a></li>
<li><a href="#apiref.functions">10.6. Functions</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="overview"><a class="anchor" href="#overview"></a>1. Overview</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="overview.introduction"><a class="anchor" href="#overview.introduction"></a>1.1. Introduction</h3>
<div class="paragraph">
<p><a href="http://pugixml.org/">pugixml</a> is a light-weight C&#43;&#43; XML processing library. It consists of a DOM-like interface with rich traversal/modification capabilities, an extremely fast XML parser which constructs the DOM tree from an XML file/buffer, and an <a href="#xpath">XPath 1.0 implementation</a> for complex data-driven tree queries. Full Unicode support is also available, with <a href="#dom.unicode">two Unicode interface variants</a> and conversions between different Unicode encodings (which happen automatically during parsing/saving). The library is <a href="#install.portability">extremely portable</a> and easy to integrate and use. pugixml is developed and maintained since 2006 and has many users. All code is distributed under the <a href="#overview.license">MIT license</a>, making it completely free to use in both open-source and proprietary applications.</p>
</div>
<div class="paragraph">
<p>pugixml enables very fast, convenient and memory-efficient XML document processing. However, since pugixml has a DOM parser, it can&#8217;t process XML documents that do not fit in memory; also the parser is a non-validating one, so if you need DTD or XML Schema validation, the library is not for you.</p>
</div>
<div class="paragraph">
<p>This is the complete manual for pugixml, which describes all features of the library in detail. If you want to start writing code as quickly as possible, you are advised to <a href="quickstart.html">read the quick start guide first</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
No documentation is perfect; neither is this one. If you find errors or omissions, please donâ€™t hesitate to <a href="https://github.com/zeux/pugixml/issues/new">submit an issue or open a pull request</a> with a fix.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="overview.feedback"><a class="anchor" href="#overview.feedback"></a>1.2. Feedback</h3>
<div class="paragraph">
<p>If you believe you&#8217;ve found a bug in pugixml (bugs include compilation problems (errors/warnings), crashes, performance degradation and incorrect behavior), please file an issue via <a href="https://github.com/zeux/pugixml/issues/new">issue submission form</a>. Be sure to include the relevant information so that the bug can be reproduced: the version of pugixml, compiler version and target architecture, the code that uses pugixml and exhibits the bug, etc.</p>
</div>
<div class="paragraph">
<p>Feature requests can be reported the same way as bugs, so if you&#8217;re missing some functionality in pugixml or if the API is rough in some places and you can suggest an improvement, <a href="https://github.com/zeux/pugixml/issues/new">file an issue</a>. However please note that there are many factors when considering API changes (compatibility with previous versions, API redundancy, etc.), so generally features that can be implemented via a small function without pugixml modification are not accepted. However, all rules have exceptions.</p>
</div>
<div class="paragraph">
<p>If you have a contribution to pugixml, such as build script for some build system/IDE, or a well-designed set of helper functions, or a binding to some language other than C&#43;&#43;, please <a href="https://github.com/zeux/pugixml/issues/new">file an issue or open a pull request</a>. Your contribution has to be distributed under the terms of a license that&#8217;s compatible with pugixml license; i.e. GPL/LGPL licensed code is not accepted.</p>
</div>
<div class="paragraph">
<p>If filing an issue is not possible due to privacy or other concerns, you can contact pugixml author by e-mail directly: <a href="mailto:arseny.kapoulkine@gmail.com">arseny.kapoulkine@gmail.com</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="overview.thanks"><a class="anchor" href="#overview.thanks"></a>1.3. Acknowledgments</h3>
<div class="paragraph">
<p>pugixml could not be developed without the help from many people; some of them are listed in this section. If you&#8217;ve played a part in pugixml development and you can not find yourself on this list, I&#8217;m truly sorry; please <a href="#email">send me an e-mail</a> so I can fix this.</p>
</div>
<div class="paragraph">
<p>Thanks to <strong>Kristen Wegner</strong> for pugxml parser, which was used as a basis for pugixml.</p>
</div>
<div class="paragraph">
<p>Thanks to <strong>Neville Franks</strong> for contributions to pugxml parser.</p>
</div>
<div class="paragraph">
<p>Thanks to <strong>Artyom Palvelev</strong> for suggesting a lazy gap contraction approach.</p>
</div>
<div class="paragraph">
<p>Thanks to <strong>Vyacheslav Egorov</strong> for documentation proofreading and fuzz testing.</p>
</div>
</div>
<div class="sect2">
<h3 id="overview.license"><a class="anchor" href="#overview.license"></a>1.4. License</h3>
<div class="paragraph">
<p>The pugixml library is distributed under the MIT license:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Copyright (c) 2006-2015 Arseny Kapoulkine

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.</pre>
</div>
</div>
<div class="paragraph">
<p>This means that you can freely use pugixml in your applications, both open-source and proprietary. If you use pugixml in a product, it is sufficient to add an acknowledgment like this to the product distribution:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>This software is based on pugixml library (http://pugixml.org).
pugixml is Copyright (C) 2006-2015 Arseny Kapoulkine.</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="install"><a class="anchor" href="#install"></a>2. Installation</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="install.getting"><a class="anchor" href="#install.getting"></a>2.1. Getting pugixml</h3>
<div class="paragraph">
<p>pugixml is distributed in source form. You can either download a source distribution or clone the Git repository.</p>
</div>
<div class="sect3">
<h4 id="install.getting.source"><a class="anchor" href="#install.getting.source"></a>2.1.1. Source distributions</h4>
<div class="paragraph">
<p>You can download the latest source distribution as an archive:</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/zeux/pugixml/releases/download/v1.7/pugixml-1.7.zip">pugixml-1.7.zip</a> (Windows line endings)
/
<a href="https://github.com/zeux/pugixml/releases/download/v1.7/pugixml-1.7.tar.gz">pugixml-1.7.tar.gz</a> (Unix line endings)</p>
</div>
<div class="paragraph">
<p>The distribution contains library source, documentation (the manual you&#8217;re reading now and the quick start guide) and some code examples. After downloading the distribution, install pugixml by extracting all files from the compressed archive.</p>
</div>
<div class="paragraph">
<p>If you need an older version, you can download it from the <a href="https://github.com/zeux/pugixml/releases">version archive</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="install.getting.git"><a class="anchor" href="#install.getting.git"></a>2.1.2. Git repository</h4>
<div class="paragraph">
<p>The Git repository is located at <a href="https://github.com/zeux/pugixml/" class="bare">https://github.com/zeux/pugixml/</a>. There is a Git tag "v{version}" for each version; also there is the "latest" tag, which always points to the latest stable release.</p>
</div>
<div class="paragraph">
<p>For example, to checkout the current version, you can use this command:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash">git clone https://github.com/zeux/pugixml
cd pugixml
git checkout v1.7</code></pre>
</div>
</div>
<div class="paragraph">
<p>The repository contains library source, documentation, code examples and full unit test suite.</p>
</div>
<div class="paragraph">
<p>Use <code>latest</code> tag if you want to automatically get new versions. Use other tags if you want to switch to new versions only explicitly. Also please note that the master branch contains the work-in-progress version of the code; while this means that you can get new features and bug fixes from master without waiting for a new release, this also means that occasionally the code can be broken in some configurations.</p>
</div>
</div>
<div class="sect3">
<h4 id="install.getting.subversion"><a class="anchor" href="#install.getting.subversion"></a>2.1.3. Subversion repository</h4>
<div class="paragraph">
<p>You can access the Git repository via Subversion using <a href="https://github.com/zeux/pugixml" class="bare">https://github.com/zeux/pugixml</a> URL. For example, to checkout the current version, you can use this command:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash">svn checkout https://github.com/zeux/pugixml/tags/v1.7 pugixml</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="install.getting.packages"><a class="anchor" href="#install.getting.packages"></a>2.1.4. Packages</h4>
<div class="paragraph">
<p>pugixml is available as a package via various package managers. Note that most packages are maintained separately from the main repository so they do not necessarily contain the latest version.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s an incomplete list of pugixml packages in various systems:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Linux (<a href="http://packages.ubuntu.com/search?keywords=pugixml">Ubuntu</a>, <a href="https://tracker.debian.org/pkg/pugixml">Debian</a>, <a href="https://apps.fedoraproject.org/packages/pugixml">Fedora</a>, <a href="https://aur.archlinux.org/packages/pugixml/">Arch Linux</a>, other <a href="http://pkgs.org/search/pugixml">distributions</a>)</p>
</li>
<li>
<p><a href="http://fbsdmon.org/ports/textproc/pugixml">FreeBSD</a></p>
</li>
<li>
<p>OSX, via <a href="http://brewformulas.org/Pugixml">Homebrew</a></p>
</li>
<li>
<p>Windows, via <a href="https://www.nuget.org/packages/pugixml/">NuGet</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="install.building"><a class="anchor" href="#install.building"></a>2.2. Building pugixml</h3>
<div class="paragraph">
<p>pugixml is distributed in source form without any pre-built binaries; you have to build them yourself.</p>
</div>
<div class="paragraph">
<p>The complete pugixml source consists of three files - one source file, <code>pugixml.cpp</code>, and two header files, <code>pugixml.hpp</code> and <code>pugiconfig.hpp</code>. <code>pugixml.hpp</code> is the primary header which you need to include in order to use pugixml classes/functions; <code>pugiconfig.hpp</code> is a supplementary configuration file (see <a href="#install.building.config">Additional configuration options</a>). The rest of this guide assumes that <code>pugixml.hpp</code> is either in the current directory or in one of include directories of your projects, so that <code>#include "pugixml.hpp"</code> can find the header; however you can also use relative path (i.e. <code>#include "../libs/pugixml/src/pugixml.hpp"</code>) or include directory-relative path (i.e. <code>#include &lt;xml/thirdparty/pugixml/src/pugixml.hpp&gt;</code>).</p>
</div>
<div class="sect3">
<h4 id="install.building.embed"><a class="anchor" href="#install.building.embed"></a>2.2.1. Building pugixml as a part of another static library/executable</h4>
<div class="paragraph">
<p>The easiest way to build pugixml is to compile the source file, <code>pugixml.cpp</code>, along with the existing library/executable. This process depends on the method of building your application; for example, if you&#8217;re using Microsoft Visual Studio <span class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnote_1" title="View footnote.">1</a>]</span>, Apple Xcode, Code::Blocks or any other IDE, just add <code>pugixml.cpp</code> to one of your projects.</p>
</div>
<div class="paragraph">
<p>If you&#8217;re using Microsoft Visual Studio and the project has precompiled headers turned on, you&#8217;ll see the following error messages:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>pugixml.cpp(3477) : fatal error C1010: unexpected end of file while looking for precompiled header. Did you forget to add '#include "stdafx.h"' to your source?</pre>
</div>
</div>
<div class="paragraph">
<p>The correct way to resolve this is to disable precompiled headers for <code>pugixml.cpp</code>; you have to set "Create/Use Precompiled Header" option (Properties dialog &#8594; C/C&#43;&#43; &#8594; Precompiled Headers &#8594; Create/Use Precompiled Header) to "Not Using Precompiled Headers". You&#8217;ll have to do it for all project configurations/platforms (you can select Configuration "All Configurations" and Platform "All Platforms" before editing the option):</p>
</div>
<table class="tableblock frame-none grid-all spread">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div><div class="imageblock">
<div class="content">
<a class="image" href="images/vs2005_pch1.png"><img src="images/vs2005_pch1.png" alt="vs2005 pch1"></a>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div><div class="imageblock">
<div class="content">
<a class="image" href="images/vs2005_pch2.png"><img src="images/vs2005_pch2.png" alt="vs2005 pch2"></a>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div><div class="imageblock">
<div class="content">
<a class="image" href="images/vs2005_pch3.png"><img src="images/vs2005_pch3.png" alt="vs2005 pch3"></a>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div><div class="imageblock">
<div class="content">
<a class="image" href="images/vs2005_pch4.png"><img src="images/vs2005_pch4.png" alt="vs2005 pch4"></a>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="install.building.static"><a class="anchor" href="#install.building.static"></a>2.2.2. Building pugixml as a standalone static library</h4>
<div class="paragraph">
<p>It&#8217;s possible to compile pugixml as a standalone static library. This process depends on the method of building your application; pugixml distribution comes with project files for several popular IDEs/build systems. There are project files for Apple XCode, Code::Blocks, Codelite, Microsoft Visual Studio 2005, 2008, 2010+, and configuration scripts for CMake and premake4. You&#8217;re welcome to submit project files/build scripts for other software; see <a href="#overview.feedback">Feedback</a>.</p>
</div>
<div class="paragraph">
<p>There are two projects for each version of Microsoft Visual Studio: one for dynamically linked CRT, which has a name like <code>pugixml_vs2008.vcproj</code>, and another one for statically linked CRT, which has a name like <code>pugixml_vs2008_static.vcproj</code>. You should select the version that matches the CRT used in your application; the default option for new projects created by Microsoft Visual Studio is dynamically linked CRT, so unless you changed the defaults, you should use the version with dynamic CRT (i.e. <code>pugixml_vs2008.vcproj</code> for Microsoft Visual Studio 2008).</p>
</div>
<div class="paragraph">
<p>In addition to adding pugixml project to your workspace, you&#8217;ll have to make sure that your application links with pugixml library. If you&#8217;re using Microsoft Visual Studio 2005/2008, you can add a dependency from your application project to pugixml one. If you&#8217;re using Microsoft Visual Studio 2010+, you&#8217;ll have to add a reference to your application project instead. For other IDEs/systems, consult the relevant documentation.</p>
</div>
<table class="tableblock frame-none grid-all spread">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top" colspan="2">Microsoft Visual Studio 2005/2008</th>
<th class="tableblock halign-left valign-top" colspan="2">Microsoft Visual Studio 2010+</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div><div class="imageblock">
<div class="content">
<a class="image" href="images/vs2005_link1.png"><img src="images/vs2005_link1.png" alt="vs2005 link1"></a>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div><div class="imageblock">
<div class="content">
<a class="image" href="images/vs2005_link2.png"><img src="images/vs2005_link2.png" alt="vs2005 link2"></a>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div><div class="imageblock">
<div class="content">
<a class="image" href="images/vs2010_link1.png"><img src="images/vs2010_link1.png" alt="vs2010 link1"></a>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div><div class="imageblock">
<div class="content">
<a class="image" href="images/vs2010_link2.png"><img src="images/vs2010_link2.png" alt="vs2010 link2"></a>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="install.building.shared"><a class="anchor" href="#install.building.shared"></a>2.2.3. Building pugixml as a standalone shared library</h4>
<div class="paragraph">
<p>It&#8217;s possible to compile pugixml as a standalone shared library. The process is usually similar to the static library approach; however, no preconfigured projects/scripts are included into pugixml distribution, so you&#8217;ll have to do it yourself. Generally, if you&#8217;re using GCC-based toolchain, the process does not differ from building any other library as DLL (adding -shared to compilation flags should suffice); if you&#8217;re using MSVC-based toolchain, you&#8217;ll have to explicitly mark exported symbols with a declspec attribute. You can do it by defining <a href="#PUGIXML_API">PUGIXML_API</a> macro, i.e. via <code>pugiconfig.hpp</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-cp">#ifdef _DLL</span>
    <span class="tok-cp">#define PUGIXML_API __declspec(dllexport)</span>
<span class="tok-cp">#else</span>
    <span class="tok-cp">#define PUGIXML_API __declspec(dllimport)</span>
<span class="tok-cp">#endif</span></code></pre>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
If you&#8217;re using STL-related functions, you should use the shared runtime library to ensure that a single heap is used for STL allocations in your application and in pugixml; in MSVC, this means selecting the 'Multithreaded DLL' or 'Multithreaded Debug DLL' to 'Runtime library' property (<code>/MD</code> or <code>/MDd</code> linker switch). You should also make sure that your runtime library choice is consistent between different projects.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="install.building.header"><a class="anchor" href="#install.building.header"></a>2.2.4. Using pugixml in header-only mode</h4>
<div id="PUGIXML_HEADER_ONLY" class="paragraph">
<p>It&#8217;s possible to use pugixml in header-only mode. This means that all source code for pugixml will be included in every translation unit that includes <code>pugixml.hpp</code>. This is how most of Boost and STL libraries work.</p>
</div>
<div class="paragraph">
<p>Note that there are advantages and drawbacks of this approach. Header mode may improve tree traversal/modification performance (because many simple functions will be inlined), if your compiler toolchain does not support link-time optimization, or if you have it turned off (with link-time optimization the performance should be similar to non-header mode). However, since compiler now has to compile pugixml source once for each translation unit that includes it, compilation times may increase noticeably. If you want to use pugixml in header mode but do not need XPath support, you can consider disabling it by using <a href="#PUGIXML_NO_XPATH">PUGIXML_NO_XPATH</a> define to improve compilation time.</p>
</div>
<div class="paragraph">
<p>To enable header-only mode, you have to define <code>PUGIXML_HEADER_ONLY</code>. You can either do it in <code>pugiconfig.hpp</code>, or provide them via compiler command-line.</p>
</div>
<div class="paragraph">
<p>Note that it is safe to compile <code>pugixml.cpp</code> if <code>PUGIXML_HEADER_ONLY</code> is defined - so if you want to i.e. use header-only mode only in Release configuration, you
can include pugixml.cpp in your project (see <a href="#install.building.embed">Building pugixml as a part of another static library/executable</a>), and conditionally enable header-only mode in <code>pugiconfig.hpp</code> like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-cp">#ifndef _DEBUG</span>
    <span class="tok-cp">#define PUGIXML_HEADER_ONLY</span>
<span class="tok-cp">#endif</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="install.building.config"><a class="anchor" href="#install.building.config"></a>2.2.5. Additional configuration options</h4>
<div class="paragraph">
<p>pugixml uses several defines to control the compilation process. There are two ways to define them: either put the needed definitions to <code>pugiconfig.hpp</code> (it has some examples that are commented out) or provide them via compiler command-line. Consistency is important: the definitions should match in all source files that include <code>pugixml.hpp</code> (including pugixml sources) throughout the application. Adding defines to <code>pugiconfig.hpp</code> lets you guarantee this, unless your macro definition is wrapped in preprocessor <code>#if</code>/<code>#ifdef</code> directive and this directive is not consistent. <code>pugiconfig.hpp</code> will never contain anything but comments, which means that when upgrading to a new version, you can safely leave your modified version intact.</p>
</div>
<div class="paragraph">
<p><a id="PUGIXML_WCHAR_MODE"></a><code>PUGIXML_WCHAR_MODE</code> define toggles between UTF-8 style interface (the in-memory text encoding is assumed to be UTF-8, most functions use <code>char</code> as character type) and UTF-16/32 style interface (the in-memory text encoding is assumed to be UTF-16/32, depending on <code>wchar_t</code> size, most functions use <code>wchar_t</code> as character type). See <a href="#dom.unicode">Unicode interface</a> for more details.</p>
</div>
<div class="paragraph">
<p><a id="PUGIXML_COMPACT"></a><code>PUGIXML_COMPACT</code> define activates a different internal representation of document storage that is much more memory efficient for documents with a lot of markup (i.e. nodes and attributes), but is slightly slower to parse and access. For details see <a href="#dom.memory.compact">Compact mode</a>.</p>
</div>
<div class="paragraph">
<p><a id="PUGIXML_NO_XPATH"></a><code>PUGIXML_NO_XPATH</code> define disables XPath. Both XPath interfaces and XPath implementation are excluded from compilation. This option is provided in case you do not need XPath functionality and need to save code space.</p>
</div>
<div class="paragraph">
<p><a id="PUGIXML_NO_STL"></a><code>PUGIXML_NO_STL</code> define disables use of STL in pugixml. The functions that operate on STL types are no longer present (i.e. load/save via iostream) if this macro is defined. This option is provided in case your target platform does not have a standard-compliant STL implementation.</p>
</div>
<div class="paragraph">
<p><a id="PUGIXML_NO_EXCEPTIONS"></a><code>PUGIXML_NO_EXCEPTIONS</code> define disables use of exceptions in pugixml. This option is provided in case your target platform does not have exception handling capabilities.</p>
</div>
<div class="paragraph">
<p><a id="PUGIXML_API"></a><code>PUGIXML_API</code>, <a id="PUGIXML_CLASS"></a><code>PUGIXML_CLASS</code> and <a id="PUGIXML_FUNCTION"></a><code>PUGIXML_FUNCTION</code> defines let you specify custom attributes (i.e. declspec or calling conventions) for pugixml classes and non-member functions. In absence of <code>PUGIXML_CLASS</code> or <code>PUGIXML_FUNCTION</code> definitions, <code>PUGIXML_API</code> definition is used instead. For example, to specify fixed calling convention, you can define <code>PUGIXML_FUNCTION</code> to i.e. <code>__fastcall</code>. Another example is DLL import/export attributes in MSVC (see <a href="#install.building.shared">Building pugixml as a standalone shared library</a>).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
In that example <code>PUGIXML_API</code> is inconsistent between several source files; this is an exception to the consistency rule.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><a id="PUGIXML_MEMORY_PAGE_SIZE"></a><code>PUGIXML_MEMORY_PAGE_SIZE</code>, <a id="PUGIXML_MEMORY_OUTPUT_STACK"></a><code>PUGIXML_MEMORY_OUTPUT_STACK</code> and <a id="PUGIXML_MEMORY_XPATH_PAGE_SIZE"></a><code>PUGIXML_MEMORY_XPATH_PAGE_SIZE</code> can be used to customize certain important sizes to optimize memory usage for the application-specific patterns. For details see <a href="#dom.memory.tuning">Memory consumption tuning</a>.</p>
</div>
<div class="paragraph">
<p><a id="PUGIXML_HAS_LONG_LONG"></a><code>PUGIXML_HAS_LONG_LONG</code> define enables support for <code>long long</code> type in pugixml. This define is automatically enabled if your platform is known to have <code>long long</code> support (i.e. has C&#43;&#43;11 support or uses a reasonably modern version of a known compiler); if pugixml does not recognize that your platform supports <code>long long</code> but in fact it does, you can enable the define manually.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="install.portability"><a class="anchor" href="#install.portability"></a>2.3. Portability</h3>
<div class="paragraph">
<p>pugixml is written in standard-compliant C&#43;&#43; with some compiler-specific workarounds where appropriate. pugixml is compatible with the C&#43;&#43;11 standard, but does not require C&#43;&#43;11 support. Each version is tested with a unit test suite with code coverage exceeding 99%.</p>
</div>
<div class="paragraph">
<p>pugixml runs on a variety of desktop platforms (including Microsoft Windows, Linux, FreeBSD, Apple MacOSX and Sun Solaris), game consoles (inclusing Microsoft Xbox 360, Microsoft Xbox One, Nintendo Wii, Sony Playstation Portable and Sony Playstation 3) and mobile platforms (including Android, iOS, BlackBerry, Samsung bada and Microsoft Windows CE).</p>
</div>
<div class="paragraph">
<p>pugixml supports various architectures, such as x86/x86-64, PowerPC, ARM, MIPS and SPARC. In general it should run on any architecture since it does not use architecture-specific code and does not rely on features such as unaligned memory access.</p>
</div>
<div class="paragraph">
<p>pugixml can be compiled using any C++ compiler; it was tested with all versions of Microsoft Visual C&#43;&#43; from 6.0 up to 2015, GCC from 3.4 up to 5.2, Clang from 3.2 up to 3.7, as well as a variety of other compilers (e.g. Borland C&#43;&#43;, Digital Mars C&#43;&#43;, Intel C&#43;&#43;, Metrowerks CodeWarrior and PathScale). The code is written to avoid compilation warnings even on reasonably high warning levels.</p>
</div>
<div class="paragraph">
<p>Note that some platforms may have very bare-bones support of C++; in some cases you&#8217;ll have to use <code>PUGIXML_NO_STL</code> and/or <code>PUGIXML_NO_EXCEPTIONS</code> to compile without issues. This mostly applies to old game consoles and embedded systems.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="dom"><a class="anchor" href="#dom"></a>3. Document object model</h2>
<div class="sectionbody">
<div class="paragraph">
<p>pugixml stores XML data in DOM-like way: the entire XML document (both document structure and element data) is stored in memory as a tree. The tree can be loaded from a character stream (file, string, C&#43;&#43; I/O stream), then traversed with the special API or XPath expressions. The whole tree is mutable: both node structure and node/attribute data can be changed at any time. Finally, the result of document transformations can be saved to a character stream (file, C&#43;&#43; I/O stream or custom transport).</p>
</div>
<div class="sect2">
<h3 id="dom.tree"><a class="anchor" href="#dom.tree"></a>3.1. Tree structure</h3>
<div class="paragraph">
<p>The XML document is represented with a tree data structure. The root of the tree is the document itself, which corresponds to C&#43;&#43; type <a href="#xml_document">xml_document</a>. Document has one or more child nodes, which correspond to C&#43;&#43; type <a href="#xml_node">xml_node</a>. Nodes have different types; depending on a type, a node can have a collection of child nodes, a collection of attributes, which correspond to C&#43;&#43; type <a href="#xml_attribute">xml_attribute</a>, and some additional data (i.e. name).</p>
</div>
<div id="xml_node_type" class="paragraph">
<p>The tree nodes can be of one of the following types (which together form the enumeration <code>xml_node_type</code>):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Document node (<a id="node_document"></a><code>node_document</code>) - this is the root of the tree, which consists of several child nodes. This node corresponds to <a href="#xml_document">xml_document</a> class; note that <a href="#xml_document">xml_document</a> is a sub-class of <a href="#xml_node">xml_node</a>, so the entire node interface is also available. However, document node is special in several ways, which are covered below. There can be only one document node in the tree; document node does not have any XML representation.</p>
</li>
<li>
<p>Element/tag node (<a id="node_element"></a><code>node_element</code>) - this is the most common type of node, which represents XML elements. Element nodes have a name, a collection of attributes and a collection of child nodes (both of which may be empty). The attribute is a simple name/value pair. The example XML representation of element nodes is as follows:</p>
<div class="listingblock">
<div class="content">
<pre>&lt;node attr="value"&gt;&lt;child/&gt;&lt;/node&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>There are two element nodes here: one has name <code>"node"</code>, single attribute <code>"attr"</code> and single child <code>"child"</code>, another has name <code>"child"</code> and does not have any attributes or child nodes.</p>
</div>
</li>
<li>
<p>Plain character data nodes (<a id="node_pcdata"></a><code>node_pcdata</code>) represent plain text in XML. PCDATA nodes have a value, but do not have a name or children/attributes. Note that <strong>plain character data is not a part of the element node but instead has its own node</strong>; an element node can have several child PCDATA nodes. The example XML representation of text nodes is as follows:</p>
<div class="listingblock">
<div class="content">
<pre>&lt;node&gt; text1 &lt;child/&gt; text2 &lt;/node&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Here <code>"node"</code> element has three children, two of which are PCDATA nodes with values <code>" text1 "</code> and <code>" text2 "</code>.</p>
</div>
</li>
<li>
<p>Character data nodes (<a id="node_cdata"></a><code>node_cdata</code>) represent text in XML that is quoted in a special way. CDATA nodes do not differ from PCDATA nodes except in XML representation - the above text example looks like this with CDATA:</p>
<div class="listingblock">
<div class="content">
<pre>&lt;node&gt; &lt;![CDATA[text1]]&gt; &lt;child/&gt; &lt;![CDATA[text2]]&gt; &lt;/node&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>CDATA nodes make it easy to include non-escaped <code>&lt;</code>, <code>&amp;</code> and <code>&gt;</code> characters in plain text. CDATA value can not contain the character sequence <code>]]&gt;</code>, since it is used to determine the end of node contents.</p>
</div>
</li>
<li>
<p>Comment nodes (<a id="node_comment"></a><code>node_comment</code>) represent comments in XML. Comment nodes have a value, but do not have a name or children/attributes. The example XML representation of a comment node is as follows:</p>
<div class="listingblock">
<div class="content">
<pre>&lt;!-- comment text --&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Here the comment node has value <code>"comment text"</code>. By default comment nodes are treated as non-essential part of XML markup and are not loaded during XML parsing. You can override this behavior with <a href="#parse_comments">parse_comments</a> flag.</p>
</div>
</li>
<li>
<p>Processing instruction node (<a id="node_pi"></a><code>node_pi</code>) represent processing instructions (PI) in XML. PI nodes have a name and an optional value, but do not have children/attributes. The example XML representation of a PI node is as follows:</p>
<div class="listingblock">
<div class="content">
<pre>&lt;?name value?&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Here the name (also called PI target) is <code>"name"</code>, and the value is <code>"value"</code>. By default PI nodes are treated as non-essential part of XML markup and are not loaded during XML parsing. You can override this behavior with <a href="#parse_pi">parse_pi</a> flag.</p>
</div>
</li>
<li>
<p>Declaration node (<a id="node_declaration"></a><code>node_declaration</code>) represents document declarations in XML. Declaration nodes have a name (<code>"xml"</code>) and an optional collection of attributes, but do not have value or children. There can be only one declaration node in a document; moreover, it should be the topmost node (its parent should be the document). The example XML representation of a declaration node is as follows:</p>
<div class="listingblock">
<div class="content">
<pre>&lt;?xml version="1.0"?&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Here the node has name <code>"xml"</code> and a single attribute with name <code>"version"</code> and value <code>"1.0"</code>. By default declaration nodes are treated as non-essential part of XML markup and are not loaded during XML parsing. You can override this behavior with <a href="#parse_declaration">parse_declaration</a> flag. Also, by default a dummy declaration is output when XML document is saved unless there is already a declaration in the document; you can disable this with <a href="#format_no_declaration">format_no_declaration</a> flag.</p>
</div>
</li>
<li>
<p>Document type declaration node (<a id="node_doctype"></a><code>node_doctype</code>) represents document type declarations in XML. Document type declaration nodes have a value, which corresponds to the entire document type contents; no additional nodes are created for inner elements like <code>&lt;!ENTITY&gt;</code>. There can be only one document type declaration node in a document; moreover, it should be the topmost node (its parent should be the document). The example XML representation of a document type declaration node is as follows:</p>
<div class="listingblock">
<div class="content">
<pre>&lt;!DOCTYPE greeting [ &lt;!ELEMENT greeting (#PCDATA)&gt; ]&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Here the node has value <code>"greeting [ &lt;!ELEMENT greeting (#PCDATA)&gt; ]"</code>. By default document type declaration nodes are treated as non-essential part of XML markup and are not loaded during XML parsing. You can override this behavior with <a href="#parse_doctype">parse_doctype</a> flag.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Finally, here is a complete example of XML document and the corresponding tree representation (<a href="samples/tree.xml" class="bare">samples/tree.xml</a>):</p>
</div>
<table class="tableblock frame-none grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="xml"><span class="tok-cp">&lt;?xml version=&quot;1.0&quot;?&gt;</span>
<span class="tok-nt">&lt;mesh</span> <span class="tok-na">name=</span><span class="tok-s">&quot;mesh_root&quot;</span><span class="tok-nt">&gt;</span>
    <span class="tok-c">&lt;!-- here is a mesh node --&gt;</span>
    some text
    <span class="tok-cp">&lt;![CDATA[someothertext]]&gt;</span>
    some more text
    <span class="tok-nt">&lt;node</span> <span class="tok-na">attr1=</span><span class="tok-s">&quot;value1&quot;</span> <span class="tok-na">attr2=</span><span class="tok-s">&quot;value2&quot;</span> <span class="tok-nt">/&gt;</span>
    <span class="tok-nt">&lt;node</span> <span class="tok-na">attr1=</span><span class="tok-s">&quot;value2&quot;</span><span class="tok-nt">&gt;</span>
        <span class="tok-nt">&lt;innernode/&gt;</span>
    <span class="tok-nt">&lt;/node&gt;</span>
<span class="tok-nt">&lt;/mesh&gt;</span>
<span class="tok-cp">&lt;?include somedata?&gt;</span></code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div><div class="imageblock">
<div class="content">
<a class="image" href="images/dom_tree.png"><img src="images/dom_tree.png" alt="dom tree"></a>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="dom.cpp"><a class="anchor" href="#dom.cpp"></a>3.2. C&#43;&#43; interface</h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
All pugixml classes and functions are located in the <code>pugi</code> namespace; you have to either use explicit name qualification (i.e. <code>pugi::xml_node</code>), or to gain access to relevant symbols via <code>using</code> directive (i.e. <code>using pugi::xml_node;</code> or <code>using namespace pugi;</code>). The namespace will be omitted from all declarations in this documentation hereafter; all code examples will use fully qualified names.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Despite the fact that there are several node types, there are only three C&#43;&#43; classes representing the tree (<code>xml_document</code>, <code>xml_node</code>, <code>xml_attribute</code>); some operations on <code>xml_node</code> are only valid for certain node types. The classes are described below.</p>
</div>
<div class="paragraph">
<p><a id="xml_document"></a><a id="xml_document::document_element"></a>
<code>xml_document</code> is the owner of the entire document structure; it is a non-copyable class. The interface of <code>xml_document</code> consists of loading functions (see <a href="#loading">Loading document</a>), saving functions (see <a href="#saving">Saving document</a>) and the entire interface of <code>xml_node</code>, which allows for document inspection and/or modification. Note that while <code>xml_document</code> is a sub-class of <code>xml_node</code>, <code>xml_node</code> is not a polymorphic type; the inheritance is present only to simplify usage. Alternatively you can use the <code>document_element</code> function to get the element node that&#8217;s the immediate child of the document.</p>
</div>
<div class="paragraph">
<p><a id="xml_document::ctor"></a><a id="xml_document::dtor"></a><a id="xml_document::reset"></a>
Default constructor of <code>xml_document</code> initializes the document to the tree with only a root node (document node). You can then populate it with data using either tree modification functions or loading functions; all loading functions destroy the previous tree with all occupied memory, which puts existing node/attribute handles for this document to invalid state. If you want to destroy the previous tree, you can use the <code>xml_document::reset</code> function; it destroys the tree and replaces it with either an empty one or a copy of the specified document. Destructor of <code>xml_document</code> also destroys the tree, thus the lifetime of the document object should exceed the lifetimes of any node/attribute handles that point to the tree.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
While technically node/attribute handles can be alive when the tree they&#8217;re referring to is destroyed, calling any member function for these handles results in undefined behavior. Thus it is recommended to make sure that the document is destroyed only after all references to its nodes/attributes are destroyed.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><a id="xml_node"></a><a id="xml_node::type"></a>
<code>xml_node</code> is the handle to document node; it can point to any node in the document, including the document node itself. There is a common interface for nodes of all types; the actual <a href="#xml_node_type">node type</a> can be queried via the <code>xml_node::type()</code> method. Note that <code>xml_node</code> is only a handle to the actual node, not the node itself - you can have several <code>xml_node</code> handles pointing to the same underlying object. Destroying <code>xml_node</code> handle does not destroy the node and does not remove it from the tree. The size of <code>xml_node</code> is equal to that of a pointer, so it is nothing more than a lightweight wrapper around a pointer; you can safely pass or return <code>xml_node</code> objects by value without additional overhead.</p>
</div>
<div id="node_null" class="paragraph">
<p>There is a special value of <code>xml_node</code> type, known as null node or empty node (such nodes have type <code>node_null</code>). It does not correspond to any node in any document, and thus resembles null pointer. However, all operations are defined on empty nodes; generally the operations don&#8217;t do anything and return empty nodes/attributes or empty strings as their result (see documentation for specific functions for more detailed information). This is useful for chaining calls; i.e. you can get the grandparent of a node like so: <code>node.parent().parent()</code>; if a node is a null node or it does not have a parent, the first <code>parent()</code> call returns null node; the second <code>parent()</code> call then also returns null node, which makes error handling easier.</p>
</div>
<div id="xml_attribute" class="paragraph">
<p><code>xml_attribute</code> is the handle to an XML attribute; it has the same semantics as <code>xml_node</code>, i.e. there can be several <code>xml_attribute</code> handles pointing to the same underlying object and there is a special null attribute value, which propagates to function results.</p>
</div>
<div class="paragraph">
<p><a id="xml_attribute::ctor"></a><a id="xml_node::ctor"></a>
Both <code>xml_node</code> and <code>xml_attribute</code> have the default constructor which initializes them to null objects.</p>
</div>
<div class="paragraph">
<p><a id="xml_attribute::comparison"></a><a id="xml_node::comparison"></a>
<code>xml_node</code> and <code>xml_attribute</code> try to behave like pointers, that is, they can be compared with other objects of the same type, making it possible to use them as keys in associative containers. All handles to the same underlying object are equal, and any two handles to different underlying objects are not equal. Null handles only compare as equal to themselves. The result of relational comparison can not be reliably determined from the order of nodes in file or in any other way. Do not use relational comparison operators except for search optimization (i.e. associative container keys).</p>
</div>
<div class="paragraph">
<p><a id="xml_attribute::hash_value"></a><a id="xml_node::hash_value"></a>
If you want to use <code>xml_node</code> or <code>xml_attribute</code> objects as keys in hash-based associative containers, you can use the <code>hash_value</code> member functions. They return the hash values that are guaranteed to be the same for all handles to the same underlying object. The hash value for null handles is 0. Note that hash value does not depend on the content of the node, only on the location of the underlying structure in memory - this means that loading the same document twice will likely produce different hash values, and copying the node will not preserve the hash.</p>
</div>
<div class="paragraph">
<p><a id="xml_attribute::unspecified_bool_type"></a><a id="xml_node::unspecified_bool_type"></a><a id="xml_attribute::empty"></a><a id="xml_node::empty"></a>
Finally handles can be implicitly cast to boolean-like objects, so that you can test if the node/attribute is empty with the following code: <code>if (node) { &#8230;&#8203; }</code> or <code>if (!node) { &#8230;&#8203; } else { &#8230;&#8203; }</code>. Alternatively you can check if a given <code>xml_node</code>/<code>xml_attribute</code> handle is null by calling the following methods:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-kt">bool</span> <span class="tok-n">xml_attribute</span><span class="tok-o">::</span><span class="tok-n">empty</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-kt">bool</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">empty</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Nodes and attributes do not exist without a document tree, so you can&#8217;t create them without adding them to some document. Once underlying node/attribute objects are destroyed, the handles to those objects become invalid. While this means that destruction of the entire tree invalidates all node/attribute handles, it also means that destroying a subtree (by calling <a href="#xml_node::remove_child">xml_node::remove_child</a>) or removing an attribute invalidates the corresponding handles. There is no way to check handle validity; you have to ensure correctness through external mechanisms.</p>
</div>
</div>
<div class="sect2">
<h3 id="dom.unicode"><a class="anchor" href="#dom.unicode"></a>3.3. Unicode interface</h3>
<div class="paragraph">
<p>There are two choices of interface and internal representation when configuring pugixml: you can either choose the UTF-8 (also called char) interface or UTF-16/32 (also called wchar_t) one. The choice is controlled via <a href="#PUGIXML_WCHAR_MODE">PUGIXML_WCHAR_MODE</a> define; you can set it via <code>pugiconfig.hpp</code> or via preprocessor options, as discussed in <a href="#install.building.config">Additional configuration options</a>. If this define is set, the wchar_t interface is used; otherwise (by default) the char interface is used. The exact wide character encoding is assumed to be either UTF-16 or UTF-32 and is determined based on the size of <code>wchar_t</code> type.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
If the size of <code>wchar_t</code> is 2, pugixml assumes UTF-16 encoding instead of UCS-2, which means that some characters are represented as two code points.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>All tree functions that work with strings work with either C-style null terminated strings or STL strings of the selected character type. For example, node name accessors look like this in char mode:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-k">const</span> <span class="tok-kt">char</span><span class="tok-o">*</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">name</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-kt">bool</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">set_name</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char</span><span class="tok-o">*</span> <span class="tok-n">value</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>and like this in wchar_t mode:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-k">const</span> <span class="tok-kt">wchar_t</span><span class="tok-o">*</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">name</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-kt">bool</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">set_name</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">wchar_t</span><span class="tok-o">*</span> <span class="tok-n">value</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><a id="char_t"></a><a id="string_t"></a>
There is a special type, <code>pugi::char_t</code>, that is defined as the character type and depends on the library configuration; it will be also used in the documentation hereafter. There is also a type <code>pugi::string_t</code>, which is defined as the STL string of the character type; it corresponds to <code>std::string</code> in char mode and to <code>std::wstring</code> in wchar_t mode.</p>
</div>
<div class="paragraph">
<p>In addition to the interface, the internal implementation changes to store XML data as <code>pugi::char_t</code>; this means that these two modes have different memory usage characteristics - generally UTF-8 mode is more memory and performance efficient, especially if <code>sizeof(wchar_t)</code> is 4. The conversion to <code>pugi::char_t</code> upon document loading and from <code>pugi::char_t</code> upon document saving happen automatically, which also carries minor performance penalty. The general advice however is to select the character mode based on usage scenario, i.e. if UTF-8 is inconvenient to process and most of your XML data is non-ASCII, wchar_t mode is probably a better choice.</p>
</div>
<div class="paragraph">
<p><a id="as_utf8"></a><a id="as_wide"></a>
There are cases when you&#8217;ll have to convert string data between UTF-8 and wchar_t encodings; the following helper functions are provided for such purposes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">string</span> <span class="tok-n">as_utf8</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">wchar_t</span><span class="tok-o">*</span> <span class="tok-n">str</span><span class="tok-p">);</span>
<span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">wstring</span> <span class="tok-n">as_wide</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char</span><span class="tok-o">*</span> <span class="tok-n">str</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Both functions accept a null-terminated string as an argument <code>str</code>, and return the converted string. <code>as_utf8</code> performs conversion from UTF-16/32 to UTF-8; <code>as_wide</code> performs conversion from UTF-8 to UTF-16/32. Invalid UTF sequences are silently discarded upon conversion. <code>str</code> has to be a valid string; passing null pointer results in undefined behavior. There are also two overloads with the same semantics which accept a string as an argument:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">string</span> <span class="tok-n">as_utf8</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">wstring</span><span class="tok-o">&amp;</span> <span class="tok-n">str</span><span class="tok-p">);</span>
<span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">wstring</span> <span class="tok-n">as_wide</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">string</span><span class="tok-o">&amp;</span> <span class="tok-n">str</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>Most examples in this documentation assume char interface and therefore will not compile with <a href="#PUGIXML_WCHAR_MODE">PUGIXML_WCHAR_MODE</a>. This is done to simplify the documentation; usually the only changes you&#8217;ll have to make is to pass <code>wchar_t</code> string literals, i.e. instead of</p>
</div>
<div class="paragraph">
<p><code>xml_node node = doc.child("bookstore").find_child_by_attribute("book", "id", "12345");</code></p>
</div>
<div class="paragraph">
<p>you&#8217;ll have to use</p>
</div>
<div class="paragraph">
<p><code>xml_node node = doc.child(L"bookstore").find_child_by_attribute(L"book", L"id", L"12345");</code></p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="dom.thread"><a class="anchor" href="#dom.thread"></a>3.4. Thread-safety guarantees</h3>
<div class="paragraph">
<p>Almost all functions in pugixml have the following thread-safety guarantees:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>it is safe to call free (non-member) functions from multiple threads</p>
</li>
<li>
<p>it is safe to perform concurrent read-only accesses to the same tree (all constant member functions do not modify the tree)</p>
</li>
<li>
<p>it is safe to perform concurrent read/write accesses, if there is only one read or write access to the single tree at a time</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Concurrent modification and traversing of a single tree requires synchronization, for example via reader-writer lock. Modification includes altering document structure and altering individual node/attribute data, i.e. changing names/values.</p>
</div>
<div class="paragraph">
<p>The only exception is <a href="#set_memory_management_functions">set_memory_management_functions</a>; it modifies global variables and as such is not thread-safe. Its usage policy has more restrictions, see <a href="#dom.memory.custom">Custom memory allocation/deallocation functions</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="dom.exception"><a class="anchor" href="#dom.exception"></a>3.5. Exception guarantees</h3>
<div class="paragraph">
<p>With the exception of XPath, pugixml itself does not throw any exceptions. Additionally, most pugixml functions have a no-throw exception guarantee.</p>
</div>
<div class="paragraph">
<p>This is not applicable to functions that operate on STL strings or IOstreams; such functions have either strong guarantee (functions that operate on strings) or basic guarantee (functions that operate on streams). Also functions that call user-defined callbacks (i.e. <a href="#xml_node::traverse">xml_node::traverse</a> or <a href="#xml_node::find_node">xml_node::find_node</a>) do not provide any exception guarantees beyond the ones provided by the callback.</p>
</div>
<div class="paragraph">
<p>If exception handling is not disabled with <a href="#PUGIXML_NO_EXCEPTIONS">PUGIXML_NO_EXCEPTIONS</a> define, XPath functions may throw <a href="#xpath_exception">xpath_exception</a> on parsing errors; also, XPath functions may throw <code>std::bad_alloc</code> in low memory conditions. Still, XPath functions provide strong exception guarantee.</p>
</div>
</div>
<div class="sect2">
<h3 id="dom.memory"><a class="anchor" href="#dom.memory"></a>3.6. Memory management</h3>
<div class="paragraph">
<p>pugixml requests the memory needed for document storage in big chunks, and allocates document data inside those chunks. This section discusses replacing functions used for chunk allocation and internal memory management implementation.</p>
</div>
<div class="sect3">
<h4 id="dom.memory.custom"><a class="anchor" href="#dom.memory.custom"></a>3.6.1. Custom memory allocation/deallocation functions</h4>
<div class="paragraph">
<p><a id="allocation_function"></a><a id="deallocation_function"></a>
All memory for tree structure, tree data and XPath objects is allocated via globally specified functions, which default to malloc/free. You can set your own allocation functions with set_memory_management function. The function interfaces are the same as that of malloc/free:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-k">typedef</span> <span class="tok-kt">void</span><span class="tok-o">*</span> <span class="tok-p">(</span><span class="tok-o">*</span><span class="tok-n">allocation_function</span><span class="tok-p">)(</span><span class="tok-kt">size_t</span> <span class="tok-n">size</span><span class="tok-p">);</span>
<span class="tok-k">typedef</span> <span class="tok-nf">void</span> <span class="tok-p">(</span><span class="tok-o">*</span><span class="tok-n">deallocation_function</span><span class="tok-p">)(</span><span class="tok-kt">void</span><span class="tok-o">*</span> <span class="tok-n">ptr</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><a id="set_memory_management_functions"></a><a id="get_memory_allocation_function"></a><a id="get_memory_deallocation_function"></a>
You can use the following accessor functions to change or get current memory management functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-kt">void</span> <span class="tok-nf">set_memory_management_functions</span><span class="tok-p">(</span><span class="tok-n">allocation_function</span> <span class="tok-n">allocate</span><span class="tok-p">,</span> <span class="tok-n">deallocation_function</span> <span class="tok-n">deallocate</span><span class="tok-p">);</span>
<span class="tok-n">allocation_function</span> <span class="tok-nf">get_memory_allocation_function</span><span class="tok-p">();</span>
<span class="tok-n">deallocation_function</span> <span class="tok-nf">get_memory_deallocation_function</span><span class="tok-p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Allocation function is called with the size (in bytes) as an argument and should return a pointer to a memory block with alignment that is suitable for storage of primitive types (usually a maximum of <code>void*</code> and <code>double</code> types alignment is sufficient) and size that is greater than or equal to the requested one. If the allocation fails, the function has to either return null pointer or to throw an exception.</p>
</div>
<div class="paragraph">
<p>Deallocation function is called with the pointer that was returned by some call to allocation function; it is never called with a null pointer. If memory management functions are not thread-safe, library thread safety is not guaranteed.</p>
</div>
<div class="paragraph">
<p>This is a simple example of custom memory management (<a href="samples/custom_memory_management.cpp" class="bare">samples/custom_memory_management.cpp</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-kt">void</span><span class="tok-o">*</span> <span class="tok-nf">custom_allocate</span><span class="tok-p">(</span><span class="tok-kt">size_t</span> <span class="tok-n">size</span><span class="tok-p">)</span>
<span class="tok-p">{</span>
    <span class="tok-k">return</span> <span class="tok-k">new</span> <span class="tok-p">(</span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">nothrow</span><span class="tok-p">)</span> <span class="tok-kt">char</span><span class="tok-p">[</span><span class="tok-n">size</span><span class="tok-p">];</span>
<span class="tok-p">}</span>

<span class="tok-kt">void</span> <span class="tok-nf">custom_deallocate</span><span class="tok-p">(</span><span class="tok-kt">void</span><span class="tok-o">*</span> <span class="tok-n">ptr</span><span class="tok-p">)</span>
<span class="tok-p">{</span>
    <span class="tok-k">delete</span><span class="tok-p">[]</span> <span class="tok-k">static_cast</span><span class="tok-o">&lt;</span><span class="tok-kt">char</span><span class="tok-o">*&gt;</span><span class="tok-p">(</span><span class="tok-n">ptr</span><span class="tok-p">);</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">set_memory_management_functions</span><span class="tok-p">(</span><span class="tok-n">custom_allocate</span><span class="tok-p">,</span> <span class="tok-n">custom_deallocate</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>When setting new memory management functions, care must be taken to make sure that there are no live pugixml objects. Otherwise when the objects are destroyed, the new deallocation function will be called with the memory obtained by the old allocation function, resulting in undefined behavior.</p>
</div>
</div>
<div class="sect3">
<h4 id="dom.memory.tuning"><a class="anchor" href="#dom.memory.tuning"></a>3.6.2. Memory consumption tuning</h4>
<div class="paragraph">
<p>There are several important buffering optimizations in pugixml that rely on predefined constants. These constants have default values that were tuned for common usage patterns; for some applications, changing these constants might improve memory consumption or increase performance. Changing these constants is not recommended unless their default values result in visible problems.</p>
</div>
<div class="paragraph">
<p>These constants can be tuned via configuration defines, as discussed in <a href="#install.building.config">Additional configuration options</a>; it is recommended to set them in <code>pugiconfig.hpp</code>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>PUGIXML_MEMORY_PAGE_SIZE</code> controls the page size for document memory allocation. Memory for node/attribute objects is allocated in pages of the specified size. The default size is 32 Kb; for some applications the size is too large (i.e. embedded systems with little heap space or applications that keep lots of XML documents in memory). A minimum size of 1 Kb is recommended.</p>
</li>
<li>
<p><code>PUGIXML_MEMORY_OUTPUT_STACK</code> controls the cumulative stack space required to output the node. Any output operation (i.e. saving a subtree to file) uses an internal buffering scheme for performance reasons. The default size is 10 Kb; if you&#8217;re using node output from threads with little stack space, decreasing this value can prevent stack overflows. A minimum size of 1 Kb is recommended.</p>
</li>
<li>
<p><code>PUGIXML_MEMORY_XPATH_PAGE_SIZE</code> controls the page size for XPath memory allocation. Memory for XPath query objects as well as internal memory for XPath evaluation is allocated in pages of the specified size. The default size is 4 Kb; if you have a lot of resident XPath query objects, you might need to decrease the size to improve memory consumption. A minimum size of 256 bytes is recommended.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="dom.memory.internals"><a class="anchor" href="#dom.memory.internals"></a>3.6.3. Document memory management internals</h4>
<div class="paragraph">
<p>Constructing a document object using the default constructor does not result in any allocations; document node is stored inside the <a href="#xml_document">xml_document</a> object.</p>
</div>
<div class="paragraph">
<p>When the document is loaded from file/buffer, unless an inplace loading function is used (see <a href="#loading.memory">Loading document from memory</a>), a complete copy of character stream is made; all names/values of nodes and attributes are allocated in this buffer. This buffer is allocated via a single large allocation and is only freed when document memory is reclaimed (i.e. if the <a href="#xml_document">xml_document</a> object is destroyed or if another document is loaded in the same object). Also when loading from file or stream, an additional large allocation may be performed if encoding conversion is required; a temporary buffer is allocated, and it is freed before load function returns.</p>
</div>
<div class="paragraph">
<p>All additional memory, such as memory for document structure (node/attribute objects) and memory for node/attribute names/values is allocated in pages on the order of 32 Kb; actual objects are allocated inside the pages using a memory management scheme optimized for fast allocation/deallocation of many small objects. Because of the scheme specifics, the pages are only destroyed if all objects inside them are destroyed; also, generally destroying an object does not mean that subsequent object creation will reuse the same memory. This means that it is possible to devise a usage scheme which will lead to higher memory usage than expected; one example is adding a lot of nodes, and them removing all even numbered ones; not a single page is reclaimed in the process. However this is an example specifically crafted to produce unsatisfying behavior; in all practical usage scenarios the memory consumption is less than that of a general-purpose allocator because allocation meta-data is very small in size.</p>
</div>
</div>
<div class="sect3">
<h4 id="dom.memory.compact"><a class="anchor" href="#dom.memory.compact"></a>3.6.4. Compact mode</h4>
<div class="paragraph">
<p>By default nodes and attributes are optimized for efficiency of access. This can cause them to take a significant amount of memory - for documents with a lot of nodes and not a lot of contents (short attribute values/node text), and depending on the pointer size, the document structure can take noticeably more memory than the document itself (e.g. on a 64-bit platform in UTF-8 mode a markup-heavy document with the file size of 2.1 Mb can use 2.1 Mb for document buffer and 8.3 Mb for document structure).</p>
</div>
<div class="paragraph">
<p>If you are processing big documents or your platform is memory constrained and you&#8217;re willing to sacrifice a bit of performance for memory, you can compile pugixml with <code>PUGIXML_COMPACT</code> define which will activate compact mode. Compact mode uses a different representation of the document structure that assumes locality of reference between nodes and attributes to optimize memory usage. As a result you get significantly smaller node/attribute objects; usually most objects in most documents don&#8217;t require additional storage, but in the worst case - if assumptions about locality of reference don&#8217;t hold - additional memory will be allocated to store the extra data required.</p>
</div>
<div class="paragraph">
<p>The compact storage supports all existing operations - including tree modification - with the same amortized complexity (that is, all basic document manipulations are still O(1) on average). The operations are slightly slower; you can usually expect 10-50% slowdown in terms of processing time unless your processing was memory-bound.</p>
</div>
<div class="paragraph">
<p>On 32-bit architectures document structure in compact mode is typically reduced by around 2.5x; on 64-bit architectures the ratio is around 5x. Thus for big markup-heavy documents compact mode can make the difference between the processing of a multi-gigabyte document running completely from RAM vs requiring swapping to disk. Even if the document fits into memory, compact storage can use CPU caches more efficiently by taking less space and causing less cache/TLB misses.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="loading"><a class="anchor" href="#loading"></a>4. Loading document</h2>
<div class="sectionbody">
<div class="paragraph">
<p>pugixml provides several functions for loading XML data from various places - files, C&#43;&#43; iostreams, memory buffers. All functions use an extremely fast non-validating parser. This parser is not fully W3C conformant - it can load any valid XML document, but does not perform some well-formedness checks. While considerable effort is made to reject invalid XML documents, some validation is not performed for performance reasons. Also some XML transformations (i.e. EOL handling or attribute value normalization) can impact parsing speed and thus can be disabled. However for vast majority of XML documents there is no performance difference between different parsing options. Parsing options also control whether certain XML nodes are parsed; see <a href="#loading.options">Parsing options</a> for more information.</p>
</div>
<div class="paragraph">
<p>XML data is always converted to internal character format (see <a href="#dom.unicode">Unicode interface</a>) before parsing. pugixml supports all popular Unicode encodings (UTF-8, UTF-16 (big and little endian), UTF-32 (big and little endian); UCS-2 is naturally supported since it&#8217;s a strict subset of UTF-16) and handles all encoding conversions automatically. Unless explicit encoding is specified, loading functions perform automatic encoding detection based on first few characters of XML data, so in almost all cases you do not have to specify document encoding. Encoding conversion is described in more detail in <a href="#loading.encoding">Encodings</a>.</p>
</div>
<div class="sect2">
<h3 id="loading.file"><a class="anchor" href="#loading.file"></a>4.1. Loading document from file</h3>
<div class="paragraph">
<p><a id="xml_document::load_file"></a><a id="xml_document::load_file_wide"></a>
The most common source of XML data is files; pugixml provides dedicated functions for loading an XML document from file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-n">xml_parse_result</span> <span class="tok-n">xml_document</span><span class="tok-o">::</span><span class="tok-n">load_file</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char</span><span class="tok-o">*</span> <span class="tok-n">path</span><span class="tok-p">,</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">options</span> <span class="tok-o">=</span> <span class="tok-n">parse_default</span><span class="tok-p">,</span> <span class="tok-n">xml_encoding</span> <span class="tok-n">encoding</span> <span class="tok-o">=</span> <span class="tok-n">encoding_auto</span><span class="tok-p">);</span>
<span class="tok-n">xml_parse_result</span> <span class="tok-n">xml_document</span><span class="tok-o">::</span><span class="tok-n">load_file</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">wchar_t</span><span class="tok-o">*</span> <span class="tok-n">path</span><span class="tok-p">,</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">options</span> <span class="tok-o">=</span> <span class="tok-n">parse_default</span><span class="tok-p">,</span> <span class="tok-n">xml_encoding</span> <span class="tok-n">encoding</span> <span class="tok-o">=</span> <span class="tok-n">encoding_auto</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>These functions accept the file path as its first argument, and also two optional arguments, which specify parsing options (see <a href="#loading.options">Parsing options</a>) and input data encoding (see <a href="#loading.encoding">Encodings</a>). The path has the target operating system format, so it can be a relative or absolute one, it should have the delimiters of the target system, it should have the exact case if the target file system is case-sensitive, etc.</p>
</div>
<div class="paragraph">
<p>File path is passed to the system file opening function as is in case of the first function (which accepts <code>const char* path</code>); the second function either uses a special file opening function if it is provided by the runtime library or converts the path to UTF-8 and uses the system file opening function.</p>
</div>
<div class="paragraph">
<p><code>load_file</code> destroys the existing document tree and then tries to load the new tree from the specified file. The result of the operation is returned in an <a href="#xml_parse_result">xml_parse_result</a> object; this object contains the operation status and the related information (i.e. last successfully parsed position in the input file, if parsing fails). See <a href="#loading.errors">Handling parsing errors</a> for error handling details.</p>
</div>
<div class="paragraph">
<p>This is an example of loading XML document from file (<a href="samples/load_file.cpp" class="bare">samples/load_file.cpp</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xml_document</span> <span class="tok-n">doc</span><span class="tok-p">;</span>

<span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xml_parse_result</span> <span class="tok-n">result</span> <span class="tok-o">=</span> <span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">load_file</span><span class="tok-p">(</span><span class="tok-s">&quot;tree.xml&quot;</span><span class="tok-p">);</span>

<span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;Load result: &quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">result</span><span class="tok-p">.</span><span class="tok-n">description</span><span class="tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;, mesh name: &quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">child</span><span class="tok-p">(</span><span class="tok-s">&quot;mesh&quot;</span><span class="tok-p">).</span><span class="tok-n">attribute</span><span class="tok-p">(</span><span class="tok-s">&quot;name&quot;</span><span class="tok-p">).</span><span class="tok-n">value</span><span class="tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">endl</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="loading.memory"><a class="anchor" href="#loading.memory"></a>4.2. Loading document from memory</h3>
<div class="paragraph">
<p><a id="xml_document::load_buffer"></a><a id="xml_document::load_buffer_inplace"></a><a id="xml_document::load_buffer_inplace_own"></a>
Sometimes XML data should be loaded from some other source than a file, i.e. HTTP URL; also you may want to load XML data from file using non-standard functions, i.e. to use your virtual file system facilities or to load XML from GZip-compressed files. All these scenarios require loading document from memory. First you should prepare a contiguous memory block with all XML data; then you have to invoke one of buffer loading functions. These functions will handle the necessary encoding conversions, if any, and then will parse the data into the corresponding XML tree. There are several buffer loading functions, which differ in the behavior and thus in performance/memory usage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-n">xml_parse_result</span> <span class="tok-n">xml_document</span><span class="tok-o">::</span><span class="tok-n">load_buffer</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">void</span><span class="tok-o">*</span> <span class="tok-n">contents</span><span class="tok-p">,</span> <span class="tok-kt">size_t</span> <span class="tok-n">size</span><span class="tok-p">,</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">options</span> <span class="tok-o">=</span> <span class="tok-n">parse_default</span><span class="tok-p">,</span> <span class="tok-n">xml_encoding</span> <span class="tok-n">encoding</span> <span class="tok-o">=</span> <span class="tok-n">encoding_auto</span><span class="tok-p">);</span>
<span class="tok-n">xml_parse_result</span> <span class="tok-n">xml_document</span><span class="tok-o">::</span><span class="tok-n">load_buffer_inplace</span><span class="tok-p">(</span><span class="tok-kt">void</span><span class="tok-o">*</span> <span class="tok-n">contents</span><span class="tok-p">,</span> <span class="tok-kt">size_t</span> <span class="tok-n">size</span><span class="tok-p">,</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">options</span> <span class="tok-o">=</span> <span class="tok-n">parse_default</span><span class="tok-p">,</span> <span class="tok-n">xml_encoding</span> <span class="tok-n">encoding</span> <span class="tok-o">=</span> <span class="tok-n">encoding_auto</span><span class="tok-p">);</span>
<span class="tok-n">xml_parse_result</span> <span class="tok-n">xml_document</span><span class="tok-o">::</span><span class="tok-n">load_buffer_inplace_own</span><span class="tok-p">(</span><span class="tok-kt">void</span><span class="tok-o">*</span> <span class="tok-n">contents</span><span class="tok-p">,</span> <span class="tok-kt">size_t</span> <span class="tok-n">size</span><span class="tok-p">,</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">options</span> <span class="tok-o">=</span> <span class="tok-n">parse_default</span><span class="tok-p">,</span> <span class="tok-n">xml_encoding</span> <span class="tok-n">encoding</span> <span class="tok-o">=</span> <span class="tok-n">encoding_auto</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>All functions accept the buffer which is represented by a pointer to XML data, <code>contents</code>, and data size in bytes. Also there are two optional arguments, which specify parsing options (see <a href="#loading.options">Parsing options</a>) and input data encoding (see <a href="#loading.encoding">Encodings</a>). The buffer does not have to be zero-terminated.</p>
</div>
<div class="paragraph">
<p><code>load_buffer</code> function works with immutable buffer - it does not ever modify the buffer. Because of this restriction it has to create a private buffer and copy XML data to it before parsing (applying encoding conversions if necessary). This copy operation carries a performance penalty, so inplace functions are provided - <code>load_buffer_inplace</code> and <code>load_buffer_inplace_own</code> store the document data in the buffer, modifying it in the process. In order for the document to stay valid, you have to make sure that the buffer&#8217;s lifetime exceeds that of the tree if you&#8217;re using inplace functions. In addition to that, <code>load_buffer_inplace</code> does not assume ownership of the buffer, so you&#8217;ll have to destroy it yourself; <code>load_buffer_inplace_own</code> assumes ownership of the buffer and destroys it once it is not needed. This means that if you&#8217;re using <code>load_buffer_inplace_own</code>, you have to allocate memory with pugixml allocation function (you can get it via <a href="#get_memory_allocation_function">get_memory_allocation_function</a>).</p>
</div>
<div class="paragraph">
<p>The best way from the performance/memory point of view is to load document using <code>load_buffer_inplace_own</code>; this function has maximum control of the buffer with XML data so it is able to avoid redundant copies and reduce peak memory usage while parsing. This is the recommended function if you have to load the document from memory and performance is critical.</p>
</div>
<div id="xml_document::load_string" class="paragraph">
<p>There is also a simple helper function for cases when you want to load the XML document from null-terminated character string:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-n">xml_parse_result</span> <span class="tok-n">xml_document</span><span class="tok-o">::</span><span class="tok-n">load_string</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">contents</span><span class="tok-p">,</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">options</span> <span class="tok-o">=</span> <span class="tok-n">parse_default</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>It is equivalent to calling <code>load_buffer</code> with <code>size</code> being either <code>strlen(contents)</code> or <code>wcslen(contents) * sizeof(wchar_t)</code>, depending on the character type. This function assumes native encoding for input data, so it does not do any encoding conversion. In general, this function is fine for loading small documents from string literals, but has more overhead and less functionality than the buffer loading functions.</p>
</div>
<div class="paragraph">
<p>This is an example of loading XML document from memory using different functions (<a href="samples/load_memory.cpp" class="bare">samples/load_memory.cpp</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-k">const</span> <span class="tok-kt">char</span> <span class="tok-n">source</span><span class="tok-p">[]</span> <span class="tok-o">=</span> <span class="tok-s">&quot;&lt;mesh name=&#39;sphere&#39;&gt;&lt;bounds&gt;0 0 1 1&lt;/bounds&gt;&lt;/mesh&gt;&quot;</span><span class="tok-p">;</span>
<span class="tok-kt">size_t</span> <span class="tok-n">size</span> <span class="tok-o">=</span> <span class="tok-k">sizeof</span><span class="tok-p">(</span><span class="tok-n">source</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-c1">// You can use load_buffer to load document from immutable memory block:</span>
<span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xml_parse_result</span> <span class="tok-n">result</span> <span class="tok-o">=</span> <span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">load_buffer</span><span class="tok-p">(</span><span class="tok-n">source</span><span class="tok-p">,</span> <span class="tok-n">size</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-c1">// You can use load_buffer_inplace to load document from mutable memory block; the block&#39;s lifetime must exceed that of document</span>
<span class="tok-kt">char</span><span class="tok-o">*</span> <span class="tok-n">buffer</span> <span class="tok-o">=</span> <span class="tok-k">new</span> <span class="tok-kt">char</span><span class="tok-p">[</span><span class="tok-n">size</span><span class="tok-p">];</span>
<span class="tok-n">memcpy</span><span class="tok-p">(</span><span class="tok-n">buffer</span><span class="tok-p">,</span> <span class="tok-n">source</span><span class="tok-p">,</span> <span class="tok-n">size</span><span class="tok-p">);</span>

<span class="tok-c1">// The block can be allocated by any method; the block is modified during parsing</span>
<span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xml_parse_result</span> <span class="tok-n">result</span> <span class="tok-o">=</span> <span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">load_buffer_inplace</span><span class="tok-p">(</span><span class="tok-n">buffer</span><span class="tok-p">,</span> <span class="tok-n">size</span><span class="tok-p">);</span>

<span class="tok-c1">// You have to destroy the block yourself after the document is no longer used</span>
<span class="tok-k">delete</span><span class="tok-p">[]</span> <span class="tok-n">buffer</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-c1">// You can use load_buffer_inplace_own to load document from mutable memory block and to pass the ownership of this block</span>
<span class="tok-c1">// The block has to be allocated via pugixml allocation function - using i.e. operator new here is incorrect</span>
<span class="tok-kt">char</span><span class="tok-o">*</span> <span class="tok-n">buffer</span> <span class="tok-o">=</span> <span class="tok-k">static_cast</span><span class="tok-o">&lt;</span><span class="tok-kt">char</span><span class="tok-o">*&gt;</span><span class="tok-p">(</span><span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">get_memory_allocation_function</span><span class="tok-p">()(</span><span class="tok-n">size</span><span class="tok-p">));</span>
<span class="tok-n">memcpy</span><span class="tok-p">(</span><span class="tok-n">buffer</span><span class="tok-p">,</span> <span class="tok-n">source</span><span class="tok-p">,</span> <span class="tok-n">size</span><span class="tok-p">);</span>

<span class="tok-c1">// The block will be deleted by the document</span>
<span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xml_parse_result</span> <span class="tok-n">result</span> <span class="tok-o">=</span> <span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">load_buffer_inplace_own</span><span class="tok-p">(</span><span class="tok-n">buffer</span><span class="tok-p">,</span> <span class="tok-n">size</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-c1">// You can use load to load document from null-terminated strings, for example literals:</span>
<span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xml_parse_result</span> <span class="tok-n">result</span> <span class="tok-o">=</span> <span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">load_string</span><span class="tok-p">(</span><span class="tok-s">&quot;&lt;mesh name=&#39;sphere&#39;&gt;&lt;bounds&gt;0 0 1 1&lt;/bounds&gt;&lt;/mesh&gt;&quot;</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="loading.stream"><a class="anchor" href="#loading.stream"></a>4.3. Loading document from C&#43;&#43; IOstreams</h3>
<div id="xml_document::load_stream" class="paragraph">
<p>To enhance interoperability, pugixml provides functions for loading document from any object which implements C&#43;&#43; <code>std::istream</code> interface. This allows you to load documents from any standard C&#43;&#43; stream (i.e. file stream) or any third-party compliant implementation (i.e. Boost Iostreams). There are two functions, one works with narrow character streams, another handles wide character ones:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-n">xml_parse_result</span> <span class="tok-n">xml_document</span><span class="tok-o">::</span><span class="tok-n">load</span><span class="tok-p">(</span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">istream</span><span class="tok-o">&amp;</span> <span class="tok-n">stream</span><span class="tok-p">,</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">options</span> <span class="tok-o">=</span> <span class="tok-n">parse_default</span><span class="tok-p">,</span> <span class="tok-n">xml_encoding</span> <span class="tok-n">encoding</span> <span class="tok-o">=</span> <span class="tok-n">encoding_auto</span><span class="tok-p">);</span>
<span class="tok-n">xml_parse_result</span> <span class="tok-n">xml_document</span><span class="tok-o">::</span><span class="tok-n">load</span><span class="tok-p">(</span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">wistream</span><span class="tok-o">&amp;</span> <span class="tok-n">stream</span><span class="tok-p">,</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">options</span> <span class="tok-o">=</span> <span class="tok-n">parse_default</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>load</code> with <code>std::istream</code> argument loads the document from stream from the current read position to the end, treating the stream contents as a byte stream of the specified encoding (with encoding autodetection as necessary). Thus calling <code>xml_document::load</code> on an opened <code>std::ifstream</code> object is equivalent to calling <code>xml_document::load_file</code>.</p>
</div>
<div class="paragraph">
<p><code>load</code> with <code>std::wstream</code> argument treats the stream contents as a wide character stream (encoding is always <a href="#encoding_wchar">encoding_wchar</a>). Because of this, using <code>load</code> with wide character streams requires careful (usually platform-specific) stream setup (i.e. using the <code>imbue</code> function). Generally use of wide streams is discouraged, however it provides you the ability to load documents from non-Unicode encodings, i.e. you can load Shift-JIS encoded data if you set the correct locale.</p>
</div>
<div class="paragraph">
<p>This is a simple example of loading XML document from file using streams (<a href="samples/load_stream.cpp" class="bare">samples/load_stream.cpp</a>); read the sample code for more complex examples involving wide streams and locales:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">ifstream</span> <span class="tok-n">stream</span><span class="tok-p">(</span><span class="tok-s">&quot;weekly-utf-8.xml&quot;</span><span class="tok-p">);</span>
<span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xml_parse_result</span> <span class="tok-n">result</span> <span class="tok-o">=</span> <span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">load</span><span class="tok-p">(</span><span class="tok-n">stream</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="loading.errors"><a class="anchor" href="#loading.errors"></a>4.4. Handling parsing errors</h3>
<div id="xml_parse_result" class="paragraph">
<p>All document loading functions return the parsing result via <code>xml_parse_result</code> object. It contains parsing status, the offset of last successfully parsed character from the beginning of the source stream, and the encoding of the source stream:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-k">struct</span> <span class="tok-n">xml_parse_result</span>
<span class="tok-p">{</span>
    <span class="tok-n">xml_parse_status</span> <span class="tok-n">status</span><span class="tok-p">;</span>
    <span class="tok-kt">ptrdiff_t</span> <span class="tok-n">offset</span><span class="tok-p">;</span>
    <span class="tok-n">xml_encoding</span> <span class="tok-n">encoding</span><span class="tok-p">;</span>

    <span class="tok-k">operator</span> <span class="tok-kt">bool</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-k">const</span> <span class="tok-kt">char</span><span class="tok-o">*</span> <span class="tok-n">description</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><a id="xml_parse_status"></a><a id="xml_parse_result::status"></a>
Parsing status is represented as the <code>xml_parse_status</code> enumeration and can be one of the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a id="status_ok"></a><code>status_ok</code> means that no error was encountered during parsing; the source stream represents the valid XML document which was fully parsed and converted to a tree.</p>
</li>
<li>
<p><a id="status_file_not_found"></a><code>status_file_not_found</code> is only returned by <code>load_file</code> function and means that file could not be opened.</p>
</li>
<li>
<p><a id="status_io_error"></a><code>status_io_error</code> is returned by <code>load_file</code> function and by <code>load</code> functions with <code>std::istream</code>/<code>std::wstream</code> arguments; it means that some I/O error has occurred during reading the file/stream.</p>
</li>
<li>
<p><a id="status_out_of_memory"></a><code>status_out_of_memory</code> means that there was not enough memory during some allocation; any allocation failure during parsing results in this error.</p>
</li>
<li>
<p><a id="status_internal_error"></a><code>status_internal_error</code> means that something went horribly wrong; currently this error does not occur</p>
</li>
<li>
<p><a id="status_unrecognized_tag"></a><code>status_unrecognized_tag</code> means that parsing stopped due to a tag with either an empty name or a name which starts with incorrect character, such as <code>#</code>.</p>
</li>
<li>
<p><a id="status_bad_pi"></a><code>status_bad_pi</code> means that parsing stopped due to incorrect document declaration/processing instruction</p>
</li>
<li>
<p><a id="status_bad_comment"></a><code>status_bad_comment</code>, <a id="status_bad_cdata"></a><code>status_bad_cdata</code>, <a id="status_bad_doctype"></a><code>status_bad_doctype</code> and <a id="status_bad_pcdata"></a><code>status_bad_pcdata</code> mean that parsing stopped due to the invalid construct of the respective type</p>
</li>
<li>
<p><a id="status_bad_start_element"></a><code>status_bad_start_element</code> means that parsing stopped because starting tag either had no closing <code>&gt;</code> symbol or contained some incorrect symbol</p>
</li>
<li>
<p><a id="status_bad_attribute"></a><code>status_bad_attribute</code> means that parsing stopped because there was an incorrect attribute, such as an attribute without value or with value that is not quoted (note that <code>&lt;node attr=1&gt;</code> is incorrect in XML)</p>
</li>
<li>
<p><a id="status_bad_end_element"></a><code>status_bad_end_element</code> means that parsing stopped because ending tag had incorrect syntax (i.e. extra non-whitespace symbols between tag name and <code>&gt;</code>)</p>
</li>
<li>
<p><a id="status_end_element_mismatch"></a><code>status_end_element_mismatch</code> means that parsing stopped because the closing tag did not match the opening one (i.e. <code>&lt;node&gt;&lt;/nedo&gt;</code>) or because some tag was not closed at all</p>
</li>
<li>
<p><a id="status_no_document_element"></a><code>status_no_document_element</code> means that no element nodes were discovered during parsing; this usually indicates an empty or invalid document</p>
</li>
</ul>
</div>
<div id="xml_parse_result::description" class="paragraph">
<p><code>description()</code> member function can be used to convert parsing status to a string; the returned message is always in English, so you&#8217;ll have to write your own function if you need a localized string. However please note that the exact messages returned by <code>description()</code> function may change from version to version, so any complex status handling should be based on <code>status</code> value. Note that <code>description()</code> returns a <code>char</code> string even in <code>PUGIXML_WCHAR_MODE</code>; you&#8217;ll have to call <a href="#as_wide">as_wide</a> to get the <code>wchar_t</code> string.</p>
</div>
<div class="paragraph">
<p>If parsing failed because the source data was not a valid XML, the resulting tree is not destroyed - despite the fact that load function returns error, you can use the part of the tree that was successfully parsed. Obviously, the last element may have an unexpected name/value; for example, if the attribute value does not end with the necessary quotation mark, like in <code>&lt;node attr="value&gt;some data&lt;/node&gt;</code> example, the value of attribute <code>attr</code> will contain the string <code>value&gt;some data&lt;/node&gt;</code>.</p>
</div>
<div id="xml_parse_result::offset" class="paragraph">
<p>In addition to the status code, parsing result has an <code>offset</code> member, which contains the offset of last successfully parsed character if parsing failed because of an error in source data; otherwise <code>offset</code> is 0. For parsing efficiency reasons, pugixml does not track the current line during parsing; this offset is in units of <a href="#char_t">pugi::char_t</a> (bytes for character mode, wide characters for wide character mode). Many text editors support 'Go To Position' feature - you can use it to locate the exact error position. Alternatively, if you&#8217;re loading the document from memory, you can display the error chunk along with the error description (see the example code below).</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
Offset is calculated in the XML buffer in native encoding; if encoding conversion is performed during parsing, offset can not be used to reliably track the error position.
</td>
</tr>
</table>
</div>
<div id="xml_parse_result::encoding" class="paragraph">
<p>Parsing result also has an <code>encoding</code> member, which can be used to check that the source data encoding was correctly guessed. It is equal to the exact encoding used during parsing (i.e. with the exact endianness); see <a href="#loading.encoding">Encodings</a> for more information.</p>
</div>
<div id="xml_parse_result::bool" class="paragraph">
<p>Parsing result object can be implicitly converted to <code>bool</code>; if you do not want to handle parsing errors thoroughly, you can just check the return value of load functions as if it was a <code>bool</code>: <code>if (doc.load_file("file.xml")) { &#8230;&#8203; } else { &#8230;&#8203; }</code>.</p>
</div>
<div class="paragraph">
<p>This is an example of handling loading errors (<a href="samples/load_error_handling.cpp" class="bare">samples/load_error_handling.cpp</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xml_document</span> <span class="tok-n">doc</span><span class="tok-p">;</span>
<span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xml_parse_result</span> <span class="tok-n">result</span> <span class="tok-o">=</span> <span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">load_string</span><span class="tok-p">(</span><span class="tok-n">source</span><span class="tok-p">);</span>

<span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">result</span><span class="tok-p">)</span>
<span class="tok-p">{</span>
    <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;XML [&quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">source</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;] parsed without errors, attr value: [&quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">child</span><span class="tok-p">(</span><span class="tok-s">&quot;node&quot;</span><span class="tok-p">).</span><span class="tok-n">attribute</span><span class="tok-p">(</span><span class="tok-s">&quot;attr&quot;</span><span class="tok-p">).</span><span class="tok-n">value</span><span class="tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;]</span><span class="tok-se">\n\n</span><span class="tok-s">&quot;</span><span class="tok-p">;</span>
<span class="tok-p">}</span>
<span class="tok-k">else</span>
<span class="tok-p">{</span>
    <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;XML [&quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">source</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;] parsed with errors, attr value: [&quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">child</span><span class="tok-p">(</span><span class="tok-s">&quot;node&quot;</span><span class="tok-p">).</span><span class="tok-n">attribute</span><span class="tok-p">(</span><span class="tok-s">&quot;attr&quot;</span><span class="tok-p">).</span><span class="tok-n">value</span><span class="tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;]</span><span class="tok-se">\n</span><span class="tok-s">&quot;</span><span class="tok-p">;</span>
    <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;Error description: &quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">result</span><span class="tok-p">.</span><span class="tok-n">description</span><span class="tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;</span><span class="tok-se">\n</span><span class="tok-s">&quot;</span><span class="tok-p">;</span>
    <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;Error offset: &quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">result</span><span class="tok-p">.</span><span class="tok-n">offset</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot; (error at [...&quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-p">(</span><span class="tok-n">source</span> <span class="tok-o">+</span> <span class="tok-n">result</span><span class="tok-p">.</span><span class="tok-n">offset</span><span class="tok-p">)</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;]</span><span class="tok-se">\n\n</span><span class="tok-s">&quot;</span><span class="tok-p">;</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="loading.options"><a class="anchor" href="#loading.options"></a>4.5. Parsing options</h3>
<div class="paragraph">
<p>All document loading functions accept the optional parameter <code>options</code>. This is a bitmask that customizes the parsing process: you can select the node types that are parsed and various transformations that are performed with the XML text. Disabling certain transformations can improve parsing performance for some documents; however, the code for all transformations is very well optimized, and thus the majority of documents won&#8217;t get any performance benefit. As a rule of thumb, only modify parsing flags if you want to get some nodes in the document that are excluded by default (i.e. declaration or comment nodes).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
You should use the usual bitwise arithmetics to manipulate the bitmask: to enable a flag, use <code>mask | flag</code>; to disable a flag, use <code>mask &amp; ~flag</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>These flags control the resulting tree contents:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a id="parse_declaration"></a><code>parse_declaration</code> determines if XML document declaration (node with type <a href="#node_declaration">node_declaration</a>) is to be put in DOM tree. If this flag is off, it is not put in the tree, but is still parsed and checked for correctness. This flag is <strong>off</strong> by default.</p>
</li>
<li>
<p><a id="parse_doctype"></a><code>parse_doctype</code> determines if XML document type declaration (node with type <a href="#node_doctype">node_doctype</a>) is to be put in DOM tree. If this flag is off, it is not put in the tree, but is still parsed and checked for correctness. This flag is <strong>off</strong> by default.</p>
</li>
<li>
<p><a id="parse_pi"></a><code>parse_pi</code> determines if processing instructions (nodes with type <a href="#node_pi">node_pi</a>) are to be put in DOM tree. If this flag is off, they are not put in the tree, but are still parsed and checked for correctness. Note that <code>&lt;?xml &#8230;&#8203;?&gt;</code> (document declaration) is not considered to be a PI. This flag is <strong>off</strong> by default.</p>
</li>
<li>
<p><a id="parse_comments"></a><code>parse_comments</code> determines if comments (nodes with type <a href="#node_comment">node_comment</a>) are to be put in DOM tree. If this flag is off, they are not put in the tree, but are still parsed and checked for correctness. This flag is <strong>off</strong> by default.</p>
</li>
<li>
<p><a id="parse_cdata"></a><code>parse_cdata</code> determines if CDATA sections (nodes with type <a href="#node_cdata">node_cdata</a>) are to be put in DOM tree. If this flag is off, they are not put in the tree, but are still parsed and checked for correctness. This flag is <strong>on</strong> by default.</p>
</li>
<li>
<p><a id="parse_trim_pcdata"></a><code>parse_trim_pcdata</code> determines if leading and trailing whitespace characters are to be removed from PCDATA nodes. While for some applications leading/trailing whitespace is significant, often the application only cares about the non-whitespace contents so it&#8217;s easier to trim whitespace from text during parsing. This flag is <strong>off</strong> by default.</p>
</li>
<li>
<p><a id="parse_ws_pcdata"></a><code>parse_ws_pcdata</code> determines if PCDATA nodes (nodes with type <a href="#node_pcdata">node_pcdata</a>) that consist only of whitespace characters are to be put in DOM tree. Often whitespace-only data is not significant for the application, and the cost of allocating and storing such nodes (both memory and speed-wise) can be significant. For example, after parsing XML string <code>&lt;node&gt; &lt;a/&gt; &lt;/node&gt;</code>, <code>&lt;node&gt;</code> element will have three children when <code>parse_ws_pcdata</code> is set (child with type <a href="#node_pcdata">node_pcdata</a> and value <code>" "</code>, child with type <a href="#node_element">node_element</a> and name <code>"a"</code>, and another child with type <a href="#node_pcdata">node_pcdata</a> and value <code>" "</code>), and only one child when <code>parse_ws_pcdata</code> is not set. This flag is <strong>off</strong> by default.</p>
</li>
<li>
<p><a id="parse_ws_pcdata_single"></a><code>parse_ws_pcdata_single</code> determines if whitespace-only PCDATA nodes that have no sibling nodes are to be put in DOM tree. In some cases application needs to parse the whitespace-only contents of nodes, i.e. <code>&lt;node&gt;  &lt;/node&gt;</code>, but is not interested in whitespace markup elsewhere. It is possible to use <a href="#parse_ws_pcdata">parse_ws_pcdata</a> flag in this case, but it results in excessive allocations and complicates document processing; this flag can be used to avoid that. As an example, after parsing XML string <code>&lt;node&gt; &lt;a&gt;  &lt;/a&gt; &lt;/node&gt;</code> with <code>parse_ws_pcdata_single</code> flag set, <code>&lt;node&gt;</code> element will have one child <code>&lt;a&gt;</code>, and <code>&lt;a&gt;</code> element will have one child with type <a href="#node_pcdata">node_pcdata</a> and value <code>"  "</code>. This flag has no effect if <a href="#parse_ws_pcdata">parse_ws_pcdata</a> is enabled. This flag is <strong>off</strong> by default.</p>
</li>
<li>
<p><a id="parse_fragment"></a><code>parse_fragment</code> determines if document should be treated as a fragment of a valid XML. Parsing document as a fragment leads to top-level PCDATA content (i.e. text that is not located inside a node) to be added to a tree, and additionally treats documents without element nodes as valid. This flag is <strong>off</strong> by default.</p>
</li>
</ul>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
Using in-place parsing (<a href="#xml_document::load_buffer_inplace">load_buffer_inplace</a>) with <code>parse_fragment</code> flag may result in the loss of the last character of the buffer if it is a part of PCDATA. Since PCDATA values are null-terminated strings, the only way to resolve this is to provide a null-terminated buffer as an input to <code>load_buffer_inplace</code> - i.e. <code>doc.load_buffer_inplace("test\0", 5, pugi::parse_default | pugi::parse_fragment)</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>These flags control the transformation of tree element contents:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a id="parse_escapes"></a><code>parse_escapes</code> determines if character and entity references are to be expanded during the parsing process. Character references have the form <code>&amp;#&#8230;&#8203;;</code> or <code>&amp;#x&#8230;&#8203;;</code> (<code>&#8230;&#8203;</code> is Unicode numeric representation of character in either decimal (<code>&amp;#&#8230;&#8203;;</code>) or hexadecimal (<code>&amp;#x&#8230;&#8203;;</code>) form), entity references are <code>&amp;lt;</code>, <code>&amp;gt;</code>, <code>&amp;amp;</code>, <code>&amp;apos;</code> and <code>&amp;quot;</code> (note that as pugixml does not handle DTD, the only allowed entities are predefined ones). If character/entity reference can not be expanded, it is left as is, so you can do additional processing later. Reference expansion is performed on attribute values and PCDATA content. This flag is <strong>on</strong> by default.</p>
</li>
<li>
<p><a id="parse_eol"></a><code>parse_eol</code> determines if EOL handling (that is, replacing sequences <code>\r\n</code> by a single <code>\n</code> character, and replacing all standalone <code>\r</code> characters by <code>\n</code>) is to be performed on input data (that is, comment contents, PCDATA/CDATA contents and attribute values). This flag is <strong>on</strong> by default.</p>
</li>
<li>
<p><a id="parse_wconv_attribute"></a><code>parse_wconv_attribute</code> determines if attribute value normalization should be performed for all attributes. This means, that whitespace characters (new line, tab and space) are replaced with space (<code>' '</code>). New line characters are always treated as if <a href="#parse_eol">parse_eol</a> is set, i.e. <code>\r\n</code> is converted to a single space.  This flag is <strong>on</strong> by default.</p>
</li>
<li>
<p><a id="parse_wnorm_attribute"></a><code>parse_wnorm_attribute</code> determines if extended attribute value normalization should be performed for all attributes. This means, that after attribute values are normalized as if <a href="#parse_wconv_attribute">parse_wconv_attribute</a> was set, leading and trailing space characters are removed, and all sequences of space characters are replaced by a single space character. <a href="#parse_wconv_attribute">parse_wconv_attribute</a> has no effect if this flag is on. This flag is <strong>off</strong> by default.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<code>parse_wconv_attribute</code> option performs transformations that are required by W3C specification for attributes that are declared as CDATA; <a href="#parse_wnorm_attribute">parse_wnorm_attribute</a> performs transformations required for NMTOKENS attributes. In the absence of document type declaration all attributes should behave as if they are declared as CDATA, thus <a href="#parse_wconv_attribute">parse_wconv_attribute</a> is the default option.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Additionally there are three predefined option masks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a id="parse_minimal"></a><code>parse_minimal</code> has all options turned off. This option mask means that pugixml does not add declaration nodes, document type declaration nodes, PI nodes, CDATA sections and comments to the resulting tree and does not perform any conversion for input data, so theoretically it is the fastest mode. However, as mentioned above, in practice <a href="#parse_default">parse_default</a> is usually equally fast.</p>
</li>
<li>
<p><a id="parse_default"></a><code>parse_default</code> is the default set of flags, i.e. it has all options set to their default values. It includes parsing CDATA sections (comments/PIs are not parsed), performing character and entity reference expansion, replacing whitespace characters with spaces in attribute values and performing EOL handling. Note, that PCDATA sections consisting only of whitespace characters are not parsed (by default) for performance reasons.</p>
</li>
<li>
<p><a id="parse_full"></a><code>parse_full</code> is the set of flags which adds nodes of all types to the resulting tree and performs default conversions for input data. It includes parsing CDATA sections, comments, PI nodes, document declaration node and document type declaration node, performing character and entity reference expansion, replacing whitespace characters with spaces in attribute values and performing EOL handling. Note, that PCDATA sections consisting only of whitespace characters are not parsed in this mode.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This is an example of using different parsing options (<a href="samples/load_options.cpp" class="bare">samples/load_options.cpp</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-k">const</span> <span class="tok-kt">char</span><span class="tok-o">*</span> <span class="tok-n">source</span> <span class="tok-o">=</span> <span class="tok-s">&quot;&lt;!--comment--&gt;&lt;node&gt;&amp;lt;&lt;/node&gt;&quot;</span><span class="tok-p">;</span>

<span class="tok-c1">// Parsing with default options; note that comment node is not added to the tree, and entity reference &amp;lt; is expanded</span>
<span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">load_string</span><span class="tok-p">(</span><span class="tok-n">source</span><span class="tok-p">);</span>
<span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;First node value: [&quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">first_child</span><span class="tok-p">().</span><span class="tok-n">value</span><span class="tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;], node child value: [&quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">child_value</span><span class="tok-p">(</span><span class="tok-s">&quot;node&quot;</span><span class="tok-p">)</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;]</span><span class="tok-se">\n</span><span class="tok-s">&quot;</span><span class="tok-p">;</span>

<span class="tok-c1">// Parsing with additional parse_comments option; comment node is now added to the tree</span>
<span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">load_string</span><span class="tok-p">(</span><span class="tok-n">source</span><span class="tok-p">,</span> <span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">parse_default</span> <span class="tok-o">|</span> <span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">parse_comments</span><span class="tok-p">);</span>
<span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;First node value: [&quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">first_child</span><span class="tok-p">().</span><span class="tok-n">value</span><span class="tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;], node child value: [&quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">child_value</span><span class="tok-p">(</span><span class="tok-s">&quot;node&quot;</span><span class="tok-p">)</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;]</span><span class="tok-se">\n</span><span class="tok-s">&quot;</span><span class="tok-p">;</span>

<span class="tok-c1">// Parsing with additional parse_comments option and without the (default) parse_escapes option; &amp;lt; is not expanded</span>
<span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">load_string</span><span class="tok-p">(</span><span class="tok-n">source</span><span class="tok-p">,</span> <span class="tok-p">(</span><span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">parse_default</span> <span class="tok-o">|</span> <span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">parse_comments</span><span class="tok-p">)</span> <span class="tok-o">&amp;</span> <span class="tok-o">~</span><span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">parse_escapes</span><span class="tok-p">);</span>
<span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;First node value: [&quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">first_child</span><span class="tok-p">().</span><span class="tok-n">value</span><span class="tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;], node child value: [&quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">child_value</span><span class="tok-p">(</span><span class="tok-s">&quot;node&quot;</span><span class="tok-p">)</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;]</span><span class="tok-se">\n</span><span class="tok-s">&quot;</span><span class="tok-p">;</span>

<span class="tok-c1">// Parsing with minimal option mask; comment node is not added to the tree, and &amp;lt; is not expanded</span>
<span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">load_string</span><span class="tok-p">(</span><span class="tok-n">source</span><span class="tok-p">,</span> <span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">parse_minimal</span><span class="tok-p">);</span>
<span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;First node value: [&quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">first_child</span><span class="tok-p">().</span><span class="tok-n">value</span><span class="tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;], node child value: [&quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">child_value</span><span class="tok-p">(</span><span class="tok-s">&quot;node&quot;</span><span class="tok-p">)</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;]</span><span class="tok-se">\n</span><span class="tok-s">&quot;</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="loading.encoding"><a class="anchor" href="#loading.encoding"></a>4.6. Encodings</h3>
<div id="xml_encoding" class="paragraph">
<p>pugixml supports all popular Unicode encodings (UTF-8, UTF-16 (big and little endian), UTF-32 (big and little endian); UCS-2 is naturally supported since it&#8217;s a strict subset of UTF-16) and handles all encoding conversions. Most loading functions accept the optional parameter <code>encoding</code>. This is a value of enumeration type <code>xml_encoding</code>, that can have the following values:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a id="encoding_auto"></a><code>encoding_auto</code> means that pugixml will try to guess the encoding based on source XML data. The algorithm is a modified version of the one presented in <a href="http://www.w3.org/TR/REC-xml/#sec-guessing-no-ext-info">Appendix F.1 of XML recommendation</a>; it tries to match the first few bytes of input data with the following patterns in strict order:</p>
<div class="ulist">
<ul>
<li>
<p>If first four bytes match UTF-32 BOM (Byte Order Mark), encoding is assumed to be UTF-32 with the endianness equal to that of BOM;</p>
</li>
<li>
<p>If first two bytes match UTF-16 BOM, encoding is assumed to be UTF-16 with the endianness equal to that of BOM;</p>
</li>
<li>
<p>If first three bytes match UTF-8 BOM, encoding is assumed to be UTF-8;</p>
</li>
<li>
<p>If first four bytes match UTF-32 representation of <code>&lt;</code>, encoding is assumed to be UTF-32 with the corresponding endianness;</p>
</li>
<li>
<p>If first four bytes match UTF-16 representation of <code>&lt;?</code>, encoding is assumed to be UTF-16 with the corresponding endianness;</p>
</li>
<li>
<p>If first two bytes match UTF-16 representation of <code>&lt;</code>, encoding is assumed to be UTF-16 with the corresponding endianness (this guess may yield incorrect result, but it&#8217;s better than UTF-8);</p>
</li>
<li>
<p>Otherwise encoding is assumed to be UTF-8.</p>
</li>
</ul>
</div>
</li>
<li>
<p><a id="encoding_utf8"></a><code>encoding_utf8</code> corresponds to UTF-8 encoding as defined in the Unicode standard; UTF-8 sequences with length equal to 5 or 6 are not standard and are rejected.</p>
</li>
<li>
<p><a id="encoding_utf16_le"></a><code>encoding_utf16_le</code> corresponds to little-endian UTF-16 encoding as defined in the Unicode standard; surrogate pairs are supported.</p>
</li>
<li>
<p><a id="encoding_utf16_be"></a><code>encoding_utf16_be</code> corresponds to big-endian UTF-16 encoding as defined in the Unicode standard; surrogate pairs are supported.</p>
</li>
<li>
<p><a id="encoding_utf16"></a><code>encoding_utf16</code> corresponds to UTF-16 encoding as defined in the Unicode standard; the endianness is assumed to be that of the target platform.</p>
</li>
<li>
<p><a id="encoding_utf32_le"></a><code>encoding_utf32_le</code> corresponds to little-endian UTF-32 encoding as defined in the Unicode standard.</p>
</li>
<li>
<p><a id="encoding_utf32_be"></a><code>encoding_utf32_be</code> corresponds to big-endian UTF-32 encoding as defined in the Unicode standard.</p>
</li>
<li>
<p><a id="encoding_utf32"></a><code>encoding_utf32</code> corresponds to UTF-32 encoding as defined in the Unicode standard; the endianness is assumed to be that of the target platform.</p>
</li>
<li>
<p><a id="encoding_wchar"></a><code>encoding_wchar</code> corresponds to the encoding of <code>wchar_t</code> type; it has the same meaning as either <code>encoding_utf16</code> or <code>encoding_utf32</code>, depending on <code>wchar_t</code> size.</p>
</li>
<li>
<p><a id="encoding_latin1"></a><code>encoding_latin1</code> corresponds to ISO-8859-1 encoding (also known as Latin-1).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The algorithm used for <code>encoding_auto</code> correctly detects any supported Unicode encoding for all well-formed XML documents (since they start with document declaration) and for all other XML documents that start with <code>&lt;</code>; if your XML document does not start with <code>&lt;</code> and has encoding that is different from UTF-8, use the specific encoding.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
The current behavior for Unicode conversion is to skip all invalid UTF sequences during conversion. This behavior should not be relied upon; moreover, in case no encoding conversion is performed, the invalid sequences are not removed, so you&#8217;ll get them as is in node/attribute contents.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="loading.w3c"><a class="anchor" href="#loading.w3c"></a>4.7. Conformance to W3C specification</h3>
<div class="paragraph">
<p>pugixml is not fully W3C conformant - it can load any valid XML document, but does not perform some well-formedness checks. While considerable effort is made to reject invalid XML documents, some validation is not performed because of performance reasons.</p>
</div>
<div class="paragraph">
<p>There is only one non-conformant behavior when dealing with valid XML documents: pugixml does not use information supplied in document type declaration for parsing. This means that entities declared in DOCTYPE are not expanded, and all attribute/PCDATA values are always processed in a uniform way that depends only on parsing options.</p>
</div>
<div class="paragraph">
<p>As for rejecting invalid XML documents, there are a number of incompatibilities with W3C specification, including:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Multiple attributes of the same node can have equal names.</p>
</li>
<li>
<p>All non-ASCII characters are treated in the same way as symbols of English alphabet, so some invalid tag names are not rejected.</p>
</li>
<li>
<p>Attribute values which contain <code>&lt;</code> are not rejected.</p>
</li>
<li>
<p>Invalid entity/character references are not rejected and are instead left as is.</p>
</li>
<li>
<p>Comment values can contain <code>--</code>.</p>
</li>
<li>
<p>XML data is not required to begin with document declaration; additionally, document declaration can appear after comments and other nodes.</p>
</li>
<li>
<p>Invalid document type declarations are silently ignored in some cases.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="access"><a class="anchor" href="#access"></a>5. Accessing document data</h2>
<div class="sectionbody">
<div class="paragraph">
<p>pugixml features an extensive interface for getting various types of data from the document and for traversing the document. This section provides documentation for all such functions that do not modify the tree except for XPath-related functions; see <a href="#xpath">XPath</a> for XPath reference. As discussed in <a href="#dom.cpp">C&#43;&#43; interface</a>, there are two types of handles to tree data - <a href="#xml_node">xml_node</a> and <a href="#xml_attribute">xml_attribute</a>. The handles have special null (empty) values which propagate through various functions and thus are useful for writing more concise code; see <a href="#node_null">this description</a> for details. The documentation in this section will explicitly state the results of all function in case of null inputs.</p>
</div>
<div class="sect2">
<h3 id="access.basic"><a class="anchor" href="#access.basic"></a>5.1. Basic traversal functions</h3>
<div class="paragraph">
<p><a id="xml_node::parent"></a><a id="xml_node::first_child"></a><a id="xml_node::last_child"></a><a id="xml_node::next_sibling"></a><a id="xml_node::previous_sibling"></a><a id="xml_node::first_attribute"></a><a id="xml_node::last_attribute"></a><a id="xml_attribute::next_attribute"></a><a id="xml_attribute::previous_attribute"></a>
The internal representation of the document is a tree, where each node has a list of child nodes (the order of children corresponds to their order in the XML representation), and additionally element nodes have a list of attributes, which is also ordered. Several functions are provided in order to let you get from one node in the tree to the other. These functions roughly correspond to the internal representation, and thus are usually building blocks for other methods of traversing (i.e. XPath traversals are based on these functions).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-n">xml_node</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">parent</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-n">xml_node</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">first_child</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-n">xml_node</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">last_child</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-n">xml_node</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">next_sibling</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-n">xml_node</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">previous_sibling</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>

<span class="tok-n">xml_attribute</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">first_attribute</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-n">xml_attribute</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">last_attribute</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-n">xml_attribute</span> <span class="tok-n">xml_attribute</span><span class="tok-o">::</span><span class="tok-n">next_attribute</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-n">xml_attribute</span> <span class="tok-n">xml_attribute</span><span class="tok-o">::</span><span class="tok-n">previous_attribute</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>parent</code> function returns the node&#8217;s parent; all non-null nodes except the document have non-null parent. <code>first_child</code> and <code>last_child</code> return the first and last child of the node, respectively; note that only document nodes and element nodes can have non-empty child node list. If node has no children, both functions return null nodes. <code>next_sibling</code> and <code>previous_sibling</code> return the node that&#8217;s immediately to the right/left of this node in the children list, respectively - for example, in <code>&lt;a/&gt;&lt;b/&gt;&lt;c/&gt;</code>, calling <code>next_sibling</code> for a handle that points to <code>&lt;b/&gt;</code> results in a handle pointing to <code>&lt;c/&gt;</code>, and calling <code>previous_sibling</code> results in handle pointing to <code>&lt;a/&gt;</code>. If node does not have next/previous sibling (this happens if it is the last/first node in the list, respectively), the functions return null nodes. <code>first_attribute</code>, <code>last_attribute</code>, <code>next_attribute</code> and <code>previous_attribute</code> functions behave similarly to the corresponding child node functions and allow to iterate through attribute list in the same way.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Because of memory consumption reasons, attributes do not have a link to their parent nodes. Thus there is no <code>xml_attribute::parent()</code> function.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Calling any of the functions above on the null handle results in a null handle - i.e. <code>node.first_child().next_sibling()</code> returns the second child of <code>node</code>, and null handle if <code>node</code> is null, has no children at all or if it has only one child node.</p>
</div>
<div class="paragraph">
<p>With these functions, you can iterate through all child nodes and display all attributes like this (<a href="samples/traverse_base.cpp" class="bare">samples/traverse_base.cpp</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-k">for</span> <span class="tok-p">(</span><span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xml_node</span> <span class="tok-n">tool</span> <span class="tok-o">=</span> <span class="tok-n">tools</span><span class="tok-p">.</span><span class="tok-n">first_child</span><span class="tok-p">();</span> <span class="tok-n">tool</span><span class="tok-p">;</span> <span class="tok-n">tool</span> <span class="tok-o">=</span> <span class="tok-n">tool</span><span class="tok-p">.</span><span class="tok-n">next_sibling</span><span class="tok-p">())</span>
<span class="tok-p">{</span>
    <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;Tool:&quot;</span><span class="tok-p">;</span>

    <span class="tok-k">for</span> <span class="tok-p">(</span><span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xml_attribute</span> <span class="tok-n">attr</span> <span class="tok-o">=</span> <span class="tok-n">tool</span><span class="tok-p">.</span><span class="tok-n">first_attribute</span><span class="tok-p">();</span> <span class="tok-n">attr</span><span class="tok-p">;</span> <span class="tok-n">attr</span> <span class="tok-o">=</span> <span class="tok-n">attr</span><span class="tok-p">.</span><span class="tok-n">next_attribute</span><span class="tok-p">())</span>
    <span class="tok-p">{</span>
        <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot; &quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">attr</span><span class="tok-p">.</span><span class="tok-n">name</span><span class="tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;=&quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">attr</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-p">();</span>
    <span class="tok-p">}</span>

    <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">endl</span><span class="tok-p">;</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="access.nodedata"><a class="anchor" href="#access.nodedata"></a>5.2. Getting node data</h3>
<div class="paragraph">
<p><a id="xml_node::name"></a><a id="xml_node::value"></a>
Apart from structural information (parent, child nodes, attributes), nodes can have name and value, both of which are strings. Depending on node type, name or value may be absent. <a href="#node_document">node_document</a> nodes do not have a name or value, <a href="#node_element">node_element</a> and <a href="#node_declaration">node_declaration</a> nodes always have a name but never have a value, <a href="#node_pcdata">node_pcdata</a>, <a href="#node_cdata">node_cdata</a>, <a href="#node_comment">node_comment</a> and <a href="#node_doctype">node_doctype</a> nodes never have a name but always have a value (it may be empty though), <a href="#node_pi">node_pi</a> nodes always have a name and a value (again, value may be empty). In order to get node&#8217;s name or value, you can use the following functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">name</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">value</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In case node does not have a name or value or if the node handle is null, both functions return empty strings - they never return null pointers.</p>
</div>
<div id="xml_node::child_value" class="paragraph">
<p>It is common to store data as text contents of some node - i.e. <code>&lt;node&gt;&lt;description&gt;This is a node&lt;/description&gt;&lt;/node&gt;</code>. In this case, <code>&lt;description&gt;</code> node does not have a value, but instead has a child of type <a href="#node_pcdata">node_pcdata</a> with value <code>"This is a node"</code>. pugixml provides several helper functions to parse such data:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">child_value</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">child_value</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">name</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-n">xml_text</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">text</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>child_value()</code> returns the value of the first child with type <a href="#node_pcdata">node_pcdata</a> or <a href="#node_cdata">node_cdata</a>; <code>child_value(name)</code> is a simple wrapper for <code>child(name).child_value()</code>. For the above example, calling <code>node.child_value("description")</code> and <code>description.child_value()</code> will both produce string <code>"This is a node"</code>. If there is no child with relevant type, or if the handle is null, <code>child_value</code> functions return empty string.</p>
</div>
<div class="paragraph">
<p><code>text()</code> returns a special object that can be used for working with PCDATA contents in more complex cases than just retrieving the value; it is described in <a href="#access.text">Working with text contents</a> sections.</p>
</div>
<div class="paragraph">
<p>There is an example of using some of these functions <a href="#code_traverse_base_data">at the end of the next section</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="access.attrdata"><a class="anchor" href="#access.attrdata"></a>5.3. Getting attribute data</h3>
<div class="paragraph">
<p><a id="xml_attribute::name"></a><a id="xml_attribute::value"></a>
All attributes have name and value, both of which are strings (value may be empty). There are two corresponding accessors, like for <code>xml_node</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">xml_attribute</span><span class="tok-o">::</span><span class="tok-n">name</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">xml_attribute</span><span class="tok-o">::</span><span class="tok-n">value</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In case the attribute handle is null, both functions return empty strings - they never return null pointers.</p>
</div>
<div id="xml_attribute::as_string" class="paragraph">
<p>If you need a non-empty string if the attribute handle is null (for example, you need to get the option value from XML attribute, but if it is not specified, you need it to default to <code>"sorted"</code> instead of <code>""</code>), you can use <code>as_string</code> accessor:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">xml_attribute</span><span class="tok-o">::</span><span class="tok-n">as_string</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">def</span> <span class="tok-o">=</span> <span class="tok-s">&quot;&quot;</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>It returns <code>def</code> argument if the attribute handle is null. If you do not specify the argument, the function is equivalent to <code>value()</code>.</p>
</div>
<div class="paragraph">
<p><a id="xml_attribute::as_int"></a><a id="xml_attribute::as_uint"></a><a id="xml_attribute::as_double"></a><a id="xml_attribute::as_float"></a><a id="xml_attribute::as_bool"></a><a id="xml_attribute::as_llong"></a><a id="xml_attribute::as_ullong"></a>
In many cases attribute values have types that are not strings - i.e. an attribute may always contain values that should be treated as integers, despite the fact that they are represented as strings in XML. pugixml provides several accessors that convert attribute value to some other type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-kt">int</span> <span class="tok-n">xml_attribute</span><span class="tok-o">::</span><span class="tok-n">as_int</span><span class="tok-p">(</span><span class="tok-kt">int</span> <span class="tok-n">def</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">xml_attribute</span><span class="tok-o">::</span><span class="tok-n">as_uint</span><span class="tok-p">(</span><span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">def</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-kt">double</span> <span class="tok-n">xml_attribute</span><span class="tok-o">::</span><span class="tok-n">as_double</span><span class="tok-p">(</span><span class="tok-kt">double</span> <span class="tok-n">def</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-kt">float</span> <span class="tok-n">xml_attribute</span><span class="tok-o">::</span><span class="tok-n">as_float</span><span class="tok-p">(</span><span class="tok-kt">float</span> <span class="tok-n">def</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-kt">bool</span> <span class="tok-n">xml_attribute</span><span class="tok-o">::</span><span class="tok-n">as_bool</span><span class="tok-p">(</span><span class="tok-kt">bool</span> <span class="tok-n">def</span> <span class="tok-o">=</span> <span class="tok-nb">false</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-kt">long</span> <span class="tok-kt">long</span> <span class="tok-n">xml_attribute</span><span class="tok-o">::</span><span class="tok-n">as_llong</span><span class="tok-p">(</span><span class="tok-kt">long</span> <span class="tok-kt">long</span> <span class="tok-n">def</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-kt">unsigned</span> <span class="tok-kt">long</span> <span class="tok-kt">long</span> <span class="tok-n">xml_attribute</span><span class="tok-o">::</span><span class="tok-n">as_ullong</span><span class="tok-p">(</span><span class="tok-kt">unsigned</span> <span class="tok-kt">long</span> <span class="tok-kt">long</span> <span class="tok-n">def</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>as_int</code>, <code>as_uint</code>, <code>as_llong</code>, <code>as_ullong</code>, <code>as_double</code> and <code>as_float</code> convert attribute values to numbers. If attribute handle is null or attribute value is empty, <code>def</code> argument is returned (which is 0 by default). Otherwise, all leading whitespace characters are truncated, and the remaining string is parsed as an integer number in either decimal or hexadecimal form (applicable to <code>as_int</code>, <code>as_uint</code>, <code>as_llong</code> and <code>as_ullong</code>; hexadecimal format is used if the number has <code>0x</code> or <code>0X</code> prefix) or as a floating point number in either decimal or scientific form (<code>as_double</code> or <code>as_float</code>). Any extra characters are silently discarded, i.e. <code>as_int</code> will return <code>1</code> for string <code>"1abc"</code>.</p>
</div>
<div class="paragraph">
<p>In case the input string contains a number that is out of the target numeric range, the result is undefined.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
Number conversion functions depend on current C locale as set with <code>setlocale</code>, so may return unexpected results if the locale is different from <code>"C"</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>as_bool</code> converts attribute value to boolean as follows: if attribute handle is null, <code>def</code> argument is returned (which is <code>false</code> by default). If attribute value is empty, <code>false</code> is returned. Otherwise, <code>true</code> is returned if the first character is one of <code>'1', 't', 'T', 'y', 'Y'</code>. This means that strings like <code>"true"</code> and <code>"yes"</code> are recognized as <code>true</code>, while strings like <code>"false"</code> and <code>"no"</code> are recognized as <code>false</code>. For more complex matching you&#8217;ll have to write your own function.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<code>as_llong</code> and <code>as_ullong</code> are only available if your platform has reliable support for the <code>long long</code> type, including string conversions.
</td>
</tr>
</table>
</div>
<div id="code_traverse_base_data" class="paragraph">
<p>This is an example of using these functions, along with node data retrieval ones (<a href="samples/traverse_base.cpp" class="bare">samples/traverse_base.cpp</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-k">for</span> <span class="tok-p">(</span><span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xml_node</span> <span class="tok-n">tool</span> <span class="tok-o">=</span> <span class="tok-n">tools</span><span class="tok-p">.</span><span class="tok-n">child</span><span class="tok-p">(</span><span class="tok-s">&quot;Tool&quot;</span><span class="tok-p">);</span> <span class="tok-n">tool</span><span class="tok-p">;</span> <span class="tok-n">tool</span> <span class="tok-o">=</span> <span class="tok-n">tool</span><span class="tok-p">.</span><span class="tok-n">next_sibling</span><span class="tok-p">(</span><span class="tok-s">&quot;Tool&quot;</span><span class="tok-p">))</span>
<span class="tok-p">{</span>
    <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;Tool &quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">tool</span><span class="tok-p">.</span><span class="tok-n">attribute</span><span class="tok-p">(</span><span class="tok-s">&quot;Filename&quot;</span><span class="tok-p">).</span><span class="tok-n">value</span><span class="tok-p">();</span>
    <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;: AllowRemote &quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">tool</span><span class="tok-p">.</span><span class="tok-n">attribute</span><span class="tok-p">(</span><span class="tok-s">&quot;AllowRemote&quot;</span><span class="tok-p">).</span><span class="tok-n">as_bool</span><span class="tok-p">();</span>
    <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;, Timeout &quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">tool</span><span class="tok-p">.</span><span class="tok-n">attribute</span><span class="tok-p">(</span><span class="tok-s">&quot;Timeout&quot;</span><span class="tok-p">).</span><span class="tok-n">as_int</span><span class="tok-p">();</span>
    <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;, Description &#39;&quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">tool</span><span class="tok-p">.</span><span class="tok-n">child_value</span><span class="tok-p">(</span><span class="tok-s">&quot;Description&quot;</span><span class="tok-p">)</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;&#39;</span><span class="tok-se">\n</span><span class="tok-s">&quot;</span><span class="tok-p">;</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="access.contents"><a class="anchor" href="#access.contents"></a>5.4. Contents-based traversal functions</h3>
<div class="paragraph">
<p><a id="xml_node::child"></a><a id="xml_node::attribute"></a><a id="xml_node::next_sibling_name"></a><a id="xml_node::previous_sibling_name"></a>
Since a lot of document traversal consists of finding the node/attribute with the correct name, there are special functions for that purpose:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-n">xml_node</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">child</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">name</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-n">xml_attribute</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">attribute</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">name</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-n">xml_node</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">next_sibling</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">name</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-n">xml_node</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">previous_sibling</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">name</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>child</code> and <code>attribute</code> return the first child/attribute with the specified name; <code>next_sibling</code> and <code>previous_sibling</code> return the first sibling in the corresponding direction with the specified name. All string comparisons are case-sensitive. In case the node handle is null or there is no node/attribute with the specified name, null handle is returned.</p>
</div>
<div class="paragraph">
<p><code>child</code> and <code>next_sibling</code> functions can be used together to loop through all child nodes with the desired name like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-k">for</span> <span class="tok-p">(</span><span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xml_node</span> <span class="tok-n">tool</span> <span class="tok-o">=</span> <span class="tok-n">tools</span><span class="tok-p">.</span><span class="tok-n">child</span><span class="tok-p">(</span><span class="tok-s">&quot;Tool&quot;</span><span class="tok-p">);</span> <span class="tok-n">tool</span><span class="tok-p">;</span> <span class="tok-n">tool</span> <span class="tok-o">=</span> <span class="tok-n">tool</span><span class="tok-p">.</span><span class="tok-n">next_sibling</span><span class="tok-p">(</span><span class="tok-s">&quot;Tool&quot;</span><span class="tok-p">))</span></code></pre>
</div>
</div>
<div id="xml_node::find_child_by_attribute" class="paragraph">
<p>Occasionally the needed node is specified not by the unique name but instead by the value of some attribute; for example, it is common to have node collections with each node having a unique id: <code>&lt;group&gt;&lt;item id="1"/&gt; &lt;item id="2"/&gt;&lt;/group&gt;</code>. There are two functions for finding child nodes based on the attribute values:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-n">xml_node</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">find_child_by_attribute</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">name</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">attr_name</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">attr_value</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-n">xml_node</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">find_child_by_attribute</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">attr_name</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">attr_value</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The three-argument function returns the first child node with the specified name which has an attribute with the specified name/value; the two-argument function skips the name test for the node, which can be useful for searching in heterogeneous collections. If the node handle is null or if no node is found, null handle is returned. All string comparisons are case-sensitive.</p>
</div>
<div class="paragraph">
<p>In all of the above functions, all arguments have to be valid strings; passing null pointers results in undefined behavior.</p>
</div>
<div class="paragraph">
<p>This is an example of using these functions (<a href="samples/traverse_base.cpp" class="bare">samples/traverse_base.cpp</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;Tool for *.dae generation: &quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">tools</span><span class="tok-p">.</span><span class="tok-n">find_child_by_attribute</span><span class="tok-p">(</span><span class="tok-s">&quot;Tool&quot;</span><span class="tok-p">,</span> <span class="tok-s">&quot;OutputFileMasks&quot;</span><span class="tok-p">,</span> <span class="tok-s">&quot;*.dae&quot;</span><span class="tok-p">).</span><span class="tok-n">attribute</span><span class="tok-p">(</span><span class="tok-s">&quot;Filename&quot;</span><span class="tok-p">).</span><span class="tok-n">value</span><span class="tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;</span><span class="tok-se">\n</span><span class="tok-s">&quot;</span><span class="tok-p">;</span>

<span class="tok-k">for</span> <span class="tok-p">(</span><span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xml_node</span> <span class="tok-n">tool</span> <span class="tok-o">=</span> <span class="tok-n">tools</span><span class="tok-p">.</span><span class="tok-n">child</span><span class="tok-p">(</span><span class="tok-s">&quot;Tool&quot;</span><span class="tok-p">);</span> <span class="tok-n">tool</span><span class="tok-p">;</span> <span class="tok-n">tool</span> <span class="tok-o">=</span> <span class="tok-n">tool</span><span class="tok-p">.</span><span class="tok-n">next_sibling</span><span class="tok-p">(</span><span class="tok-s">&quot;Tool&quot;</span><span class="tok-p">))</span>
<span class="tok-p">{</span>
    <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;Tool &quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">tool</span><span class="tok-p">.</span><span class="tok-n">attribute</span><span class="tok-p">(</span><span class="tok-s">&quot;Filename&quot;</span><span class="tok-p">).</span><span class="tok-n">value</span><span class="tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;</span><span class="tok-se">\n</span><span class="tok-s">&quot;</span><span class="tok-p">;</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="access.rangefor"><a class="anchor" href="#access.rangefor"></a>5.5. Range-based for-loop support</h3>
<div class="paragraph">
<p><a id="xml_node::children"></a><a id="xml_node::attributes"></a>
If your C&#43;&#43; compiler supports range-based for-loop (this is a C&#43;&#43;11 feature, at the time of writing it&#8217;s supported by Microsoft Visual Studio 2012+, GCC 4.6+ and Clang 3.0+), you can use it to enumerate nodes/attributes. Additional helpers are provided to support this; note that they are also compatible with <a href="http://www.boost.org/libs/foreach/">Boost Foreach</a>, and possibly other pre-C&#43;&#43;11 foreach facilities.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-n"><em>implementation</em></span><span class="tok-o">-</span><span class="tok-n"><em>defined</em></span><span class="tok-o">-</span><span class="tok-n"><em>type</em></span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">children</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-n"><em>implementation</em></span><span class="tok-o">-</span><span class="tok-n"><em>defined</em></span><span class="tok-o">-</span><span class="tok-n"><em>type</em></span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">children</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">name</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-n"><em>implementation</em></span><span class="tok-o">-</span><span class="tok-n"><em>defined</em></span><span class="tok-o">-</span><span class="tok-n"><em>type</em></span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">attributes</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>children</code> function allows you to enumerate all child nodes; <code>children</code> function with <code>name</code> argument allows you to enumerate all child nodes with a specific name; <code>attributes</code> function allows you to enumerate all attributes of the node. Note that you can also use node object itself in a range-based for construct, which is equivalent to using <code>children()</code>.</p>
</div>
<div class="paragraph">
<p>This is an example of using these functions (<a href="samples/traverse_rangefor.cpp" class="bare">samples/traverse_rangefor.cpp</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-k">for</span> <span class="tok-p">(</span><span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xml_node</span> <span class="tok-nl">tool</span><span class="tok-p">:</span> <span class="tok-n">tools</span><span class="tok-p">.</span><span class="tok-n">children</span><span class="tok-p">(</span><span class="tok-s">&quot;Tool&quot;</span><span class="tok-p">))</span>
<span class="tok-p">{</span>
    <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;Tool:&quot;</span><span class="tok-p">;</span>

    <span class="tok-k">for</span> <span class="tok-p">(</span><span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xml_attribute</span> <span class="tok-nl">attr</span><span class="tok-p">:</span> <span class="tok-n">tool</span><span class="tok-p">.</span><span class="tok-n">attributes</span><span class="tok-p">())</span>
    <span class="tok-p">{</span>
        <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot; &quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">attr</span><span class="tok-p">.</span><span class="tok-n">name</span><span class="tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;=&quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">attr</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-p">();</span>
    <span class="tok-p">}</span>

    <span class="tok-k">for</span> <span class="tok-p">(</span><span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xml_node</span> <span class="tok-nl">child</span><span class="tok-p">:</span> <span class="tok-n">tool</span><span class="tok-p">.</span><span class="tok-n">children</span><span class="tok-p">())</span>
    <span class="tok-p">{</span>
        <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;, child &quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">child</span><span class="tok-p">.</span><span class="tok-n">name</span><span class="tok-p">();</span>
    <span class="tok-p">}</span>

    <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">endl</span><span class="tok-p">;</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="access.iterators"><a class="anchor" href="#access.iterators"></a>5.6. Traversing node/attribute lists via iterators</h3>
<div class="paragraph">
<p><a id="xml_node_iterator"></a><a id="xml_attribute_iterator"></a><a id="xml_node::begin"></a><a id="xml_node::end"></a><a id="xml_node::attributes_begin"></a><a id="xml_node::attributes_end"></a>
Child node lists and attribute lists are simply double-linked lists; while you can use <code>previous_sibling</code>/<code>next_sibling</code> and other such functions for iteration, pugixml additionally provides node and attribute iterators, so that you can treat nodes as containers of other nodes or attributes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-k">class</span> <span class="tok-nc">xml_node_iterator</span><span class="tok-p">;</span>
<span class="tok-k">class</span> <span class="tok-nc">xml_attribute_iterator</span><span class="tok-p">;</span>

<span class="tok-k">typedef</span> <span class="tok-n">xml_node_iterator</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">iterator</span><span class="tok-p">;</span>
<span class="tok-n">iterator</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">begin</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-n">iterator</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">end</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>

<span class="tok-k">typedef</span> <span class="tok-n">xml_attribute_iterator</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">attribute_iterator</span><span class="tok-p">;</span>
<span class="tok-n">attribute_iterator</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">attributes_begin</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-n">attribute_iterator</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">attributes_end</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>begin</code> and <code>attributes_begin</code> return iterators that point to the first node/attribute, respectively; <code>end</code> and <code>attributes_end</code> return past-the-end iterator for node/attribute list, respectively - this iterator can&#8217;t be dereferenced, but decrementing it results in an iterator pointing to the last element in the list (except for empty lists, where decrementing past-the-end iterator results in undefined behavior). Past-the-end iterator is commonly used as a termination value for iteration loops (see sample below). If you want to get an iterator that points to an existing handle, you can construct the iterator with the handle as a single constructor argument, like so: <code>xml_node_iterator(node)</code>. For <code>xml_attribute_iterator</code>, you&#8217;ll have to provide both an attribute and its parent node.</p>
</div>
<div class="paragraph">
<p><code>begin</code> and <code>end</code> return equal iterators if called on null node; such iterators can&#8217;t be dereferenced. <code>attributes_begin</code> and <code>attributes_end</code> behave the same way. For correct iterator usage this means that child node/attribute collections of null nodes appear to be empty.</p>
</div>
<div class="paragraph">
<p>Both types of iterators have bidirectional iterator semantics (i.e. they can be incremented and decremented, but efficient random access is not supported) and support all usual iterator operations - comparison, dereference, etc. The iterators are invalidated if the node/attribute objects they&#8217;re pointing to are removed from the tree; adding nodes/attributes does not invalidate any iterators.</p>
</div>
<div class="paragraph">
<p>Here is an example of using iterators for document traversal (<a href="samples/traverse_iter.cpp" class="bare">samples/traverse_iter.cpp</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-k">for</span> <span class="tok-p">(</span><span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xml_node_iterator</span> <span class="tok-n">it</span> <span class="tok-o">=</span> <span class="tok-n">tools</span><span class="tok-p">.</span><span class="tok-n">begin</span><span class="tok-p">();</span> <span class="tok-n">it</span> <span class="tok-o">!=</span> <span class="tok-n">tools</span><span class="tok-p">.</span><span class="tok-n">end</span><span class="tok-p">();</span> <span class="tok-o">++</span><span class="tok-n">it</span><span class="tok-p">)</span>
<span class="tok-p">{</span>
    <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;Tool:&quot;</span><span class="tok-p">;</span>

    <span class="tok-k">for</span> <span class="tok-p">(</span><span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xml_attribute_iterator</span> <span class="tok-n">ait</span> <span class="tok-o">=</span> <span class="tok-n">it</span><span class="tok-o">-&gt;</span><span class="tok-n">attributes_begin</span><span class="tok-p">();</span> <span class="tok-n">ait</span> <span class="tok-o">!=</span> <span class="tok-n">it</span><span class="tok-o">-&gt;</span><span class="tok-n">attributes_end</span><span class="tok-p">();</span> <span class="tok-o">++</span><span class="tok-n">ait</span><span class="tok-p">)</span>
    <span class="tok-p">{</span>
        <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot; &quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">ait</span><span class="tok-o">-&gt;</span><span class="tok-n">name</span><span class="tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;=&quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">ait</span><span class="tok-o">-&gt;</span><span class="tok-n">value</span><span class="tok-p">();</span>
    <span class="tok-p">}</span>

    <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">endl</span><span class="tok-p">;</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
Node and attribute iterators are somewhere in the middle between const and non-const iterators. While dereference operation yields a non-constant reference to the object, so that you can use it for tree modification operations, modifying this reference using assignment - i.e. passing iterators to a function like <code>std::sort</code> - will not give expected results, as assignment modifies local handle that&#8217;s stored in the iterator.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="access.walker"><a class="anchor" href="#access.walker"></a>5.7. Recursive traversal with xml_tree_walker</h3>
<div id="xml_tree_walker" class="paragraph">
<p>The methods described above allow traversal of immediate children of some node; if you want to do a deep tree traversal, you&#8217;ll have to do it via a recursive function or some equivalent method. However, pugixml provides a helper for depth-first traversal of a subtree. In order to use it, you have to implement <code>xml_tree_walker</code> interface and to call <code>traverse</code> function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-k">class</span> <span class="tok-nc">xml_tree_walker</span>
<span class="tok-p">{</span>
<span class="tok-k">public</span><span class="tok-o">:</span>
    <span class="tok-k">virtual</span> <span class="tok-kt">bool</span> <span class="tok-n">begin</span><span class="tok-p">(</span><span class="tok-n">xml_node</span><span class="tok-o">&amp;</span> <span class="tok-n">node</span><span class="tok-p">);</span>
    <span class="tok-k">virtual</span> <span class="tok-kt">bool</span> <span class="tok-n">for_each</span><span class="tok-p">(</span><span class="tok-n">xml_node</span><span class="tok-o">&amp;</span> <span class="tok-n">node</span><span class="tok-p">)</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">;</span>
    <span class="tok-k">virtual</span> <span class="tok-kt">bool</span> <span class="tok-nf">end</span><span class="tok-p">(</span><span class="tok-n">xml_node</span><span class="tok-o">&amp;</span> <span class="tok-n">node</span><span class="tok-p">);</span>

    <span class="tok-kt">int</span> <span class="tok-n">depth</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-p">};</span>

<span class="tok-kt">bool</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">traverse</span><span class="tok-p">(</span><span class="tok-n">xml_tree_walker</span><span class="tok-o">&amp;</span> <span class="tok-n">walker</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><a id="xml_tree_walker::begin"></a><a id="xml_tree_walker::for_each"></a><a id="xml_tree_walker::end"></a><a id="xml_node::traverse"></a>
The traversal is launched by calling <code>traverse</code> function on traversal root and proceeds as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>First, <code>begin</code> function is called with traversal root as its argument.</p>
</li>
<li>
<p>Then, <code>for_each</code> function is called for all nodes in the traversal subtree in depth first order, excluding the traversal root. Node is passed as an argument.</p>
</li>
<li>
<p>Finally, <code>end</code> function is called with traversal root as its argument.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If <code>begin</code>, <code>end</code> or any of the <code>for_each</code> calls return <code>false</code>, the traversal is terminated and <code>false</code> is returned as the traversal result; otherwise, the traversal results in <code>true</code>. Note that you don&#8217;t have to override <code>begin</code> or <code>end</code> functions; their default implementations return <code>true</code>.</p>
</div>
<div id="xml_tree_walker::depth" class="paragraph">
<p>You can get the node&#8217;s depth relative to the traversal root at any point by calling <code>depth</code> function. It returns <code>-1</code> if called from <code>begin</code>/<code>end</code>, and returns 0-based depth if called from <code>for_each</code> - depth is 0 for all children of the traversal root, 1 for all grandchildren and so on.</p>
</div>
<div class="paragraph">
<p>This is an example of traversing tree hierarchy with xml_tree_walker (<a href="samples/traverse_walker.cpp" class="bare">samples/traverse_walker.cpp</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-k">struct</span> <span class="tok-nl">simple_walker</span><span class="tok-p">:</span> <span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xml_tree_walker</span>
<span class="tok-p">{</span>
    <span class="tok-k">virtual</span> <span class="tok-kt">bool</span> <span class="tok-n">for_each</span><span class="tok-p">(</span><span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xml_node</span><span class="tok-o">&amp;</span> <span class="tok-n">node</span><span class="tok-p">)</span>
    <span class="tok-p">{</span>
        <span class="tok-k">for</span> <span class="tok-p">(</span><span class="tok-kt">int</span> <span class="tok-n">i</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">;</span> <span class="tok-n">i</span> <span class="tok-o">&lt;</span> <span class="tok-n">depth</span><span class="tok-p">();</span> <span class="tok-o">++</span><span class="tok-n">i</span><span class="tok-p">)</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;  &quot;</span><span class="tok-p">;</span> <span class="tok-c1">// indentation</span>

        <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">node_types</span><span class="tok-p">[</span><span class="tok-n">node</span><span class="tok-p">.</span><span class="tok-n">type</span><span class="tok-p">()]</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;: name=&#39;&quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">node</span><span class="tok-p">.</span><span class="tok-n">name</span><span class="tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;&#39;, value=&#39;&quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">node</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;&#39;</span><span class="tok-se">\n</span><span class="tok-s">&quot;</span><span class="tok-p">;</span>

        <span class="tok-k">return</span> <span class="tok-nb">true</span><span class="tok-p">;</span> <span class="tok-c1">// continue traversal</span>
    <span class="tok-p">}</span>
<span class="tok-p">};</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-n">simple_walker</span> <span class="tok-n">walker</span><span class="tok-p">;</span>
<span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">traverse</span><span class="tok-p">(</span><span class="tok-n">walker</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="access.predicate"><a class="anchor" href="#access.predicate"></a>5.8. Searching for nodes/attributes with predicates</h3>
<div class="paragraph">
<p><a id="xml_node::find_attribute"></a><a id="xml_node::find_child"></a><a id="xml_node::find_node"></a>
While there are existing functions for getting a node/attribute with known contents, they are often not sufficient for simple queries. As an alternative for manual iteration through nodes/attributes until the needed one is found, you can make a predicate and call one of <code>find_</code> functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-k">template</span> <span class="tok-o">&lt;</span><span class="tok-k">typename</span> <span class="tok-n">Predicate</span><span class="tok-o">&gt;</span> <span class="tok-n">xml_attribute</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">find_attribute</span><span class="tok-p">(</span><span class="tok-n">Predicate</span> <span class="tok-n">pred</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-k">template</span> <span class="tok-o">&lt;</span><span class="tok-k">typename</span> <span class="tok-n">Predicate</span><span class="tok-o">&gt;</span> <span class="tok-n">xml_node</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">find_child</span><span class="tok-p">(</span><span class="tok-n">Predicate</span> <span class="tok-n">pred</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-k">template</span> <span class="tok-o">&lt;</span><span class="tok-k">typename</span> <span class="tok-n">Predicate</span><span class="tok-o">&gt;</span> <span class="tok-n">xml_node</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">find_node</span><span class="tok-p">(</span><span class="tok-n">Predicate</span> <span class="tok-n">pred</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The predicate should be either a plain function or a function object which accepts one argument of type <code>xml_attribute</code> (for <code>find_attribute</code>) or <code>xml_node</code> (for <code>find_child</code> and <code>find_node</code>), and returns <code>bool</code>. The predicate is never called with null handle as an argument.</p>
</div>
<div class="paragraph">
<p><code>find_attribute</code> function iterates through all attributes of the specified node, and returns the first attribute for which the predicate returned <code>true</code>. If the predicate returned <code>false</code> for all attributes or if there were no attributes (including the case where the node is null), null attribute is returned.</p>
</div>
<div class="paragraph">
<p><code>find_child</code> function iterates through all child nodes of the specified node, and returns the first node for which the predicate returned <code>true</code>. If the predicate returned <code>false</code> for all nodes or if there were no child nodes (including the case where the node is null), null node is returned.</p>
</div>
<div class="paragraph">
<p><code>find_node</code> function performs a depth-first traversal through the subtree of the specified node (excluding the node itself), and returns the first node for which the predicate returned <code>true</code>. If the predicate returned <code>false</code> for all nodes or if subtree was empty, null node is returned.</p>
</div>
<div class="paragraph">
<p>This is an example of using predicate-based functions (<a href="samples/traverse_predicate.cpp" class="bare">samples/traverse_predicate.cpp</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-kt">bool</span> <span class="tok-nf">small_timeout</span><span class="tok-p">(</span><span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xml_node</span> <span class="tok-n">node</span><span class="tok-p">)</span>
<span class="tok-p">{</span>
    <span class="tok-k">return</span> <span class="tok-n">node</span><span class="tok-p">.</span><span class="tok-n">attribute</span><span class="tok-p">(</span><span class="tok-s">&quot;Timeout&quot;</span><span class="tok-p">).</span><span class="tok-n">as_int</span><span class="tok-p">()</span> <span class="tok-o">&lt;</span> <span class="tok-mi">20</span><span class="tok-p">;</span>
<span class="tok-p">}</span>

<span class="tok-k">struct</span> <span class="tok-n">allow_remote_predicate</span>
<span class="tok-p">{</span>
    <span class="tok-kt">bool</span> <span class="tok-k">operator</span><span class="tok-p">()(</span><span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xml_attribute</span> <span class="tok-n">attr</span><span class="tok-p">)</span> <span class="tok-k">const</span>
    <span class="tok-p">{</span>
        <span class="tok-k">return</span> <span class="tok-n">strcmp</span><span class="tok-p">(</span><span class="tok-n">attr</span><span class="tok-p">.</span><span class="tok-n">name</span><span class="tok-p">(),</span> <span class="tok-s">&quot;AllowRemote&quot;</span><span class="tok-p">)</span> <span class="tok-o">==</span> <span class="tok-mi">0</span><span class="tok-p">;</span>
    <span class="tok-p">}</span>

    <span class="tok-kt">bool</span> <span class="tok-k">operator</span><span class="tok-p">()(</span><span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xml_node</span> <span class="tok-n">node</span><span class="tok-p">)</span> <span class="tok-k">const</span>
    <span class="tok-p">{</span>
        <span class="tok-k">return</span> <span class="tok-n">node</span><span class="tok-p">.</span><span class="tok-n">attribute</span><span class="tok-p">(</span><span class="tok-s">&quot;AllowRemote&quot;</span><span class="tok-p">).</span><span class="tok-n">as_bool</span><span class="tok-p">();</span>
    <span class="tok-p">}</span>
<span class="tok-p">};</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-c1">// Find child via predicate (looks for direct children only)</span>
<span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">tools</span><span class="tok-p">.</span><span class="tok-n">find_child</span><span class="tok-p">(</span><span class="tok-n">allow_remote_predicate</span><span class="tok-p">()).</span><span class="tok-n">attribute</span><span class="tok-p">(</span><span class="tok-s">&quot;Filename&quot;</span><span class="tok-p">).</span><span class="tok-n">value</span><span class="tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">endl</span><span class="tok-p">;</span>

<span class="tok-c1">// Find node via predicate (looks for all descendants in depth-first order)</span>
<span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">find_node</span><span class="tok-p">(</span><span class="tok-n">allow_remote_predicate</span><span class="tok-p">()).</span><span class="tok-n">attribute</span><span class="tok-p">(</span><span class="tok-s">&quot;Filename&quot;</span><span class="tok-p">).</span><span class="tok-n">value</span><span class="tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">endl</span><span class="tok-p">;</span>

<span class="tok-c1">// Find attribute via predicate</span>
<span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">tools</span><span class="tok-p">.</span><span class="tok-n">last_child</span><span class="tok-p">().</span><span class="tok-n">find_attribute</span><span class="tok-p">(</span><span class="tok-n">allow_remote_predicate</span><span class="tok-p">()).</span><span class="tok-n">value</span><span class="tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">endl</span><span class="tok-p">;</span>

<span class="tok-c1">// We can use simple functions instead of function objects</span>
<span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">tools</span><span class="tok-p">.</span><span class="tok-n">find_child</span><span class="tok-p">(</span><span class="tok-n">small_timeout</span><span class="tok-p">).</span><span class="tok-n">attribute</span><span class="tok-p">(</span><span class="tok-s">&quot;Filename&quot;</span><span class="tok-p">).</span><span class="tok-n">value</span><span class="tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">endl</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="access.text"><a class="anchor" href="#access.text"></a>5.9. Working with text contents</h3>
<div id="xml_text" class="paragraph">
<p>It is common to store data as text contents of some node - i.e. <code>&lt;node&gt;&lt;description&gt;This is a node&lt;/description&gt;&lt;/node&gt;</code>. In this case, <code>&lt;description&gt;</code> node does not have a value, but instead has a child of type <a href="#node_pcdata">node_pcdata</a> with value <code>"This is a node"</code>. pugixml provides a special class, <code>xml_text</code>, to work with such data. Working with text objects to modify data is described in <a href="#modify.text">the documentation for modifying document data</a>; this section describes the access interface of <code>xml_text</code>.</p>
</div>
<div id="xml_node::text" class="paragraph">
<p>You can get the text object from a node by using <code>text()</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-n">xml_text</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">text</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If the node has a type <code>node_pcdata</code> or <code>node_cdata</code>, then the node itself is used to return data; otherwise, a first child node of type <code>node_pcdata</code> or <code>node_cdata</code> is used.</p>
</div>
<div class="paragraph">
<p><a id="xml_text::empty"></a><a id="xml_text::unspecified_bool_type"></a>
You can check if the text object is bound to a valid PCDATA/CDATA node by using it as a boolean value, i.e. <code>if (text) { &#8230;&#8203; }</code> or <code>if (!text) { &#8230;&#8203; }</code>. Alternatively you can check it by using the <code>empty()</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-kt">bool</span> <span class="tok-n">xml_text</span><span class="tok-o">::</span><span class="tok-n">empty</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div id="xml_text::get" class="paragraph">
<p>Given a text object, you can get the contents (i.e. the value of PCDATA/CDATA node) by using the following function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">xml_text</span><span class="tok-o">::</span><span class="tok-n">get</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In case text object is empty, the function returns an empty string - it never returns a null pointer.</p>
</div>
<div class="paragraph">
<p><a id="xml_text::as_string"></a><a id="xml_text::as_int"></a><a id="xml_text::as_uint"></a><a id="xml_text::as_double"></a><a id="xml_text::as_float"></a><a id="xml_text::as_bool"></a><a id="xml_text::as_llong"></a><a id="xml_text::as_ullong"></a>
If you need a non-empty string if the text object is empty, or if the text contents is actually a number or a boolean that is stored as a string, you can use the following accessors:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">xml_text</span><span class="tok-o">::</span><span class="tok-n">as_string</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">def</span> <span class="tok-o">=</span> <span class="tok-s">&quot;&quot;</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-kt">int</span> <span class="tok-n">xml_text</span><span class="tok-o">::</span><span class="tok-n">as_int</span><span class="tok-p">(</span><span class="tok-kt">int</span> <span class="tok-n">def</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">xml_text</span><span class="tok-o">::</span><span class="tok-n">as_uint</span><span class="tok-p">(</span><span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">def</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-kt">double</span> <span class="tok-n">xml_text</span><span class="tok-o">::</span><span class="tok-n">as_double</span><span class="tok-p">(</span><span class="tok-kt">double</span> <span class="tok-n">def</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-kt">float</span> <span class="tok-n">xml_text</span><span class="tok-o">::</span><span class="tok-n">as_float</span><span class="tok-p">(</span><span class="tok-kt">float</span> <span class="tok-n">def</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-kt">bool</span> <span class="tok-n">xml_text</span><span class="tok-o">::</span><span class="tok-n">as_bool</span><span class="tok-p">(</span><span class="tok-kt">bool</span> <span class="tok-n">def</span> <span class="tok-o">=</span> <span class="tok-nb">false</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-kt">long</span> <span class="tok-kt">long</span> <span class="tok-n">xml_text</span><span class="tok-o">::</span><span class="tok-n">as_llong</span><span class="tok-p">(</span><span class="tok-kt">long</span> <span class="tok-kt">long</span> <span class="tok-n">def</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-kt">unsigned</span> <span class="tok-kt">long</span> <span class="tok-kt">long</span> <span class="tok-n">xml_text</span><span class="tok-o">::</span><span class="tok-n">as_ullong</span><span class="tok-p">(</span><span class="tok-kt">unsigned</span> <span class="tok-kt">long</span> <span class="tok-kt">long</span> <span class="tok-n">def</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>All of the above functions have the same semantics as similar <code>xml_attribute</code> members: they return the default argument if the text object is empty, they convert the text contents to a target type using the same rules and restrictions. You can <a href="#xml_attribute::as_int">refer to documentation for the attribute functions</a> for details.</p>
</div>
<div id="xml_text::data" class="paragraph">
<p><code>xml_text</code> is essentially a helper class that operates on <code>xml_node</code> values. It is bound to a node of type <a href="#node_pcdata">node_pcdata</a> or <a href="#node_cdata">node_cdata</a>. You can use the following function to retrieve this node:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-n">xml_node</span> <span class="tok-n">xml_text</span><span class="tok-o">::</span><span class="tok-n">data</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Essentially, assuming <code>text</code> is an <code>xml_text</code> object, calling <code>text.get()</code> is equivalent to calling <code>text.data().value()</code>.</p>
</div>
<div class="paragraph">
<p>This is an example of using <code>xml_text</code> object (<a href="samples/text.cpp" class="bare">samples/text.cpp</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;Project name: &quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">project</span><span class="tok-p">.</span><span class="tok-n">child</span><span class="tok-p">(</span><span class="tok-s">&quot;name&quot;</span><span class="tok-p">).</span><span class="tok-n">text</span><span class="tok-p">().</span><span class="tok-n">get</span><span class="tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">endl</span><span class="tok-p">;</span>
<span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;Project version: &quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">project</span><span class="tok-p">.</span><span class="tok-n">child</span><span class="tok-p">(</span><span class="tok-s">&quot;version&quot;</span><span class="tok-p">).</span><span class="tok-n">text</span><span class="tok-p">().</span><span class="tok-n">as_double</span><span class="tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">endl</span><span class="tok-p">;</span>
<span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;Project visibility: &quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-p">(</span><span class="tok-n">project</span><span class="tok-p">.</span><span class="tok-n">child</span><span class="tok-p">(</span><span class="tok-s">&quot;public&quot;</span><span class="tok-p">).</span><span class="tok-n">text</span><span class="tok-p">().</span><span class="tok-n">as_bool</span><span class="tok-p">(</span><span class="tok-cm">/* def= */</span> <span class="tok-nb">true</span><span class="tok-p">)</span> <span class="tok-o">?</span> <span class="tok-s">&quot;public&quot;</span> <span class="tok-o">:</span> <span class="tok-s">&quot;private&quot;</span><span class="tok-p">)</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">endl</span><span class="tok-p">;</span>
<span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;Project description: &quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">project</span><span class="tok-p">.</span><span class="tok-n">child</span><span class="tok-p">(</span><span class="tok-s">&quot;description&quot;</span><span class="tok-p">).</span><span class="tok-n">text</span><span class="tok-p">().</span><span class="tok-n">get</span><span class="tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">endl</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="access.misc"><a class="anchor" href="#access.misc"></a>5.10. Miscellaneous functions</h3>
<div id="xml_node::root" class="paragraph">
<p>If you need to get the document root of some node, you can use the following function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-n">xml_node</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">root</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This function returns the node with type <a href="#node_document">node_document</a>, which is the root node of the document the node belongs to (unless the node is null, in which case null node is returned).</p>
</div>
<div class="paragraph">
<p><a id="xml_node::path"></a><a id="xml_node::first_element_by_path"></a>
While pugixml supports complex XPath expressions, sometimes a simple path handling facility is needed. There are two functions, for getting node path and for converting path to a node:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-kt">string_t</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">path</span><span class="tok-p">(</span><span class="tok-kt">char_t</span> <span class="tok-n">delimiter</span> <span class="tok-o">=</span> <span class="tok-sc">&#39;/&#39;</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-n">xml_node</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">first_element_by_path</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">path</span><span class="tok-p">,</span> <span class="tok-kt">char_t</span> <span class="tok-n">delimiter</span> <span class="tok-o">=</span> <span class="tok-sc">&#39;/&#39;</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Node paths consist of node names, separated with a delimiter (which is <code>/</code> by default); also paths can contain self (<code>.</code>) and parent (<code>..</code>) pseudo-names, so that this is a valid path: <code>"../../foo/./bar"</code>. <code>path</code> returns the path to the node from the document root, <code>first_element_by_path</code> looks for a node represented by a given path; a path can be an absolute one (absolute paths start with the delimiter), in which case the rest of the path is treated as document root relative, and relative to the given node. For example, in the following document: <code>&lt;a&gt;&lt;b&gt;&lt;c/&gt;&lt;/b&gt;&lt;/a&gt;</code>, node <code>&lt;c/&gt;</code> has path <code>"a/b/c"</code>; calling <code>first_element_by_path</code> for document with path <code>"a/b"</code> results in node <code>&lt;b/&gt;</code>; calling <code>first_element_by_path</code> for node <code>&lt;a/&gt;</code> with path <code>"../a/./b/../."</code> results in node <code>&lt;a/&gt;</code>; calling <code>first_element_by_path</code> with path <code>"/a"</code> results in node <code>&lt;a/&gt;</code> for any node.</p>
</div>
<div class="paragraph">
<p>In case path component is ambiguous (if there are two nodes with given name), the first one is selected; paths are not guaranteed to uniquely identify nodes in a document. If any component of a path is not found, the result of <code>first_element_by_path</code> is null node; also <code>first_element_by_path</code> returns null node for null nodes, in which case the path does not matter. <code>path</code> returns an empty string for null nodes.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<code>path</code> function returns the result as STL string, and thus is not available if <a href="#PUGIXML_NO_STL">PUGIXML_NO_STL</a> is defined.
</td>
</tr>
</table>
</div>
<div id="xml_node::offset_debug" class="paragraph">
<p>pugixml does not record row/column information for nodes upon parsing for efficiency reasons. However, if the node has not changed in a significant way since parsing (the name/value are not changed, and the node itself is the original one, i.e. it was not deleted from the tree and re-added later), it is possible to get the offset from the beginning of XML buffer:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-kt">ptrdiff_t</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">offset_debug</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If the offset is not available (this happens if the node is null, was not originally parsed from a stream, or has changed in a significant way), the function returns -1. Otherwise it returns the offset to node&#8217;s data from the beginning of XML buffer in <a href="#char_t">pugi::char_t</a> units. For more information on parsing offsets, see <a href="#xml_parse_result::offset">parsing error handling documentation</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="modify"><a class="anchor" href="#modify"></a>6. Modifying document data</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The document in pugixml is fully mutable: you can completely change the document structure and modify the data of nodes/attributes. This section provides documentation for the relevant functions. All functions take care of memory management and structural integrity themselves, so they always result in structurally valid tree - however, it is possible to create an invalid XML tree (for example, by adding two attributes with the same name or by setting attribute/node name to empty/invalid string). Tree modification is optimized for performance and for memory consumption, so if you have enough memory you can create documents from scratch with pugixml and later save them to file/stream instead of relying on error-prone manual text writing and without too much overhead.</p>
</div>
<div class="paragraph">
<p>All member functions that change node/attribute data or structure are non-constant and thus can not be called on constant handles. However, you can easily convert constant handle to non-constant one by simple assignment: <code>void foo(const pugi::xml_node&amp; n) { pugi::xml_node nc = n; }</code>, so const-correctness here mainly provides additional documentation.</p>
</div>
<div class="sect2">
<h3 id="modify.nodedata"><a class="anchor" href="#modify.nodedata"></a>6.1. Setting node data</h3>
<div class="paragraph">
<p><a id="xml_node::set_name"></a><a id="xml_node::set_value"></a>
As discussed before, nodes can have name and value, both of which are strings. Depending on node type, name or value may be absent. <a href="#node_document">node_document</a> nodes do not have a name or value, <a href="#node_element">node_element</a> and <a href="#node_declaration">node_declaration</a> nodes always have a name but never have a value, <a href="#node_pcdata">node_pcdata</a>, <a href="#node_cdata">node_cdata</a>, <a href="#node_comment">node_comment</a> and <a href="#node_doctype">node_doctype</a> nodes never have a name but always have a value (it may be empty though), <a href="#node_pi">node_pi</a> nodes always have a name and a value (again, value may be empty). In order to set node&#8217;s name or value, you can use the following functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-kt">bool</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">set_name</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
<span class="tok-kt">bool</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">set_value</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">rhs</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Both functions try to set the name/value to the specified string, and return the operation result. The operation fails if the node can not have name or value (for instance, when trying to call <code>set_name</code> on a <a href="#node_pcdata">node_pcdata</a> node), if the node handle is null, or if there is insufficient memory to handle the request. The provided string is copied into document managed memory and can be destroyed after the function returns (for example, you can safely pass stack-allocated buffers to these functions). The name/value content is not verified, so take care to use only valid XML names, or the document may become malformed.</p>
</div>
<div class="paragraph">
<p>This is an example of setting node name and value (<a href="samples/modify_base.cpp" class="bare">samples/modify_base.cpp</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xml_node</span> <span class="tok-n">node</span> <span class="tok-o">=</span> <span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">child</span><span class="tok-p">(</span><span class="tok-s">&quot;node&quot;</span><span class="tok-p">);</span>

<span class="tok-c1">// change node name</span>
<span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">node</span><span class="tok-p">.</span><span class="tok-n">set_name</span><span class="tok-p">(</span><span class="tok-s">&quot;notnode&quot;</span><span class="tok-p">);</span>
<span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;, new node name: &quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">node</span><span class="tok-p">.</span><span class="tok-n">name</span><span class="tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">endl</span><span class="tok-p">;</span>

<span class="tok-c1">// change comment text</span>
<span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">last_child</span><span class="tok-p">().</span><span class="tok-n">set_value</span><span class="tok-p">(</span><span class="tok-s">&quot;useless comment&quot;</span><span class="tok-p">);</span>
<span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;, new comment text: &quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">last_child</span><span class="tok-p">().</span><span class="tok-n">value</span><span class="tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">endl</span><span class="tok-p">;</span>

<span class="tok-c1">// we can&#39;t change value of the element or name of the comment</span>
<span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">node</span><span class="tok-p">.</span><span class="tok-n">set_value</span><span class="tok-p">(</span><span class="tok-s">&quot;1&quot;</span><span class="tok-p">)</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;, &quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">last_child</span><span class="tok-p">().</span><span class="tok-n">set_name</span><span class="tok-p">(</span><span class="tok-s">&quot;2&quot;</span><span class="tok-p">)</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">endl</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="modify.attrdata"><a class="anchor" href="#modify.attrdata"></a>6.2. Setting attribute data</h3>
<div class="paragraph">
<p><a id="xml_attribute::set_name"></a><a id="xml_attribute::set_value"></a>
All attributes have name and value, both of which are strings (value may be empty). You can set them with the following functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-kt">bool</span> <span class="tok-n">xml_attribute</span><span class="tok-o">::</span><span class="tok-n">set_name</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
<span class="tok-kt">bool</span> <span class="tok-n">xml_attribute</span><span class="tok-o">::</span><span class="tok-n">set_value</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">rhs</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Both functions try to set the name/value to the specified string, and return the operation result. The operation fails if the attribute handle is null, or if there is insufficient memory to handle the request. The provided string is copied into document managed memory and can be destroyed after the function returns (for example, you can safely pass stack-allocated buffers to these functions). The name/value content is not verified, so take care to use only valid XML names, or the document may become malformed.</p>
</div>
<div class="paragraph">
<p>In addition to string functions, several functions are provided for handling attributes with numbers and booleans as values:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-kt">bool</span> <span class="tok-n">xml_attribute</span><span class="tok-o">::</span><span class="tok-n">set_value</span><span class="tok-p">(</span><span class="tok-kt">int</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
<span class="tok-kt">bool</span> <span class="tok-n">xml_attribute</span><span class="tok-o">::</span><span class="tok-n">set_value</span><span class="tok-p">(</span><span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
<span class="tok-kt">bool</span> <span class="tok-n">xml_attribute</span><span class="tok-o">::</span><span class="tok-n">set_value</span><span class="tok-p">(</span><span class="tok-kt">double</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
<span class="tok-kt">bool</span> <span class="tok-n">xml_attribute</span><span class="tok-o">::</span><span class="tok-n">set_value</span><span class="tok-p">(</span><span class="tok-kt">float</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
<span class="tok-kt">bool</span> <span class="tok-n">xml_attribute</span><span class="tok-o">::</span><span class="tok-n">set_value</span><span class="tok-p">(</span><span class="tok-kt">bool</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
<span class="tok-kt">bool</span> <span class="tok-n">xml_attribute</span><span class="tok-o">::</span><span class="tok-n">set_value</span><span class="tok-p">(</span><span class="tok-kt">long</span> <span class="tok-kt">long</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
<span class="tok-kt">bool</span> <span class="tok-n">xml_attribute</span><span class="tok-o">::</span><span class="tok-n">set_value</span><span class="tok-p">(</span><span class="tok-kt">unsigned</span> <span class="tok-kt">long</span> <span class="tok-kt">long</span> <span class="tok-n">rhs</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The above functions convert the argument to string and then call the base <code>set_value</code> function. Integers are converted to a decimal form, floating-point numbers are converted to either decimal or scientific form, depending on the number magnitude, boolean values are converted to either <code>"true"</code> or <code>"false"</code>.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
Number conversion functions depend on current C locale as set with <code>setlocale</code>, so may generate unexpected results if the locale is different from <code>"C"</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<code>set_value</code> overloads with <code>long long</code> type are only available if your platform has reliable support for the type, including string conversions.
</td>
</tr>
</table>
</div>
<div id="xml_attribute::assign" class="paragraph">
<p>For convenience, all <code>set_value</code> functions have the corresponding assignment operators:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-n">xml_attribute</span><span class="tok-o">&amp;</span> <span class="tok-n">xml_attribute</span><span class="tok-o">::</span><span class="tok-k">operator</span><span class="tok-o">=</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
<span class="tok-n">xml_attribute</span><span class="tok-o">&amp;</span> <span class="tok-n">xml_attribute</span><span class="tok-o">::</span><span class="tok-k">operator</span><span class="tok-o">=</span><span class="tok-p">(</span><span class="tok-kt">int</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
<span class="tok-n">xml_attribute</span><span class="tok-o">&amp;</span> <span class="tok-n">xml_attribute</span><span class="tok-o">::</span><span class="tok-k">operator</span><span class="tok-o">=</span><span class="tok-p">(</span><span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
<span class="tok-n">xml_attribute</span><span class="tok-o">&amp;</span> <span class="tok-n">xml_attribute</span><span class="tok-o">::</span><span class="tok-k">operator</span><span class="tok-o">=</span><span class="tok-p">(</span><span class="tok-kt">double</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
<span class="tok-n">xml_attribute</span><span class="tok-o">&amp;</span> <span class="tok-n">xml_attribute</span><span class="tok-o">::</span><span class="tok-k">operator</span><span class="tok-o">=</span><span class="tok-p">(</span><span class="tok-kt">float</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
<span class="tok-n">xml_attribute</span><span class="tok-o">&amp;</span> <span class="tok-n">xml_attribute</span><span class="tok-o">::</span><span class="tok-k">operator</span><span class="tok-o">=</span><span class="tok-p">(</span><span class="tok-kt">bool</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
<span class="tok-n">xml_attribute</span><span class="tok-o">&amp;</span> <span class="tok-n">xml_attribute</span><span class="tok-o">::</span><span class="tok-k">operator</span><span class="tok-o">=</span><span class="tok-p">(</span><span class="tok-kt">long</span> <span class="tok-kt">long</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
<span class="tok-n">xml_attribute</span><span class="tok-o">&amp;</span> <span class="tok-n">xml_attribute</span><span class="tok-o">::</span><span class="tok-k">operator</span><span class="tok-o">=</span><span class="tok-p">(</span><span class="tok-kt">unsigned</span> <span class="tok-kt">long</span> <span class="tok-kt">long</span> <span class="tok-n">rhs</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>These operators simply call the right <code>set_value</code> function and return the attribute they&#8217;re called on; the return value of <code>set_value</code> is ignored, so errors are ignored.</p>
</div>
<div class="paragraph">
<p>This is an example of setting attribute name and value (<a href="samples/modify_base.cpp" class="bare">samples/modify_base.cpp</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xml_attribute</span> <span class="tok-n">attr</span> <span class="tok-o">=</span> <span class="tok-n">node</span><span class="tok-p">.</span><span class="tok-n">attribute</span><span class="tok-p">(</span><span class="tok-s">&quot;id&quot;</span><span class="tok-p">);</span>

<span class="tok-c1">// change attribute name/value</span>
<span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">attr</span><span class="tok-p">.</span><span class="tok-n">set_name</span><span class="tok-p">(</span><span class="tok-s">&quot;key&quot;</span><span class="tok-p">)</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;, &quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">attr</span><span class="tok-p">.</span><span class="tok-n">set_value</span><span class="tok-p">(</span><span class="tok-s">&quot;345&quot;</span><span class="tok-p">);</span>
<span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;, new attribute: &quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">attr</span><span class="tok-p">.</span><span class="tok-n">name</span><span class="tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;=&quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">attr</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">endl</span><span class="tok-p">;</span>

<span class="tok-c1">// we can use numbers or booleans</span>
<span class="tok-n">attr</span><span class="tok-p">.</span><span class="tok-n">set_value</span><span class="tok-p">(</span><span class="tok-mf">1.234</span><span class="tok-p">);</span>
<span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;new attribute value: &quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">attr</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">endl</span><span class="tok-p">;</span>

<span class="tok-c1">// we can also use assignment operators for more concise code</span>
<span class="tok-n">attr</span> <span class="tok-o">=</span> <span class="tok-nb">true</span><span class="tok-p">;</span>
<span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;final attribute value: &quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">attr</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">endl</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="modify.add"><a class="anchor" href="#modify.add"></a>6.3. Adding nodes/attributes</h3>
<div class="paragraph">
<p><a id="xml_node::prepend_attribute"></a><a id="xml_node::append_attribute"></a><a id="xml_node::insert_attribute_after"></a><a id="xml_node::insert_attribute_before"></a><a id="xml_node::prepend_child"></a><a id="xml_node::append_child"></a><a id="xml_node::insert_child_after"></a><a id="xml_node::insert_child_before"></a>
Nodes and attributes do not exist without a document tree, so you can&#8217;t create them without adding them to some document. A node or attribute can be created at the end of node/attribute list or before/after some other node:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-n">xml_attribute</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">append_attribute</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">name</span><span class="tok-p">);</span>
<span class="tok-n">xml_attribute</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">prepend_attribute</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">name</span><span class="tok-p">);</span>
<span class="tok-n">xml_attribute</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">insert_attribute_after</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">name</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-n">xml_attribute</span><span class="tok-o">&amp;</span> <span class="tok-n">attr</span><span class="tok-p">);</span>
<span class="tok-n">xml_attribute</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">insert_attribute_before</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">name</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-n">xml_attribute</span><span class="tok-o">&amp;</span> <span class="tok-n">attr</span><span class="tok-p">);</span>

<span class="tok-n">xml_node</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">append_child</span><span class="tok-p">(</span><span class="tok-n">xml_node_type</span> <span class="tok-n">type</span> <span class="tok-o">=</span> <span class="tok-n">node_element</span><span class="tok-p">);</span>
<span class="tok-n">xml_node</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">prepend_child</span><span class="tok-p">(</span><span class="tok-n">xml_node_type</span> <span class="tok-n">type</span> <span class="tok-o">=</span> <span class="tok-n">node_element</span><span class="tok-p">);</span>
<span class="tok-n">xml_node</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">insert_child_after</span><span class="tok-p">(</span><span class="tok-n">xml_node_type</span> <span class="tok-n">type</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-n">xml_node</span><span class="tok-o">&amp;</span> <span class="tok-n">node</span><span class="tok-p">);</span>
<span class="tok-n">xml_node</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">insert_child_before</span><span class="tok-p">(</span><span class="tok-n">xml_node_type</span> <span class="tok-n">type</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-n">xml_node</span><span class="tok-o">&amp;</span> <span class="tok-n">node</span><span class="tok-p">);</span>

<span class="tok-n">xml_node</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">append_child</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">name</span><span class="tok-p">);</span>
<span class="tok-n">xml_node</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">prepend_child</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">name</span><span class="tok-p">);</span>
<span class="tok-n">xml_node</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">insert_child_after</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">name</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-n">xml_node</span><span class="tok-o">&amp;</span> <span class="tok-n">node</span><span class="tok-p">);</span>
<span class="tok-n">xml_node</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">insert_child_before</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">name</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-n">xml_node</span><span class="tok-o">&amp;</span> <span class="tok-n">node</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>append_attribute</code> and <code>append_child</code> create a new node/attribute at the end of the corresponding list of the node the method is called on; <code>prepend_attribute</code> and <code>prepend_child</code> create a new node/attribute at the beginning of the list; <code>insert_attribute_after</code>, <code>insert_attribute_before</code>, <code>insert_child_after</code> and <code>insert_attribute_before</code> add the node/attribute before or after the specified node/attribute.</p>
</div>
<div class="paragraph">
<p>Attribute functions create an attribute with the specified name; you can specify the empty name and change the name later if you want to. Node functions with the <code>type</code> argument create the node with the specified type; since node type can&#8217;t be changed, you have to know the desired type beforehand. Also note that not all types can be added as children; see below for clarification. Node functions with the <code>name</code> argument create the element node (<a href="#node_element">node_element</a>) with the specified name.</p>
</div>
<div class="paragraph">
<p>All functions return the handle to the created object on success, and null handle on failure. There are several reasons for failure:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Adding fails if the target node is null;</p>
</li>
<li>
<p>Only <a href="#node_element">node_element</a> nodes can contain attributes, so attribute adding fails if node is not an element;</p>
</li>
<li>
<p>Only <a href="#node_document">node_document</a> and <a href="#node_element">node_element</a> nodes can contain children, so child node adding fails if the target node is not an element or a document;</p>
</li>
<li>
<p><a href="#node_document">node_document</a> and <a href="#node_null">node_null</a> nodes can not be inserted as children, so passing <a href="#node_document">node_document</a> or <a href="#node_null">node_null</a> value as <code>type</code> results in operation failure;</p>
</li>
<li>
<p><a href="#node_declaration">node_declaration</a> nodes can only be added as children of the document node; attempt to insert declaration node as a child of an element node fails;</p>
</li>
<li>
<p>Adding node/attribute results in memory allocation, which may fail;</p>
</li>
<li>
<p>Insertion functions fail if the specified node or attribute is null or is not in the target node&#8217;s children/attribute list.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Even if the operation fails, the document remains in consistent state, but the requested node/attribute is not added.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
<code>attribute()</code> and <code>child()</code> functions do not add attributes or nodes to the tree, so code like <code>node.attribute("id") = 123;</code> will not do anything if <code>node</code> does not have an attribute with name <code>"id"</code>. Make sure you&#8217;re operating with existing attributes/nodes by adding them if necessary.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This is an example of adding new attributes/nodes to the document (<a href="samples/modify_add.cpp" class="bare">samples/modify_add.cpp</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-c1">// add node with some name</span>
<span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xml_node</span> <span class="tok-n">node</span> <span class="tok-o">=</span> <span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">append_child</span><span class="tok-p">(</span><span class="tok-s">&quot;node&quot;</span><span class="tok-p">);</span>

<span class="tok-c1">// add description node with text child</span>
<span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xml_node</span> <span class="tok-n">descr</span> <span class="tok-o">=</span> <span class="tok-n">node</span><span class="tok-p">.</span><span class="tok-n">append_child</span><span class="tok-p">(</span><span class="tok-s">&quot;description&quot;</span><span class="tok-p">);</span>
<span class="tok-n">descr</span><span class="tok-p">.</span><span class="tok-n">append_child</span><span class="tok-p">(</span><span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">node_pcdata</span><span class="tok-p">).</span><span class="tok-n">set_value</span><span class="tok-p">(</span><span class="tok-s">&quot;Simple node&quot;</span><span class="tok-p">);</span>

<span class="tok-c1">// add param node before the description</span>
<span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xml_node</span> <span class="tok-n">param</span> <span class="tok-o">=</span> <span class="tok-n">node</span><span class="tok-p">.</span><span class="tok-n">insert_child_before</span><span class="tok-p">(</span><span class="tok-s">&quot;param&quot;</span><span class="tok-p">,</span> <span class="tok-n">descr</span><span class="tok-p">);</span>

<span class="tok-c1">// add attributes to param node</span>
<span class="tok-n">param</span><span class="tok-p">.</span><span class="tok-n">append_attribute</span><span class="tok-p">(</span><span class="tok-s">&quot;name&quot;</span><span class="tok-p">)</span> <span class="tok-o">=</span> <span class="tok-s">&quot;version&quot;</span><span class="tok-p">;</span>
<span class="tok-n">param</span><span class="tok-p">.</span><span class="tok-n">append_attribute</span><span class="tok-p">(</span><span class="tok-s">&quot;value&quot;</span><span class="tok-p">)</span> <span class="tok-o">=</span> <span class="tok-mf">1.1</span><span class="tok-p">;</span>
<span class="tok-n">param</span><span class="tok-p">.</span><span class="tok-n">insert_attribute_after</span><span class="tok-p">(</span><span class="tok-s">&quot;type&quot;</span><span class="tok-p">,</span> <span class="tok-n">param</span><span class="tok-p">.</span><span class="tok-n">attribute</span><span class="tok-p">(</span><span class="tok-s">&quot;name&quot;</span><span class="tok-p">))</span> <span class="tok-o">=</span> <span class="tok-s">&quot;float&quot;</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="modify.remove"><a class="anchor" href="#modify.remove"></a>6.4. Removing nodes/attributes</h3>
<div class="paragraph">
<p><a id="xml_node::remove_attribute"></a><a id="xml_node::remove_child"></a>
If you do not want your document to contain some node or attribute, you can remove it with one of the following functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-kt">bool</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">remove_attribute</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xml_attribute</span><span class="tok-o">&amp;</span> <span class="tok-n">a</span><span class="tok-p">);</span>
<span class="tok-kt">bool</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">remove_child</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xml_node</span><span class="tok-o">&amp;</span> <span class="tok-n">n</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>remove_attribute</code> removes the attribute from the attribute list of the node, and returns the operation result. <code>remove_child</code> removes the child node with the entire subtree (including all descendant nodes and attributes) from the document, and returns the operation result. Removing fails if one of the following is true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The node the function is called on is null;</p>
</li>
<li>
<p>The attribute/node to be removed is null;</p>
</li>
<li>
<p>The attribute/node to be removed is not in the node&#8217;s attribute/child list.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Removing the attribute or node invalidates all handles to the same underlying object, and also invalidates all iterators pointing to the same object. Removing node also invalidates all past-the-end iterators to its attribute or child node list. Be careful to ensure that all such handles and iterators either do not exist or are not used after the attribute/node is removed.</p>
</div>
<div class="paragraph">
<p>If you want to remove the attribute or child node by its name, two additional helper functions are available:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-kt">bool</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">remove_attribute</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">name</span><span class="tok-p">);</span>
<span class="tok-kt">bool</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">remove_child</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">name</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>These functions look for the first attribute or child with the specified name, and then remove it, returning the result. If there is no attribute or child with such name, the function returns <code>false</code>; if there are two nodes with the given name, only the first node is deleted. If you want to delete all nodes with the specified name, you can use code like this: <code>while (node.remove_child("tool")) ;</code>.</p>
</div>
<div class="paragraph">
<p>This is an example of removing attributes/nodes from the document (<a href="samples/modify_remove.cpp" class="bare">samples/modify_remove.cpp</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-c1">// remove description node with the whole subtree</span>
<span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xml_node</span> <span class="tok-n">node</span> <span class="tok-o">=</span> <span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">child</span><span class="tok-p">(</span><span class="tok-s">&quot;node&quot;</span><span class="tok-p">);</span>
<span class="tok-n">node</span><span class="tok-p">.</span><span class="tok-n">remove_child</span><span class="tok-p">(</span><span class="tok-s">&quot;description&quot;</span><span class="tok-p">);</span>

<span class="tok-c1">// remove id attribute</span>
<span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xml_node</span> <span class="tok-n">param</span> <span class="tok-o">=</span> <span class="tok-n">node</span><span class="tok-p">.</span><span class="tok-n">child</span><span class="tok-p">(</span><span class="tok-s">&quot;param&quot;</span><span class="tok-p">);</span>
<span class="tok-n">param</span><span class="tok-p">.</span><span class="tok-n">remove_attribute</span><span class="tok-p">(</span><span class="tok-s">&quot;value&quot;</span><span class="tok-p">);</span>

<span class="tok-c1">// we can also remove nodes/attributes by handles</span>
<span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xml_attribute</span> <span class="tok-n">id</span> <span class="tok-o">=</span> <span class="tok-n">param</span><span class="tok-p">.</span><span class="tok-n">attribute</span><span class="tok-p">(</span><span class="tok-s">&quot;name&quot;</span><span class="tok-p">);</span>
<span class="tok-n">param</span><span class="tok-p">.</span><span class="tok-n">remove_attribute</span><span class="tok-p">(</span><span class="tok-n">id</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="modify.text"><a class="anchor" href="#modify.text"></a>6.5. Working with text contents</h3>
<div class="paragraph">
<p>pugixml provides a special class, <code>xml_text</code>, to work with text contents stored as a value of some node, i.e. <code>&lt;node&gt;&lt;description&gt;This is a node&lt;/description&gt;&lt;/node&gt;</code>. Working with text objects to retrieve data is described in <a href="#access.text">the documentation for accessing document data</a>; this section describes the modification interface of <code>xml_text</code>.</p>
</div>
<div id="xml_text::set" class="paragraph">
<p>Once you have an <code>xml_text</code> object, you can set the text contents using the following function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-kt">bool</span> <span class="tok-n">xml_text</span><span class="tok-o">::</span><span class="tok-n">set</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">rhs</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This function tries to set the contents to the specified string, and returns the operation result. The operation fails if the text object was retrieved from a node that can not have a value and is not an element node (i.e. it is a <a href="#node_declaration">node_declaration</a> node), if the text object is empty, or if there is insufficient memory to handle the request. The provided string is copied into document managed memory and can be destroyed after the function returns (for example, you can safely pass stack-allocated buffers to this function). Note that if the text object was retrieved from an element node, this function creates the PCDATA child node if necessary (i.e. if the element node does not have a PCDATA/CDATA child already).</p>
</div>
<div id="xml_text::set_value" class="paragraph">
<p>In addition to a string function, several functions are provided for handling text with numbers and booleans as contents:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-kt">bool</span> <span class="tok-n">xml_text</span><span class="tok-o">::</span><span class="tok-n">set</span><span class="tok-p">(</span><span class="tok-kt">int</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
<span class="tok-kt">bool</span> <span class="tok-n">xml_text</span><span class="tok-o">::</span><span class="tok-n">set</span><span class="tok-p">(</span><span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
<span class="tok-kt">bool</span> <span class="tok-n">xml_text</span><span class="tok-o">::</span><span class="tok-n">set</span><span class="tok-p">(</span><span class="tok-kt">double</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
<span class="tok-kt">bool</span> <span class="tok-n">xml_text</span><span class="tok-o">::</span><span class="tok-n">set</span><span class="tok-p">(</span><span class="tok-kt">float</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
<span class="tok-kt">bool</span> <span class="tok-n">xml_text</span><span class="tok-o">::</span><span class="tok-n">set</span><span class="tok-p">(</span><span class="tok-kt">bool</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
<span class="tok-kt">bool</span> <span class="tok-n">xml_text</span><span class="tok-o">::</span><span class="tok-n">set</span><span class="tok-p">(</span><span class="tok-kt">long</span> <span class="tok-kt">long</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
<span class="tok-kt">bool</span> <span class="tok-n">xml_text</span><span class="tok-o">::</span><span class="tok-n">set</span><span class="tok-p">(</span><span class="tok-kt">unsigned</span> <span class="tok-kt">long</span> <span class="tok-kt">long</span> <span class="tok-n">rhs</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The above functions convert the argument to string and then call the base <code>set</code> function. These functions have the same semantics as similar <code>xml_attribute</code> functions. You can <a href="#xml_attribute::set_value">refer to documentation for the attribute functions</a> for details.</p>
</div>
<div id="xml_text::assign" class="paragraph">
<p>For convenience, all <code>set</code> functions have the corresponding assignment operators:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-n">xml_text</span><span class="tok-o">&amp;</span> <span class="tok-n">xml_text</span><span class="tok-o">::</span><span class="tok-k">operator</span><span class="tok-o">=</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
<span class="tok-n">xml_text</span><span class="tok-o">&amp;</span> <span class="tok-n">xml_text</span><span class="tok-o">::</span><span class="tok-k">operator</span><span class="tok-o">=</span><span class="tok-p">(</span><span class="tok-kt">int</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
<span class="tok-n">xml_text</span><span class="tok-o">&amp;</span> <span class="tok-n">xml_text</span><span class="tok-o">::</span><span class="tok-k">operator</span><span class="tok-o">=</span><span class="tok-p">(</span><span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
<span class="tok-n">xml_text</span><span class="tok-o">&amp;</span> <span class="tok-n">xml_text</span><span class="tok-o">::</span><span class="tok-k">operator</span><span class="tok-o">=</span><span class="tok-p">(</span><span class="tok-kt">double</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
<span class="tok-n">xml_text</span><span class="tok-o">&amp;</span> <span class="tok-n">xml_text</span><span class="tok-o">::</span><span class="tok-k">operator</span><span class="tok-o">=</span><span class="tok-p">(</span><span class="tok-kt">float</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
<span class="tok-n">xml_text</span><span class="tok-o">&amp;</span> <span class="tok-n">xml_text</span><span class="tok-o">::</span><span class="tok-k">operator</span><span class="tok-o">=</span><span class="tok-p">(</span><span class="tok-kt">bool</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
<span class="tok-n">xml_text</span><span class="tok-o">&amp;</span> <span class="tok-n">xml_text</span><span class="tok-o">::</span><span class="tok-k">operator</span><span class="tok-o">=</span><span class="tok-p">(</span><span class="tok-kt">long</span> <span class="tok-kt">long</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
<span class="tok-n">xml_text</span><span class="tok-o">&amp;</span> <span class="tok-n">xml_text</span><span class="tok-o">::</span><span class="tok-k">operator</span><span class="tok-o">=</span><span class="tok-p">(</span><span class="tok-kt">unsigned</span> <span class="tok-kt">long</span> <span class="tok-kt">long</span> <span class="tok-n">rhs</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>These operators simply call the right <code>set</code> function and return the attribute they&#8217;re called on; the return value of <code>set</code> is ignored, so errors are ignored.</p>
</div>
<div class="paragraph">
<p>This is an example of using <code>xml_text</code> object to modify text contents (<a href="samples/text.cpp" class="bare">samples/text.cpp</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-c1">// change project version</span>
<span class="tok-n">project</span><span class="tok-p">.</span><span class="tok-n">child</span><span class="tok-p">(</span><span class="tok-s">&quot;version&quot;</span><span class="tok-p">).</span><span class="tok-n">text</span><span class="tok-p">()</span> <span class="tok-o">=</span> <span class="tok-mf">1.2</span><span class="tok-p">;</span>

<span class="tok-c1">// add description element and set the contents</span>
<span class="tok-c1">// note that we do not have to explicitly add the node_pcdata child</span>
<span class="tok-n">project</span><span class="tok-p">.</span><span class="tok-n">append_child</span><span class="tok-p">(</span><span class="tok-s">&quot;description&quot;</span><span class="tok-p">).</span><span class="tok-n">text</span><span class="tok-p">().</span><span class="tok-n">set</span><span class="tok-p">(</span><span class="tok-s">&quot;a test project&quot;</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="modify.clone"><a class="anchor" href="#modify.clone"></a>6.6. Cloning nodes/attributes</h3>
<div class="paragraph">
<p><a id="xml_node::prepend_copy"></a><a id="xml_node::append_copy"></a><a id="xml_node::insert_copy_after"></a><a id="xml_node::insert_copy_before"></a>
With the help of previously described functions, it is possible to create trees with any contents and structure, including cloning the existing data. However since this is an often needed operation, pugixml provides built-in node/attribute cloning facilities. Since nodes and attributes do not exist without a document tree, you can&#8217;t create a standalone copy - you have to immediately insert it somewhere in the tree. For this, you can use one of the following functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-n">xml_attribute</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">append_copy</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xml_attribute</span><span class="tok-o">&amp;</span> <span class="tok-n">proto</span><span class="tok-p">);</span>
<span class="tok-n">xml_attribute</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">prepend_copy</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xml_attribute</span><span class="tok-o">&amp;</span> <span class="tok-n">proto</span><span class="tok-p">);</span>
<span class="tok-n">xml_attribute</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">insert_copy_after</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xml_attribute</span><span class="tok-o">&amp;</span> <span class="tok-n">proto</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-n">xml_attribute</span><span class="tok-o">&amp;</span> <span class="tok-n">attr</span><span class="tok-p">);</span>
<span class="tok-n">xml_attribute</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">insert_copy_before</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xml_attribute</span><span class="tok-o">&amp;</span> <span class="tok-n">proto</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-n">xml_attribute</span><span class="tok-o">&amp;</span> <span class="tok-n">attr</span><span class="tok-p">);</span>

<span class="tok-n">xml_node</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">append_copy</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xml_node</span><span class="tok-o">&amp;</span> <span class="tok-n">proto</span><span class="tok-p">);</span>
<span class="tok-n">xml_node</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">prepend_copy</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xml_node</span><span class="tok-o">&amp;</span> <span class="tok-n">proto</span><span class="tok-p">);</span>
<span class="tok-n">xml_node</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">insert_copy_after</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xml_node</span><span class="tok-o">&amp;</span> <span class="tok-n">proto</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-n">xml_node</span><span class="tok-o">&amp;</span> <span class="tok-n">node</span><span class="tok-p">);</span>
<span class="tok-n">xml_node</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">insert_copy_before</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xml_node</span><span class="tok-o">&amp;</span> <span class="tok-n">proto</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-n">xml_node</span><span class="tok-o">&amp;</span> <span class="tok-n">node</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>These functions mirror the structure of <code>append_child</code>, <code>prepend_child</code>, <code>insert_child_before</code> and related functions - they take the handle to the prototype object, which is to be cloned, insert a new attribute/node at the appropriate place, and then copy the attribute data or the whole node subtree to the new object. The functions return the handle to the resulting duplicate object, or null handle on failure.</p>
</div>
<div class="paragraph">
<p>The attribute is copied along with the name and value; the node is copied along with its type, name and value; additionally attribute list and all children are recursively cloned, resulting in the deep subtree clone. The prototype object can be a part of the same document, or a part of any other document.</p>
</div>
<div class="paragraph">
<p>The failure conditions resemble those of <code>append_child</code>, <code>insert_child_before</code> and related functions, <a href="#xml_node::append_child">consult their documentation for more information</a>. There are additional caveats specific to cloning functions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Cloning null handles results in operation failure;</p>
</li>
<li>
<p>Node cloning starts with insertion of the node of the same type as that of the prototype; for this reason, cloning functions can not be directly used to clone entire documents, since <a href="#node_document">node_document</a> is not a valid insertion type. The example below provides a workaround.</p>
</li>
<li>
<p>It is possible to copy a subtree as a child of some node inside this subtree, i.e. <code>node.append_copy(node.parent().parent());</code>. This is a valid operation, and it results in a clone of the subtree in the state before cloning started, i.e. no infinite recursion takes place.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This is an example with one possible implementation of include tags in XML (<a href="samples/include.cpp" class="bare">samples/include.cpp</a>). It illustrates node cloning and usage of other document modification functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-kt">bool</span> <span class="tok-nf">load_preprocess</span><span class="tok-p">(</span><span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xml_document</span><span class="tok-o">&amp;</span> <span class="tok-n">doc</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-kt">char</span><span class="tok-o">*</span> <span class="tok-n">path</span><span class="tok-p">);</span>

<span class="tok-kt">bool</span> <span class="tok-nf">preprocess</span><span class="tok-p">(</span><span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xml_node</span> <span class="tok-n">node</span><span class="tok-p">)</span>
<span class="tok-p">{</span>
    <span class="tok-k">for</span> <span class="tok-p">(</span><span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xml_node</span> <span class="tok-n">child</span> <span class="tok-o">=</span> <span class="tok-n">node</span><span class="tok-p">.</span><span class="tok-n">first_child</span><span class="tok-p">();</span> <span class="tok-n">child</span><span class="tok-p">;</span> <span class="tok-p">)</span>
    <span class="tok-p">{</span>
        <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">child</span><span class="tok-p">.</span><span class="tok-n">type</span><span class="tok-p">()</span> <span class="tok-o">==</span> <span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">node_pi</span> <span class="tok-o">&amp;&amp;</span> <span class="tok-n">strcmp</span><span class="tok-p">(</span><span class="tok-n">child</span><span class="tok-p">.</span><span class="tok-n">name</span><span class="tok-p">(),</span> <span class="tok-s">&quot;include&quot;</span><span class="tok-p">)</span> <span class="tok-o">==</span> <span class="tok-mi">0</span><span class="tok-p">)</span>
        <span class="tok-p">{</span>
            <span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xml_node</span> <span class="tok-n">include</span> <span class="tok-o">=</span> <span class="tok-n">child</span><span class="tok-p">;</span>

            <span class="tok-c1">// load new preprocessed document (note: ideally this should handle relative paths)</span>
            <span class="tok-k">const</span> <span class="tok-kt">char</span><span class="tok-o">*</span> <span class="tok-n">path</span> <span class="tok-o">=</span> <span class="tok-n">include</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-p">();</span>

            <span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xml_document</span> <span class="tok-n">doc</span><span class="tok-p">;</span>
            <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-o">!</span><span class="tok-n">load_preprocess</span><span class="tok-p">(</span><span class="tok-n">doc</span><span class="tok-p">,</span> <span class="tok-n">path</span><span class="tok-p">))</span> <span class="tok-k">return</span> <span class="tok-nb">false</span><span class="tok-p">;</span>

            <span class="tok-c1">// insert the comment marker above include directive</span>
            <span class="tok-n">node</span><span class="tok-p">.</span><span class="tok-n">insert_child_before</span><span class="tok-p">(</span><span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">node_comment</span><span class="tok-p">,</span> <span class="tok-n">include</span><span class="tok-p">).</span><span class="tok-n">set_value</span><span class="tok-p">(</span><span class="tok-n">path</span><span class="tok-p">);</span>

            <span class="tok-c1">// copy the document above the include directive (this retains the original order!)</span>
            <span class="tok-k">for</span> <span class="tok-p">(</span><span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xml_node</span> <span class="tok-n">ic</span> <span class="tok-o">=</span> <span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">first_child</span><span class="tok-p">();</span> <span class="tok-n">ic</span><span class="tok-p">;</span> <span class="tok-n">ic</span> <span class="tok-o">=</span> <span class="tok-n">ic</span><span class="tok-p">.</span><span class="tok-n">next_sibling</span><span class="tok-p">())</span>
            <span class="tok-p">{</span>
                <span class="tok-n">node</span><span class="tok-p">.</span><span class="tok-n">insert_copy_before</span><span class="tok-p">(</span><span class="tok-n">ic</span><span class="tok-p">,</span> <span class="tok-n">include</span><span class="tok-p">);</span>
            <span class="tok-p">}</span>

            <span class="tok-c1">// remove the include node and move to the next child</span>
            <span class="tok-n">child</span> <span class="tok-o">=</span> <span class="tok-n">child</span><span class="tok-p">.</span><span class="tok-n">next_sibling</span><span class="tok-p">();</span>

            <span class="tok-n">node</span><span class="tok-p">.</span><span class="tok-n">remove_child</span><span class="tok-p">(</span><span class="tok-n">include</span><span class="tok-p">);</span>
        <span class="tok-p">}</span>
        <span class="tok-k">else</span>
        <span class="tok-p">{</span>
            <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-o">!</span><span class="tok-n">preprocess</span><span class="tok-p">(</span><span class="tok-n">child</span><span class="tok-p">))</span> <span class="tok-k">return</span> <span class="tok-nb">false</span><span class="tok-p">;</span>

            <span class="tok-n">child</span> <span class="tok-o">=</span> <span class="tok-n">child</span><span class="tok-p">.</span><span class="tok-n">next_sibling</span><span class="tok-p">();</span>
        <span class="tok-p">}</span>
    <span class="tok-p">}</span>

    <span class="tok-k">return</span> <span class="tok-nb">true</span><span class="tok-p">;</span>
<span class="tok-p">}</span>

<span class="tok-kt">bool</span> <span class="tok-nf">load_preprocess</span><span class="tok-p">(</span><span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xml_document</span><span class="tok-o">&amp;</span> <span class="tok-n">doc</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-kt">char</span><span class="tok-o">*</span> <span class="tok-n">path</span><span class="tok-p">)</span>
<span class="tok-p">{</span>
    <span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xml_parse_result</span> <span class="tok-n">result</span> <span class="tok-o">=</span> <span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">load_file</span><span class="tok-p">(</span><span class="tok-n">path</span><span class="tok-p">,</span> <span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">parse_default</span> <span class="tok-o">|</span> <span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">parse_pi</span><span class="tok-p">);</span> <span class="tok-c1">// for &lt;?include?&gt;</span>

    <span class="tok-k">return</span> <span class="tok-n">result</span> <span class="tok-o">?</span> <span class="tok-n">preprocess</span><span class="tok-p">(</span><span class="tok-n">doc</span><span class="tok-p">)</span> <span class="tok-o">:</span> <span class="tok-nb">false</span><span class="tok-p">;</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="modify.move"><a class="anchor" href="#modify.move"></a>6.7. Moving nodes</h3>
<div class="paragraph">
<p><a id="xml_node::prepend_move"></a><a id="xml_node::append_move"></a><a id="xml_node::insert_move_after"></a><a id="xml_node::insert_move_before"></a>
Sometimes instead of cloning a node you need to move an existing node to a different position in a tree. This can be accomplished by copying the node and removing the original; however, this is expensive since it results in a lot of extra operations. For moving nodes within the same document tree, you can use of the following functions instead:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-n">xml_node</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">append_move</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xml_node</span><span class="tok-o">&amp;</span> <span class="tok-n">moved</span><span class="tok-p">);</span>
<span class="tok-n">xml_node</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">prepend_move</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xml_node</span><span class="tok-o">&amp;</span> <span class="tok-n">moved</span><span class="tok-p">);</span>
<span class="tok-n">xml_node</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">insert_move_after</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xml_node</span><span class="tok-o">&amp;</span> <span class="tok-n">moved</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-n">xml_node</span><span class="tok-o">&amp;</span> <span class="tok-n">node</span><span class="tok-p">);</span>
<span class="tok-n">xml_node</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">insert_move_before</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xml_node</span><span class="tok-o">&amp;</span> <span class="tok-n">moved</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-n">xml_node</span><span class="tok-o">&amp;</span> <span class="tok-n">node</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>These functions mirror the structure of <code>append_copy</code>, <code>prepend_copy</code>, <code>insert_copy_before</code> and <code>insert_copy_after</code> - they take the handle to the moved object and move it to the appropriate place with all attributes and/or child nodes. The functions return the handle to the resulting object (which is the same as the moved object), or null handle on failure.</p>
</div>
<div class="paragraph">
<p>The failure conditions resemble those of <code>append_child</code>, <code>insert_child_before</code> and related functions, <a href="#xml_node::append_child">consult their documentation for more information</a>. There are additional caveats specific to moving functions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Moving null handles results in operation failure;</p>
</li>
<li>
<p>Moving is only possible for nodes that belong to the same document; attempting to move nodes between documents will fail.</p>
</li>
<li>
<p><code>insert_move_after</code> and <code>insert_move_before</code> functions fail if the moved node is the same as the <code>node</code> argument (this operation would be a no-op otherwise).</p>
</li>
<li>
<p>It is impossible to move a subtree to a child of some node inside this subtree, i.e. <code>node.append_move(node.parent().parent());</code> will fail.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="modify.fragments"><a class="anchor" href="#modify.fragments"></a>6.8. Assembling document from fragments</h3>
<div id="xml_node::append_buffer" class="paragraph">
<p>pugixml provides several ways to assemble an XML document from other XML documents. Assuming there is a set of document fragments, represented as in-memory buffers, the implementation choices are as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Use a temporary document to parse the data from a string, then clone the nodes to a destination node. For example:</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-kt">bool</span> <span class="tok-nf">append_fragment</span><span class="tok-p">(</span><span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xml_node</span> <span class="tok-n">target</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-kt">char</span><span class="tok-o">*</span> <span class="tok-n">buffer</span><span class="tok-p">,</span> <span class="tok-kt">size_t</span> <span class="tok-n">size</span><span class="tok-p">)</span>
<span class="tok-p">{</span>
    <span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xml_document</span> <span class="tok-n">doc</span><span class="tok-p">;</span>
    <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-o">!</span><span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">load_buffer</span><span class="tok-p">(</span><span class="tok-n">buffer</span><span class="tok-p">,</span> <span class="tok-n">size</span><span class="tok-p">))</span> <span class="tok-k">return</span> <span class="tok-nb">false</span><span class="tok-p">;</span>

    <span class="tok-k">for</span> <span class="tok-p">(</span><span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xml_node</span> <span class="tok-n">child</span> <span class="tok-o">=</span> <span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">first_child</span><span class="tok-p">();</span> <span class="tok-n">child</span><span class="tok-p">;</span> <span class="tok-n">child</span> <span class="tok-o">=</span> <span class="tok-n">child</span><span class="tok-p">.</span><span class="tok-n">next_sibling</span><span class="tok-p">())</span>
        <span class="tok-n">target</span><span class="tok-p">.</span><span class="tok-n">append_copy</span><span class="tok-p">(</span><span class="tok-n">child</span><span class="tok-p">);</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>Cache the parsing step - instead of keeping in-memory buffers, keep document objects that already contain the parsed fragment:</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-kt">bool</span> <span class="tok-nf">append_fragment</span><span class="tok-p">(</span><span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xml_node</span> <span class="tok-n">target</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xml_document</span><span class="tok-o">&amp;</span> <span class="tok-n">cached_fragment</span><span class="tok-p">)</span>
<span class="tok-p">{</span>
    <span class="tok-k">for</span> <span class="tok-p">(</span><span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xml_node</span> <span class="tok-n">child</span> <span class="tok-o">=</span> <span class="tok-n">cached_fragment</span><span class="tok-p">.</span><span class="tok-n">first_child</span><span class="tok-p">();</span> <span class="tok-n">child</span><span class="tok-p">;</span> <span class="tok-n">child</span> <span class="tok-o">=</span> <span class="tok-n">child</span><span class="tok-p">.</span><span class="tok-n">next_sibling</span><span class="tok-p">())</span>
        <span class="tok-n">target</span><span class="tok-p">.</span><span class="tok-n">append_copy</span><span class="tok-p">(</span><span class="tok-n">child</span><span class="tok-p">);</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>Use <code>xml_node::append_buffer</code> directly:</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-n">xml_parse_result</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">append_buffer</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">void</span><span class="tok-o">*</span> <span class="tok-n">contents</span><span class="tok-p">,</span> <span class="tok-kt">size_t</span> <span class="tok-n">size</span><span class="tok-p">,</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">options</span> <span class="tok-o">=</span> <span class="tok-n">parse_default</span><span class="tok-p">,</span> <span class="tok-n">xml_encoding</span> <span class="tok-n">encoding</span> <span class="tok-o">=</span> <span class="tok-n">encoding_auto</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>The first method is more convenient, but slower than the other two. The relative performance of <code>append_copy</code> and <code>append_buffer</code> depends on the buffer format - usually <code>append_buffer</code> is faster if the buffer is in native encoding (UTF-8 or wchar_t, depending on <code>PUGIXML_WCHAR_MODE</code>). At the same time it might be less efficient in terms of memory usage - the implementation makes a copy of the provided buffer, and the copy has the same lifetime as the document - the memory used by that copy will be reclaimed after the document is destroyed, but no sooner. Even deleting all nodes in the document, including the appended ones, won&#8217;t reclaim the memory.</p>
</div>
<div class="paragraph">
<p><code>append_buffer</code> behaves in the same way as <a href="#xml_document::load_buffer">xml_document::load_buffer</a> - the input buffer is a byte buffer, with size in bytes; the buffer is not modified and can be freed after the function returns.</p>
</div>
<div id="status_append_invalid_root" class="paragraph">
<p>Since <code>append_buffer</code> needs to append child nodes to the current node, it only works if the current node is either document or element node. Calling <code>append_buffer</code> on a node with any other type results in an error with <code>status_append_invalid_root</code> status.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="saving"><a class="anchor" href="#saving"></a>7. Saving document</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Often after creating a new document or loading the existing one and processing it, it is necessary to save the result back to file. Also it is occasionally useful to output the whole document or a subtree to some stream; use cases include debug printing, serialization via network or other text-oriented medium, etc. pugixml provides several functions to output any subtree of the document to a file, stream or another generic transport interface; these functions allow to customize the output format (see <a href="#saving.options">Output options</a>), and also perform necessary encoding conversions (see <a href="#saving.encoding">Encodings</a>). This section documents the relevant functionality.</p>
</div>
<div class="paragraph">
<p>Before writing to the destination the node/attribute data is properly formatted according to the node type; all special XML symbols, such as <code>&lt;</code> and <code>&amp;</code>, are properly escaped (unless <a href="#format_no_escapes">format_no_escapes</a> flag is set). In order to guard against forgotten node/attribute names, empty node/attribute names are printed as <code>":anonymous"</code>. For well-formed output, make sure all node and attribute names are set to meaningful values.</p>
</div>
<div class="paragraph">
<p>CDATA sections with values that contain <code>"]]&gt;"</code> are split into several sections as follows: section with value <code>"pre]]&gt;post"</code> is written as <code>&lt;![CDATA[pre]]]]&gt;&lt;![CDATA[&gt;post]]&gt;</code>. While this alters the structure of the document (if you load the document after saving it, there will be two CDATA sections instead of one), this is the only way to escape CDATA contents.</p>
</div>
<div class="sect2">
<h3 id="saving.file"><a class="anchor" href="#saving.file"></a>7.1. Saving document to a file</h3>
<div class="paragraph">
<p><a id="xml_document::save_file"></a><a id="xml_document::save_file_wide"></a>
If you want to save the whole document to a file, you can use one of the following functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-kt">bool</span> <span class="tok-n">xml_document</span><span class="tok-o">::</span><span class="tok-n">save_file</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char</span><span class="tok-o">*</span> <span class="tok-n">path</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">indent</span> <span class="tok-o">=</span> <span class="tok-s">&quot;</span><span class="tok-se">\t</span><span class="tok-s">&quot;</span><span class="tok-p">,</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">flags</span> <span class="tok-o">=</span> <span class="tok-n">format_default</span><span class="tok-p">,</span> <span class="tok-n">xml_encoding</span> <span class="tok-n">encoding</span> <span class="tok-o">=</span> <span class="tok-n">encoding_auto</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-kt">bool</span> <span class="tok-n">xml_document</span><span class="tok-o">::</span><span class="tok-n">save_file</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">wchar_t</span><span class="tok-o">*</span> <span class="tok-n">path</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">indent</span> <span class="tok-o">=</span> <span class="tok-s">&quot;</span><span class="tok-se">\t</span><span class="tok-s">&quot;</span><span class="tok-p">,</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">flags</span> <span class="tok-o">=</span> <span class="tok-n">format_default</span><span class="tok-p">,</span> <span class="tok-n">xml_encoding</span> <span class="tok-n">encoding</span> <span class="tok-o">=</span> <span class="tok-n">encoding_auto</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>These functions accept file path as its first argument, and also three optional arguments, which specify indentation and other output options (see <a href="#saving.options">Output options</a>) and output data encoding (see <a href="#saving.encoding">Encodings</a>). The path has the target operating system format, so it can be a relative or absolute one, it should have the delimiters of the target system, it should have the exact case if the target file system is case-sensitive, etc.</p>
</div>
<div class="paragraph">
<p>File path is passed to the system file opening function as is in case of the first function (which accepts <code>const char* path</code>); the second function either uses a special file opening function if it is provided by the runtime library or converts the path to UTF-8 and uses the system file opening function.</p>
</div>
<div id="xml_writer_file" class="paragraph">
<p><code>save_file</code> opens the target file for writing, outputs the requested header (by default a document declaration is output, unless the document already has one), and then saves the document contents. If the file could not be opened, the function returns <code>false</code>. Calling <code>save_file</code> is equivalent to creating an <code>xml_writer_file</code> object with <code>FILE*</code> handle as the only constructor argument and then calling <code>save</code>; see <a href="#saving.writer">Saving document via writer interface</a> for writer interface details.</p>
</div>
<div class="paragraph">
<p>This is a simple example of saving XML document to file (<a href="samples/save_file.cpp" class="bare">samples/save_file.cpp</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-c1">// save document to file</span>
<span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;Saving result: &quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">save_file</span><span class="tok-p">(</span><span class="tok-s">&quot;save_file_output.xml&quot;</span><span class="tok-p">)</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">endl</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="saving.stream"><a class="anchor" href="#saving.stream"></a>7.2. Saving document to C&#43;&#43; IOstreams</h3>
<div id="xml_document::save_stream" class="paragraph">
<p>To enhance interoperability pugixml provides functions for saving document to any object which implements C&#43;&#43; <code>std::ostream</code> interface. This allows you to save documents to any standard C&#43;&#43; stream (i.e. file stream) or any third-party compliant implementation (i.e. Boost Iostreams). Most notably, this allows for easy debug output, since you can use <code>std::cout</code> stream as saving target. There are two functions, one works with narrow character streams, another handles wide character ones:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-kt">void</span> <span class="tok-n">xml_document</span><span class="tok-o">::</span><span class="tok-n">save</span><span class="tok-p">(</span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">ostream</span><span class="tok-o">&amp;</span> <span class="tok-n">stream</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">indent</span> <span class="tok-o">=</span> <span class="tok-s">&quot;</span><span class="tok-se">\t</span><span class="tok-s">&quot;</span><span class="tok-p">,</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">flags</span> <span class="tok-o">=</span> <span class="tok-n">format_default</span><span class="tok-p">,</span> <span class="tok-n">xml_encoding</span> <span class="tok-n">encoding</span> <span class="tok-o">=</span> <span class="tok-n">encoding_auto</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-kt">void</span> <span class="tok-n">xml_document</span><span class="tok-o">::</span><span class="tok-n">save</span><span class="tok-p">(</span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">wostream</span><span class="tok-o">&amp;</span> <span class="tok-n">stream</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">indent</span> <span class="tok-o">=</span> <span class="tok-s">&quot;</span><span class="tok-se">\t</span><span class="tok-s">&quot;</span><span class="tok-p">,</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">flags</span> <span class="tok-o">=</span> <span class="tok-n">format_default</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>save</code> with <code>std::ostream</code> argument saves the document to the stream in the same way as <code>save_file</code> (i.e. with requested header and with encoding conversions). On the other hand, <code>save</code> with <code>std::wstream</code> argument saves the document to the wide stream with <a href="#encoding_wchar">encoding_wchar</a> encoding.  Because of this, using <code>save</code> with wide character streams requires careful (usually platform-specific) stream setup (i.e. using the <code>imbue</code> function). Generally use of wide streams is discouraged, however it provides you with the ability to save documents to non-Unicode encodings, i.e. you can save Shift-JIS encoded data if you set the correct locale.</p>
</div>
<div id="xml_writer_stream" class="paragraph">
<p>Calling <code>save</code> with stream target is equivalent to creating an <code>xml_writer_stream</code> object with stream as the only constructor argument and then calling <code>save</code>; see <a href="#saving.writer">Saving document via writer interface</a> for writer interface details.</p>
</div>
<div class="paragraph">
<p>This is a simple example of saving XML document to standard output (<a href="samples/save_stream.cpp" class="bare">samples/save_stream.cpp</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-c1">// save document to standard output</span>
<span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;Document:</span><span class="tok-se">\n</span><span class="tok-s">&quot;</span><span class="tok-p">;</span>
<span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">save</span><span class="tok-p">(</span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="saving.writer"><a class="anchor" href="#saving.writer"></a>7.3. Saving document via writer interface</h3>
<div class="paragraph">
<p><a id="xml_document::save"></a><a id="xml_writer"></a><a id="xml_writer::write"></a>
All of the above saving functions are implemented in terms of writer interface. This is a simple interface with a single function, which is called several times during output process with chunks of document data as input:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-k">class</span> <span class="tok-nc">xml_writer</span>
<span class="tok-p">{</span>
<span class="tok-k">public</span><span class="tok-o">:</span>
    <span class="tok-k">virtual</span> <span class="tok-kt">void</span> <span class="tok-n">write</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">void</span><span class="tok-o">*</span> <span class="tok-n">data</span><span class="tok-p">,</span> <span class="tok-kt">size_t</span> <span class="tok-n">size</span><span class="tok-p">)</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">;</span>
<span class="tok-p">};</span>

<span class="tok-kt">void</span> <span class="tok-n">xml_document</span><span class="tok-o">::</span><span class="tok-n">save</span><span class="tok-p">(</span><span class="tok-n">xml_writer</span><span class="tok-o">&amp;</span> <span class="tok-n">writer</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">indent</span> <span class="tok-o">=</span> <span class="tok-s">&quot;</span><span class="tok-se">\t</span><span class="tok-s">&quot;</span><span class="tok-p">,</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">flags</span> <span class="tok-o">=</span> <span class="tok-n">format_default</span><span class="tok-p">,</span> <span class="tok-n">xml_encoding</span> <span class="tok-n">encoding</span> <span class="tok-o">=</span> <span class="tok-n">encoding_auto</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In order to output the document via some custom transport, for example sockets, you should create an object which implements <code>xml_writer</code> interface and pass it to <code>save</code> function. <code>xml_writer::write</code> function is called with a buffer as an input, where <code>data</code> points to buffer start, and <code>size</code> is equal to the buffer size in bytes. <code>write</code> implementation must write the buffer to the transport; it can not save the passed buffer pointer, as the buffer contents will change after <code>write</code> returns. The buffer contains the chunk of document data in the desired encoding.</p>
</div>
<div class="paragraph">
<p><code>write</code> function is called with relatively large blocks (size is usually several kilobytes, except for the last block that may be small), so there is often no need for additional buffering in the implementation.</p>
</div>
<div class="paragraph">
<p>This is a simple example of custom writer for saving document data to STL string (<a href="samples/save_custom_writer.cpp" class="bare">samples/save_custom_writer.cpp</a>); read the sample code for more complex examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-k">struct</span> <span class="tok-nl">xml_string_writer</span><span class="tok-p">:</span> <span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xml_writer</span>
<span class="tok-p">{</span>
    <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">string</span> <span class="tok-n">result</span><span class="tok-p">;</span>

    <span class="tok-k">virtual</span> <span class="tok-kt">void</span> <span class="tok-nf">write</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">void</span><span class="tok-o">*</span> <span class="tok-n">data</span><span class="tok-p">,</span> <span class="tok-kt">size_t</span> <span class="tok-n">size</span><span class="tok-p">)</span>
    <span class="tok-p">{</span>
        <span class="tok-n">result</span><span class="tok-p">.</span><span class="tok-n">append</span><span class="tok-p">(</span><span class="tok-k">static_cast</span><span class="tok-o">&lt;</span><span class="tok-k">const</span> <span class="tok-kt">char</span><span class="tok-o">*&gt;</span><span class="tok-p">(</span><span class="tok-n">data</span><span class="tok-p">),</span> <span class="tok-n">size</span><span class="tok-p">);</span>
    <span class="tok-p">}</span>
<span class="tok-p">};</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="saving.subtree"><a class="anchor" href="#saving.subtree"></a>7.4. Saving a single subtree</h3>
<div class="paragraph">
<p><a id="xml_node::print"></a><a id="xml_node::print_stream"></a>
While the previously described functions save the whole document to the destination, it is easy to save a single subtree. The following functions are provided:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-kt">void</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">print</span><span class="tok-p">(</span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">ostream</span><span class="tok-o">&amp;</span> <span class="tok-n">os</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">indent</span> <span class="tok-o">=</span> <span class="tok-s">&quot;</span><span class="tok-se">\t</span><span class="tok-s">&quot;</span><span class="tok-p">,</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">flags</span> <span class="tok-o">=</span> <span class="tok-n">format_default</span><span class="tok-p">,</span> <span class="tok-n">xml_encoding</span> <span class="tok-n">encoding</span> <span class="tok-o">=</span> <span class="tok-n">encoding_auto</span><span class="tok-p">,</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">depth</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-kt">void</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">print</span><span class="tok-p">(</span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">wostream</span><span class="tok-o">&amp;</span> <span class="tok-n">os</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">indent</span> <span class="tok-o">=</span> <span class="tok-s">&quot;</span><span class="tok-se">\t</span><span class="tok-s">&quot;</span><span class="tok-p">,</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">flags</span> <span class="tok-o">=</span> <span class="tok-n">format_default</span><span class="tok-p">,</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">depth</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-kt">void</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">print</span><span class="tok-p">(</span><span class="tok-n">xml_writer</span><span class="tok-o">&amp;</span> <span class="tok-n">writer</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">indent</span> <span class="tok-o">=</span> <span class="tok-s">&quot;</span><span class="tok-se">\t</span><span class="tok-s">&quot;</span><span class="tok-p">,</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">flags</span> <span class="tok-o">=</span> <span class="tok-n">format_default</span><span class="tok-p">,</span> <span class="tok-n">xml_encoding</span> <span class="tok-n">encoding</span> <span class="tok-o">=</span> <span class="tok-n">encoding_auto</span><span class="tok-p">,</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">depth</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>These functions have the same arguments with the same meaning as the corresponding <code>xml_document::save</code> functions, and allow you to save the subtree to either a C&#43;&#43; IOstream or to any object that implements <code>xml_writer</code> interface.</p>
</div>
<div class="paragraph">
<p>Saving a subtree differs from saving the whole document: the process behaves as if <a href="#format_write_bom">format_write_bom</a> is off, and <a href="#format_no_declaration">format_no_declaration</a> is on, even if actual values of the flags are different. This means that BOM is not written to the destination, and document declaration is only written if it is the node itself or is one of node&#8217;s children. Note that this also holds if you&#8217;re saving a document; this example (<a href="samples/save_subtree.cpp" class="bare">samples/save_subtree.cpp</a>) illustrates the difference:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-c1">// get a test document</span>
<span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xml_document</span> <span class="tok-n">doc</span><span class="tok-p">;</span>
<span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">load_string</span><span class="tok-p">(</span><span class="tok-s">&quot;&lt;foo bar=&#39;baz&#39;&gt;&lt;call&gt;hey&lt;/call&gt;&lt;/foo&gt;&quot;</span><span class="tok-p">);</span>

<span class="tok-c1">// print document to standard output (prints &lt;?xml version=&quot;1.0&quot;?&gt;&lt;foo bar=&quot;baz&quot;&gt;&lt;call&gt;hey&lt;/call&gt;&lt;/foo&gt;)</span>
<span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">save</span><span class="tok-p">(</span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span><span class="tok-p">,</span> <span class="tok-s">&quot;&quot;</span><span class="tok-p">,</span> <span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">format_raw</span><span class="tok-p">);</span>
<span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">endl</span><span class="tok-p">;</span>

<span class="tok-c1">// print document to standard output as a regular node (prints &lt;foo bar=&quot;baz&quot;&gt;&lt;call&gt;hey&lt;/call&gt;&lt;/foo&gt;)</span>
<span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">print</span><span class="tok-p">(</span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span><span class="tok-p">,</span> <span class="tok-s">&quot;&quot;</span><span class="tok-p">,</span> <span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">format_raw</span><span class="tok-p">);</span>
<span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">endl</span><span class="tok-p">;</span>

<span class="tok-c1">// print a subtree to standard output (prints &lt;call&gt;hey&lt;/call&gt;)</span>
<span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">child</span><span class="tok-p">(</span><span class="tok-s">&quot;foo&quot;</span><span class="tok-p">).</span><span class="tok-n">child</span><span class="tok-p">(</span><span class="tok-s">&quot;call&quot;</span><span class="tok-p">).</span><span class="tok-n">print</span><span class="tok-p">(</span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span><span class="tok-p">,</span> <span class="tok-s">&quot;&quot;</span><span class="tok-p">,</span> <span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">format_raw</span><span class="tok-p">);</span>
<span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">endl</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="saving.options"><a class="anchor" href="#saving.options"></a>7.5. Output options</h3>
<div class="paragraph">
<p>All saving functions accept the optional parameter <code>flags</code>. This is a bitmask that customizes the output format; you can select the way the document nodes are printed and select the needed additional information that is output before the document contents.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
You should use the usual bitwise arithmetics to manipulate the bitmask: to enable a flag, use <code>mask | flag</code>; to disable a flag, use <code>mask &amp; ~flag</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>These flags control the resulting tree contents:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a id="format_indent"></a><code>format_indent</code> determines if all nodes should be indented with the indentation string (this is an additional parameter for all saving functions, and is <code>"\t"</code> by default). If this flag is on, the indentation string is printed several times before every node, where the amount of indentation depends on the node&#8217;s depth relative to the output subtree. This flag has no effect if <a href="#format_raw">format_raw</a> is enabled. This flag is <strong>on</strong> by default.</p>
</li>
<li>
<p><a id="format_indent_attributes"></a><code>format_indent_attributes</code> determines if all attributes should be printed on a new line, indented with the indentation string according to the attribute&#8217;s depth. This flag implies <a href="#format_indent">format_indent</a>. This flag has no effect if <a href="#format_raw">format_raw</a> is enabled. This flag is <strong>off</strong> by default.</p>
</li>
<li>
<p><a id="format_raw"></a><code>format_raw</code> switches between formatted and raw output. If this flag is on, the nodes are not indented in any way, and also no newlines that are not part of document text are printed. Raw mode can be used for serialization where the result is not intended to be read by humans; also it can be useful if the document was parsed with <a href="#parse_ws_pcdata">parse_ws_pcdata</a> flag, to preserve the original document formatting as much as possible. This flag is <strong>off</strong> by default.</p>
</li>
<li>
<p><a id="format_no_escapes"></a><code>format_no_escapes</code> disables output escaping for attribute values and PCDATA contents. If this flag is off, special symbols (<code>"</code>, <code>&amp;</code>, <code>&lt;</code>, <code>&gt;</code>) and all non-printable characters (those with codepoint values less than 32) are converted to XML escape sequences (i.e. <code>&amp;amp;</code>) during output. If this flag is on, no text processing is performed; therefore, output XML can be malformed if output contents contains invalid symbols (i.e. having a stray <code>&lt;</code> in the PCDATA will make the output malformed). This flag is <strong>off</strong> by default.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These flags control the additional output information:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a id="format_no_declaration"></a><code>format_no_declaration</code> disables default node declaration output. By default, if the document is saved via <code>save</code> or <code>save_file</code> function, and it does not have any document declaration, a default declaration is output before the document contents. Enabling this flag disables this declaration. This flag has no effect in <code>xml_node::print</code> functions: they never output the default declaration. This flag is <strong>off</strong> by default.</p>
</li>
<li>
<p><a id="format_write_bom"></a><code>format_write_bom</code> enables Byte Order Mark (BOM) output. By default, no BOM is output, so in case of non UTF-8 encodings the resulting document&#8217;s encoding may not be recognized by some parsers and text editors, if they do not implement sophisticated encoding detection. Enabling this flag adds an encoding-specific BOM to the output. This flag has no effect in <code>xml_node::print</code> functions: they never output the BOM. This flag is <strong>off</strong> by default.</p>
</li>
<li>
<p><a id="format_save_file_text"></a><code>format_save_file_text</code> changes the file mode when using <code>save_file</code> function. By default, file is opened in binary mode, which means that the output file will
contain platform-independent newline <code>\n</code> (ASCII 10). If this flag is on, file is opened in text mode, which on some systems changes the newline format (i.e. on Windows you can use this flag to output XML documents with <code>\r\n</code> (ASCII 13 10) newlines. This flag is <strong>off</strong> by default.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Additionally, there is one predefined option mask:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a id="format_default"></a><code>format_default</code> is the default set of flags, i.e. it has all options set to their default values. It sets formatted output with indentation, without BOM and with default node declaration, if necessary.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This is an example that shows the outputs of different output options (<a href="samples/save_options.cpp" class="bare">samples/save_options.cpp</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-c1">// get a test document</span>
<span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xml_document</span> <span class="tok-n">doc</span><span class="tok-p">;</span>
<span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">load_string</span><span class="tok-p">(</span><span class="tok-s">&quot;&lt;foo bar=&#39;baz&#39;&gt;&lt;call&gt;hey&lt;/call&gt;&lt;/foo&gt;&quot;</span><span class="tok-p">);</span>

<span class="tok-c1">// default options; prints</span>
<span class="tok-c1">// &lt;?xml version=&quot;1.0&quot;?&gt;</span>
<span class="tok-c1">// &lt;foo bar=&quot;baz&quot;&gt;</span>
<span class="tok-c1">//         &lt;call&gt;hey&lt;/call&gt;</span>
<span class="tok-c1">// &lt;/foo&gt;</span>
<span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">save</span><span class="tok-p">(</span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span><span class="tok-p">);</span>
<span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">endl</span><span class="tok-p">;</span>

<span class="tok-c1">// default options with custom indentation string; prints</span>
<span class="tok-c1">// &lt;?xml version=&quot;1.0&quot;?&gt;</span>
<span class="tok-c1">// &lt;foo bar=&quot;baz&quot;&gt;</span>
<span class="tok-c1">// --&lt;call&gt;hey&lt;/call&gt;</span>
<span class="tok-c1">// &lt;/foo&gt;</span>
<span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">save</span><span class="tok-p">(</span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span><span class="tok-p">,</span> <span class="tok-s">&quot;--&quot;</span><span class="tok-p">);</span>
<span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">endl</span><span class="tok-p">;</span>

<span class="tok-c1">// default options without indentation; prints</span>
<span class="tok-c1">// &lt;?xml version=&quot;1.0&quot;?&gt;</span>
<span class="tok-c1">// &lt;foo bar=&quot;baz&quot;&gt;</span>
<span class="tok-c1">// &lt;call&gt;hey&lt;/call&gt;</span>
<span class="tok-c1">// &lt;/foo&gt;</span>
<span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">save</span><span class="tok-p">(</span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span><span class="tok-p">,</span> <span class="tok-s">&quot;</span><span class="tok-se">\t</span><span class="tok-s">&quot;</span><span class="tok-p">,</span> <span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">format_default</span> <span class="tok-o">&amp;</span> <span class="tok-o">~</span><span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">format_indent</span><span class="tok-p">);</span> <span class="tok-c1">// can also pass &quot;&quot; instead of indentation string for the same effect</span>
<span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">endl</span><span class="tok-p">;</span>

<span class="tok-c1">// raw output; prints</span>
<span class="tok-c1">// &lt;?xml version=&quot;1.0&quot;?&gt;&lt;foo bar=&quot;baz&quot;&gt;&lt;call&gt;hey&lt;/call&gt;&lt;/foo&gt;</span>
<span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">save</span><span class="tok-p">(</span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span><span class="tok-p">,</span> <span class="tok-s">&quot;</span><span class="tok-se">\t</span><span class="tok-s">&quot;</span><span class="tok-p">,</span> <span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">format_raw</span><span class="tok-p">);</span>
<span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">endl</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">endl</span><span class="tok-p">;</span>

<span class="tok-c1">// raw output without declaration; prints</span>
<span class="tok-c1">// &lt;foo bar=&quot;baz&quot;&gt;&lt;call&gt;hey&lt;/call&gt;&lt;/foo&gt;</span>
<span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">save</span><span class="tok-p">(</span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span><span class="tok-p">,</span> <span class="tok-s">&quot;</span><span class="tok-se">\t</span><span class="tok-s">&quot;</span><span class="tok-p">,</span> <span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">format_raw</span> <span class="tok-o">|</span> <span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">format_no_declaration</span><span class="tok-p">);</span>
<span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">endl</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="saving.encoding"><a class="anchor" href="#saving.encoding"></a>7.6. Encodings</h3>
<div class="paragraph">
<p>pugixml supports all popular Unicode encodings (UTF-8, UTF-16 (big and little endian), UTF-32 (big and little endian); UCS-2 is naturally supported since it&#8217;s a strict subset of UTF-16) and handles all encoding conversions during output. The output encoding is set via the <code>encoding</code> parameter of saving functions, which is of type <code>xml_encoding</code>. The possible values for the encoding are documented in <a href="#loading.encoding">Encodings</a>; the only flag that has a different meaning is <code>encoding_auto</code>.</p>
</div>
<div class="paragraph">
<p>While all other flags set the exact encoding, <code>encoding_auto</code> is meant for automatic encoding detection. The automatic detection does not make sense for output encoding, since there is usually nothing to infer the actual encoding from, so here <code>encoding_auto</code> means UTF-8 encoding, which is the most popular encoding for XML data storage. This is also the default value of output encoding; specify another value if you do not want UTF-8 encoded output.</p>
</div>
<div class="paragraph">
<p>Also note that wide stream saving functions do not have <code>encoding</code> argument and always assume <a href="#encoding_wchar">encoding_wchar</a> encoding.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
The current behavior for Unicode conversion is to skip all invalid UTF sequences during conversion. This behavior should not be relied upon; if your node/attribute names do not contain any valid UTF sequences, they may be output as if they are empty, which will result in malformed XML document.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="saving.declaration"><a class="anchor" href="#saving.declaration"></a>7.7. Customizing document declaration</h3>
<div class="paragraph">
<p>When you are saving the document using <code>xml_document::save()</code> or <code>xml_document::save_file()</code>, a default XML document declaration is output, if <code>format_no_declaration</code> is not specified and if the document does not have a declaration node. However, the default declaration is not customizable. If you want to customize the declaration output, you need to create the declaration node yourself.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
By default the declaration node is not added to the document during parsing. If you just need to preserve the original declaration node, you have to add the flag <a href="#parse_declaration">parse_declaration</a> to the parsing flags; the resulting document will contain the original declaration node, which will be output during saving.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Declaration node is a node with type <a href="#node_declaration">node_declaration</a>; it behaves like an element node in that it has attributes with values (but it does not have child nodes). Therefore setting custom version, encoding or standalone declaration involves adding attributes and setting attribute values.</p>
</div>
<div class="paragraph">
<p>This is an example that shows how to create a custom declaration node (<a href="samples/save_declaration.cpp" class="bare">samples/save_declaration.cpp</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-c1">// get a test document</span>
<span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xml_document</span> <span class="tok-n">doc</span><span class="tok-p">;</span>
<span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">load_string</span><span class="tok-p">(</span><span class="tok-s">&quot;&lt;foo bar=&#39;baz&#39;&gt;&lt;call&gt;hey&lt;/call&gt;&lt;/foo&gt;&quot;</span><span class="tok-p">);</span>

<span class="tok-c1">// add a custom declaration node</span>
<span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xml_node</span> <span class="tok-n">decl</span> <span class="tok-o">=</span> <span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">prepend_child</span><span class="tok-p">(</span><span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">node_declaration</span><span class="tok-p">);</span>
<span class="tok-n">decl</span><span class="tok-p">.</span><span class="tok-n">append_attribute</span><span class="tok-p">(</span><span class="tok-s">&quot;version&quot;</span><span class="tok-p">)</span> <span class="tok-o">=</span> <span class="tok-s">&quot;1.0&quot;</span><span class="tok-p">;</span>
<span class="tok-n">decl</span><span class="tok-p">.</span><span class="tok-n">append_attribute</span><span class="tok-p">(</span><span class="tok-s">&quot;encoding&quot;</span><span class="tok-p">)</span> <span class="tok-o">=</span> <span class="tok-s">&quot;UTF-8&quot;</span><span class="tok-p">;</span>
<span class="tok-n">decl</span><span class="tok-p">.</span><span class="tok-n">append_attribute</span><span class="tok-p">(</span><span class="tok-s">&quot;standalone&quot;</span><span class="tok-p">)</span> <span class="tok-o">=</span> <span class="tok-s">&quot;no&quot;</span><span class="tok-p">;</span>

<span class="tok-c1">// &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;</span>
<span class="tok-c1">// &lt;foo bar=&quot;baz&quot;&gt;</span>
<span class="tok-c1">//         &lt;call&gt;hey&lt;/call&gt;</span>
<span class="tok-c1">// &lt;/foo&gt;</span>
<span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">save</span><span class="tok-p">(</span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span><span class="tok-p">);</span>
<span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">endl</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="xpath"><a class="anchor" href="#xpath"></a>8. XPath</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If the task at hand is to select a subset of document nodes that match some criteria, it is possible to code a function using the existing traversal functionality for any practical criteria. However, often either a data-driven approach is desirable, in case the criteria are not predefined and come from a file, or it is inconvenient to use traversal interfaces and a higher-level DSL is required. There is a standard language for XML processing, XPath, that can be useful for these cases. pugixml implements an almost complete subset of XPath 1.0. Because of differences in document object model and some performance implications, there are minor violations of the official specifications, which can be found in <a href="#xpath.w3c">Conformance to W3C specification</a>. The rest of this section describes the interface for XPath functionality. Please note that if you wish to learn to use XPath language, you have to look for other tutorials or manuals; for example, you can read <a href="http://www.w3schools.com/xpath/">W3Schools XPath tutorial</a>, <a href="http://www.tizag.com/xmlTutorial/xpathtutorial.php">XPath tutorial at tizag.com</a>, and <a href="http://www.w3.org/TR/xpath/">the XPath 1.0 specification</a>.</p>
</div>
<div class="sect2">
<h3 id="xpath.types"><a class="anchor" href="#xpath.types"></a>8.1. XPath types</h3>
<div class="paragraph">
<p><a id="xpath_value_type"></a><a id="xpath_type_number"></a><a id="xpath_type_string"></a><a id="xpath_type_boolean"></a><a id="xpath_type_node_set"></a><a id="xpath_type_none"></a>
Each XPath expression can have one of the following types: boolean, number, string or node set. Boolean type corresponds to <code>bool</code> type, number type corresponds to <code>double</code> type, string type corresponds to either <code>std::string</code> or <code>std::wstring</code>, depending on whether <a href="#dom.unicode">wide character interface is enabled</a>, and node set corresponds to <a href="#xpath_node_set">xpath_node_set</a> type. There is an enumeration, <code>xpath_value_type</code>, which can take the values <code>xpath_type_boolean</code>, <code>xpath_type_number</code>, <code>xpath_type_string</code> or <code>xpath_type_node_set</code>, accordingly.</p>
</div>
<div class="paragraph">
<p><a id="xpath_node"></a><a id="xpath_node::node"></a><a id="xpath_node::attribute"></a><a id="xpath_node::parent"></a>
Because an XPath node can be either a node or an attribute, there is a special type, <code>xpath_node</code>, which is a discriminated union of these types. A value of this type contains two node handles, one of <code>xml_node</code> type, and another one of <code>xml_attribute</code> type; at most one of them can be non-null. The accessors to get these handles are available:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-n">xml_node</span> <span class="tok-n">xpath_node</span><span class="tok-o">::</span><span class="tok-n">node</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-n">xml_attribute</span> <span class="tok-n">xpath_node</span><span class="tok-o">::</span><span class="tok-n">attribute</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>XPath nodes can be null, in which case both accessors return null handles.</p>
</div>
<div class="paragraph">
<p>Note that as per XPath specification, each XPath node has a parent, which can be retrieved via this function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-n">xml_node</span> <span class="tok-n">xpath_node</span><span class="tok-o">::</span><span class="tok-n">parent</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>parent</code> function returns the node&#8217;s parent if the XPath node corresponds to <code>xml_node</code> handle (equivalent to <code>node().parent()</code>), or the node to which the attribute belongs to, if the XPath node corresponds to <code>xml_attribute</code> handle. For null nodes, <code>parent</code> returns null handle.</p>
</div>
<div class="paragraph">
<p><a id="xpath_node::unspecified_bool_type"></a><a id="xpath_node::comparison"></a>
Like node and attribute handles, XPath node handles can be implicitly cast to boolean-like object to check if it is a null node, and also can be compared for equality with each other.</p>
</div>
<div id="xpath_node::ctor" class="paragraph">
<p>You can also create XPath nodes with one of the three constructors: the default constructor, the constructor that takes node argument, and the constructor that takes attribute and node arguments (in which case the attribute must belong to the attribute list of the node). The constructor from <code>xml_node</code> is implicit, so you can usually pass <code>xml_node</code> to functions that expect <code>xpath_node</code>. Apart from that you usually don&#8217;t need to create your own XPath node objects, since they are returned to you via selection functions.</p>
</div>
<div id="xpath_node_set" class="paragraph">
<p>XPath expressions operate not on single nodes, but instead on node sets. A node set is a collection of nodes, which can be optionally ordered in either a forward document order or a reverse one. Document order is defined in XPath specification; an XPath node is before another node in document order if it appears before it in XML representation of the corresponding document.</p>
</div>
<div class="paragraph">
<p><a id="xpath_node_set::const_iterator"></a><a id="xpath_node_set::begin"></a><a id="xpath_node_set::end"></a>
Node sets are represented by <code>xpath_node_set</code> object, which has an interface that resembles one of sequential random-access containers. It has an iterator type along with usual begin/past-the-end iterator accessors:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-k">typedef</span> <span class="tok-k">const</span> <span class="tok-n">xpath_node</span><span class="tok-o">*</span> <span class="tok-n">xpath_node_set</span><span class="tok-o">::</span><span class="tok-n">const_iterator</span><span class="tok-p">;</span>
<span class="tok-n">const_iterator</span> <span class="tok-n">xpath_node_set</span><span class="tok-o">::</span><span class="tok-n">begin</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-n">const_iterator</span> <span class="tok-n">xpath_node_set</span><span class="tok-o">::</span><span class="tok-n">end</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><a id="xpath_node_set::index"></a><a id="xpath_node_set::size"></a><a id="xpath_node_set::empty"></a>
And it also can be iterated via indices, just like <code>std::vector</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-k">const</span> <span class="tok-n">xpath_node</span><span class="tok-o">&amp;</span> <span class="tok-n">xpath_node_set</span><span class="tok-o">::</span><span class="tok-k">operator</span><span class="tok-p">[](</span><span class="tok-kt">size_t</span> <span class="tok-n">index</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-kt">size_t</span> <span class="tok-n">xpath_node_set</span><span class="tok-o">::</span><span class="tok-n">size</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-kt">bool</span> <span class="tok-n">xpath_node_set</span><span class="tok-o">::</span><span class="tok-n">empty</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>All of the above operations have the same semantics as that of <code>std::vector</code>: the iterators are random-access, all of the above operations are constant time, and accessing the element at index that is greater or equal than the set size results in undefined behavior. You can use both iterator-based and index-based access for iteration, however the iterator-based one can be faster.</p>
</div>
<div class="paragraph">
<p><a id="xpath_node_set::type"></a><a id="xpath_node_set::type_unsorted"></a><a id="xpath_node_set::type_sorted"></a><a id="xpath_node_set::type_sorted_reverse"></a><a id="xpath_node_set::sort"></a>
The order of iteration depends on the order of nodes inside the set; the order can be queried via the following function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-k">enum</span> <span class="tok-n">xpath_node_set</span><span class="tok-o">::</span><span class="tok-kt">type_t</span> <span class="tok-p">{</span><span class="tok-n">type_unsorted</span><span class="tok-p">,</span> <span class="tok-n">type_sorted</span><span class="tok-p">,</span> <span class="tok-n">type_sorted_reverse</span><span class="tok-p">};</span>
<span class="tok-kt">type_t</span> <span class="tok-n">xpath_node_set</span><span class="tok-o">::</span><span class="tok-n">type</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>type</code> function returns the current order of nodes; <code>type_sorted</code> means that the nodes are in forward document order, <code>type_sorted_reverse</code> means that the nodes are in reverse document order, and <code>type_unsorted</code> means that neither order is guaranteed (nodes can accidentally be in a sorted order even if <code>type()</code> returns <code>type_unsorted</code>). If you require a specific order of iteration, you can change it via <code>sort</code> function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-kt">void</span> <span class="tok-n">xpath_node_set</span><span class="tok-o">::</span><span class="tok-n">sort</span><span class="tok-p">(</span><span class="tok-kt">bool</span> <span class="tok-n">reverse</span> <span class="tok-o">=</span> <span class="tok-nb">false</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Calling <code>sort</code> sorts the nodes in either forward or reverse document order, depending on the argument; after this call <code>type()</code> will return <code>type_sorted</code> or <code>type_sorted_reverse</code>.</p>
</div>
<div id="xpath_node_set::first" class="paragraph">
<p>Often the actual iteration is not needed; instead, only the first element in document order is required. For this, a special accessor is provided:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-n">xpath_node</span> <span class="tok-n">xpath_node_set</span><span class="tok-o">::</span><span class="tok-n">first</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This function returns the first node in forward document order from the set, or null node if the set is empty. Note that while the result of the node does not depend on the order of nodes in the set (i.e. on the result of <code>type()</code>), the complexity does - if the set is sorted, the complexity is constant, otherwise it is linear in the number of elements or worse.</p>
</div>
<div id="xpath_node_set::ctor" class="paragraph">
<p>While in the majority of cases the node set is returned by XPath functions, sometimes there is a need to manually construct a node set. For such cases, a constructor is provided which takes an iterator range (<code>const_iterator</code> is a typedef for <code>const xpath_node*</code>), and an optional type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-n">xpath_node_set</span><span class="tok-o">::</span><span class="tok-n">xpath_node_set</span><span class="tok-p">(</span><span class="tok-n">const_iterator</span> <span class="tok-n">begin</span><span class="tok-p">,</span> <span class="tok-n">const_iterator</span> <span class="tok-n">end</span><span class="tok-p">,</span> <span class="tok-kt">type_t</span> <span class="tok-n">type</span> <span class="tok-o">=</span> <span class="tok-n">type_unsorted</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The constructor copies the specified range and sets the specified type. The objects in the range are not checked in any way; you&#8217;ll have to ensure that the range contains no duplicates, and that the objects are sorted according to the <code>type</code> parameter. Otherwise XPath operations with this set may produce unexpected results.</p>
</div>
</div>
<div class="sect2">
<h3 id="xpath.select"><a class="anchor" href="#xpath.select"></a>8.2. Selecting nodes via XPath expression</h3>
<div class="paragraph">
<p><a id="xml_node::select_node"></a><a id="xml_node::select_nodes"></a>
If you want to select nodes that match some XPath expression, you can do it with the following functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-n">xpath_node</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">select_node</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">query</span><span class="tok-p">,</span> <span class="tok-n">xpath_variable_set</span><span class="tok-o">*</span> <span class="tok-n">variables</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-n">xpath_node_set</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">select_nodes</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">query</span><span class="tok-p">,</span> <span class="tok-n">xpath_variable_set</span><span class="tok-o">*</span> <span class="tok-n">variables</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>select_nodes</code> function compiles the expression and then executes it with the node as a context node, and returns the resulting node set. <code>select_node</code> returns only the first node in document order from the result, and is equivalent to calling <code>select_nodes(query).first()</code>. If the XPath expression does not match anything, or the node handle is null, <code>select_nodes</code> returns an empty set, and <code>select_node</code> returns null XPath node.</p>
</div>
<div class="paragraph">
<p>If exception handling is not disabled, both functions throw <a href="#xpath_exception">xpath_exception</a> if the query can not be compiled or if it returns a value with type other than node set; see <a href="#xpath.errors">Error handling</a> for details.</p>
</div>
<div class="paragraph">
<p><a id="xml_node::select_node_precomp"></a><a id="xml_node::select_nodes_precomp"></a>
While compiling expressions is fast, the compilation time can introduce a significant overhead if the same expression is used many times on small subtrees. If you&#8217;re doing many similar queries, consider compiling them into query objects (see <a href="#xpath.query">Using query objects</a> for further reference). Once you get a compiled query object, you can pass it to select functions instead of an expression string:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-n">xpath_node</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">select_node</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xpath_query</span><span class="tok-o">&amp;</span> <span class="tok-n">query</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-n">xpath_node_set</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">select_nodes</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xpath_query</span><span class="tok-o">&amp;</span> <span class="tok-n">query</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If exception handling is not disabled, both functions throw <a href="#xpath_exception">xpath_exception</a> if the query returns a value with type other than node set.</p>
</div>
<div class="paragraph">
<p>This is an example of selecting nodes using XPath expressions (<a href="samples/xpath_select.cpp" class="bare">samples/xpath_select.cpp</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xpath_node_set</span> <span class="tok-n">tools</span> <span class="tok-o">=</span> <span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">select_nodes</span><span class="tok-p">(</span><span class="tok-s">&quot;/Profile/Tools/Tool[@AllowRemote=&#39;true&#39; and @DeriveCaptionFrom=&#39;lastparam&#39;]&quot;</span><span class="tok-p">);</span>

<span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;Tools:</span><span class="tok-se">\n</span><span class="tok-s">&quot;</span><span class="tok-p">;</span>

<span class="tok-k">for</span> <span class="tok-p">(</span><span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xpath_node_set</span><span class="tok-o">::</span><span class="tok-n">const_iterator</span> <span class="tok-n">it</span> <span class="tok-o">=</span> <span class="tok-n">tools</span><span class="tok-p">.</span><span class="tok-n">begin</span><span class="tok-p">();</span> <span class="tok-n">it</span> <span class="tok-o">!=</span> <span class="tok-n">tools</span><span class="tok-p">.</span><span class="tok-n">end</span><span class="tok-p">();</span> <span class="tok-o">++</span><span class="tok-n">it</span><span class="tok-p">)</span>
<span class="tok-p">{</span>
    <span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xpath_node</span> <span class="tok-n">node</span> <span class="tok-o">=</span> <span class="tok-o">*</span><span class="tok-n">it</span><span class="tok-p">;</span>
    <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">node</span><span class="tok-p">.</span><span class="tok-n">node</span><span class="tok-p">().</span><span class="tok-n">attribute</span><span class="tok-p">(</span><span class="tok-s">&quot;Filename&quot;</span><span class="tok-p">).</span><span class="tok-n">value</span><span class="tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;</span><span class="tok-se">\n</span><span class="tok-s">&quot;</span><span class="tok-p">;</span>
<span class="tok-p">}</span>

<span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xpath_node</span> <span class="tok-n">build_tool</span> <span class="tok-o">=</span> <span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">select_node</span><span class="tok-p">(</span><span class="tok-s">&quot;//Tool[contains(Description, &#39;build system&#39;)]&quot;</span><span class="tok-p">);</span>

<span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">build_tool</span><span class="tok-p">)</span>
    <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;Build tool: &quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">build_tool</span><span class="tok-p">.</span><span class="tok-n">node</span><span class="tok-p">().</span><span class="tok-n">attribute</span><span class="tok-p">(</span><span class="tok-s">&quot;Filename&quot;</span><span class="tok-p">).</span><span class="tok-n">value</span><span class="tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;</span><span class="tok-se">\n</span><span class="tok-s">&quot;</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="xpath.query"><a class="anchor" href="#xpath.query"></a>8.3. Using query objects</h3>
<div id="xpath_query" class="paragraph">
<p>When you call <code>select_nodes</code> with an expression string as an argument, a query object is created behind the scenes. A query object represents a compiled XPath expression. Query objects can be needed in the following circumstances:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>You can precompile expressions to query objects to save compilation time if it becomes an issue;</p>
</li>
<li>
<p>You can use query objects to evaluate XPath expressions which result in booleans, numbers or strings;</p>
</li>
<li>
<p>You can get the type of expression value via query object.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Query objects correspond to <code>xpath_query</code> type. They are immutable and non-copyable: they are bound to the expression at creation time and can not be cloned. If you want to put query objects in a container, either allocate them on heap via <code>new</code> operator and store pointers to <code>xpath_query</code> in the container, or use a C11 compiler (query objects are movable in C11).</p>
</div>
<div id="xpath_query::ctor" class="paragraph">
<p>You can create a query object with the constructor that takes XPath expression as an argument:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-k">explicit</span> <span class="tok-n">xpath_query</span><span class="tok-o">::</span><span class="tok-n">xpath_query</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">query</span><span class="tok-p">,</span> <span class="tok-n">xpath_variable_set</span><span class="tok-o">*</span> <span class="tok-n">variables</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div id="xpath_query::return_type" class="paragraph">
<p>The expression is compiled and the compiled representation is stored in the new query object. If compilation fails, <a href="#xpath_exception">xpath_exception</a> is thrown if exception handling is not disabled (see <a href="#xpath.errors">Error handling</a> for details). After the query is created, you can query the type of the evaluation result using the following function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-n">xpath_value_type</span> <span class="tok-n">xpath_query</span><span class="tok-o">::</span><span class="tok-n">return_type</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><a id="xpath_query::evaluate_boolean"></a><a id="xpath_query::evaluate_number"></a><a id="xpath_query::evaluate_string"></a><a id="xpath_query::evaluate_node_set"></a><a id="xpath_query::evaluate_node"></a>
You can evaluate the query using one of the following functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-kt">bool</span> <span class="tok-n">xpath_query</span><span class="tok-o">::</span><span class="tok-n">evaluate_boolean</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xpath_node</span><span class="tok-o">&amp;</span> <span class="tok-n">n</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-kt">double</span> <span class="tok-n">xpath_query</span><span class="tok-o">::</span><span class="tok-n">evaluate_number</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xpath_node</span><span class="tok-o">&amp;</span> <span class="tok-n">n</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-kt">string_t</span> <span class="tok-n">xpath_query</span><span class="tok-o">::</span><span class="tok-n">evaluate_string</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xpath_node</span><span class="tok-o">&amp;</span> <span class="tok-n">n</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-n">xpath_node_set</span> <span class="tok-n">xpath_query</span><span class="tok-o">::</span><span class="tok-n">evaluate_node_set</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xpath_node</span><span class="tok-o">&amp;</span> <span class="tok-n">n</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-n">xpath_node</span> <span class="tok-n">xpath_query</span><span class="tok-o">::</span><span class="tok-n">evaluate_node</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xpath_node</span><span class="tok-o">&amp;</span> <span class="tok-n">n</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>All functions take the context node as an argument, compute the expression and return the result, converted to the requested type. According to XPath specification, value of any type can be converted to boolean, number or string value, but no type other than node set can be converted to node set. Because of this, <code>evaluate_boolean</code>, <code>evaluate_number</code> and <code>evaluate_string</code> always return a result, but <code>evaluate_node_set</code> and <code>evaluate_node</code> result in an error if the return type is not node set (see <a href="#xpath.errors">Error handling</a>).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Calling <code>node.select_nodes("query")</code> is equivalent to calling <code>xpath_query("query").evaluate_node_set(node)</code>. Calling <code>node.select_node("query")</code> is equivalent to calling <code>xpath_query("query").evaluate_node(node)</code>.
</td>
</tr>
</table>
</div>
<div id="xpath_query::evaluate_string_buffer" class="paragraph">
<p>Note that <code>evaluate_string</code> function returns the STL string; as such, it&#8217;s not available in <a href="#PUGIXML_NO_STL">PUGIXML_NO_STL</a> mode and also usually allocates memory. There is another string evaluation function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-kt">size_t</span> <span class="tok-n">xpath_query</span><span class="tok-o">::</span><span class="tok-n">evaluate_string</span><span class="tok-p">(</span><span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">buffer</span><span class="tok-p">,</span> <span class="tok-kt">size_t</span> <span class="tok-n">capacity</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-n">xpath_node</span><span class="tok-o">&amp;</span> <span class="tok-n">n</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This function evaluates the string, and then writes the result to <code>buffer</code> (but at most <code>capacity</code> characters); then it returns the full size of the result in characters, including the terminating zero. If <code>capacity</code> is not 0, the resulting buffer is always zero-terminated. You can use this function as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>First call the function with <code>buffer = 0</code> and <code>capacity = 0</code>; then allocate the returned amount of characters, and call the function again, passing the allocated storage and the amount of characters;</p>
</li>
<li>
<p>First call the function with small buffer and buffer capacity; then, if the result is larger than the capacity, the output has been trimmed, so allocate a larger buffer and call the function again.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This is an example of using query objects (<a href="samples/xpath_query.cpp" class="bare">samples/xpath_query.cpp</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-c1">// Select nodes via compiled query</span>
<span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xpath_query</span> <span class="tok-n">query_remote_tools</span><span class="tok-p">(</span><span class="tok-s">&quot;/Profile/Tools/Tool[@AllowRemote=&#39;true&#39;]&quot;</span><span class="tok-p">);</span>

<span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xpath_node_set</span> <span class="tok-n">tools</span> <span class="tok-o">=</span> <span class="tok-n">query_remote_tools</span><span class="tok-p">.</span><span class="tok-n">evaluate_node_set</span><span class="tok-p">(</span><span class="tok-n">doc</span><span class="tok-p">);</span>
<span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;Remote tool: &quot;</span><span class="tok-p">;</span>
<span class="tok-n">tools</span><span class="tok-p">[</span><span class="tok-mi">2</span><span class="tok-p">].</span><span class="tok-n">node</span><span class="tok-p">().</span><span class="tok-n">print</span><span class="tok-p">(</span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span><span class="tok-p">);</span>

<span class="tok-c1">// Evaluate numbers via compiled query</span>
<span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xpath_query</span> <span class="tok-n">query_timeouts</span><span class="tok-p">(</span><span class="tok-s">&quot;sum(//Tool/@Timeout)&quot;</span><span class="tok-p">);</span>
<span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">query_timeouts</span><span class="tok-p">.</span><span class="tok-n">evaluate_number</span><span class="tok-p">(</span><span class="tok-n">doc</span><span class="tok-p">)</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">endl</span><span class="tok-p">;</span>

<span class="tok-c1">// Evaluate strings via compiled query for different context nodes</span>
<span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xpath_query</span> <span class="tok-n">query_name_valid</span><span class="tok-p">(</span><span class="tok-s">&quot;string-length(substring-before(@Filename, &#39;_&#39;)) &gt; 0 and @OutputFileMasks&quot;</span><span class="tok-p">);</span>
<span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xpath_query</span> <span class="tok-n">query_name</span><span class="tok-p">(</span><span class="tok-s">&quot;concat(substring-before(@Filename, &#39;_&#39;), &#39; produces &#39;, @OutputFileMasks)&quot;</span><span class="tok-p">);</span>

<span class="tok-k">for</span> <span class="tok-p">(</span><span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xml_node</span> <span class="tok-n">tool</span> <span class="tok-o">=</span> <span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">first_element_by_path</span><span class="tok-p">(</span><span class="tok-s">&quot;Profile/Tools/Tool&quot;</span><span class="tok-p">);</span> <span class="tok-n">tool</span><span class="tok-p">;</span> <span class="tok-n">tool</span> <span class="tok-o">=</span> <span class="tok-n">tool</span><span class="tok-p">.</span><span class="tok-n">next_sibling</span><span class="tok-p">())</span>
<span class="tok-p">{</span>
    <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">string</span> <span class="tok-n">s</span> <span class="tok-o">=</span> <span class="tok-n">query_name</span><span class="tok-p">.</span><span class="tok-n">evaluate_string</span><span class="tok-p">(</span><span class="tok-n">tool</span><span class="tok-p">);</span>

    <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">query_name_valid</span><span class="tok-p">.</span><span class="tok-n">evaluate_boolean</span><span class="tok-p">(</span><span class="tok-n">tool</span><span class="tok-p">))</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">s</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">endl</span><span class="tok-p">;</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="xpath.variables"><a class="anchor" href="#xpath.variables"></a>8.4. Using variables</h3>
<div class="paragraph">
<p>XPath queries may contain references to variables; this is useful if you want to use queries that depend on some dynamic parameter without manually preparing the complete query string, or if you want to reuse the same query object for similar queries.</p>
</div>
<div class="paragraph">
<p>Variable references have the form <code>$name</code>; in order to use them, you have to provide a variable set, which includes all variables present in the query with correct types. This set is passed to <code>xpath_query</code> constructor or to <code>select_nodes</code>/<code>select_node</code> functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-k">explicit</span> <span class="tok-n">xpath_query</span><span class="tok-o">::</span><span class="tok-n">xpath_query</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">query</span><span class="tok-p">,</span> <span class="tok-n">xpath_variable_set</span><span class="tok-o">*</span> <span class="tok-n">variables</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">);</span>
<span class="tok-n">xpath_node</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">select_node</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">query</span><span class="tok-p">,</span> <span class="tok-n">xpath_variable_set</span><span class="tok-o">*</span> <span class="tok-n">variables</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-n">xpath_node_set</span> <span class="tok-n">xml_node</span><span class="tok-o">::</span><span class="tok-n">select_nodes</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">query</span><span class="tok-p">,</span> <span class="tok-n">xpath_variable_set</span><span class="tok-o">*</span> <span class="tok-n">variables</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If you&#8217;re using query objects, you can change the variable values before <code>evaluate</code>/<code>select</code> calls to change the query behavior.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
The variable set pointer is stored in the query object; you have to ensure that the lifetime of the set exceeds that of query object.
</td>
</tr>
</table>
</div>
<div id="xpath_variable_set" class="paragraph">
<p>Variable sets correspond to <code>xpath_variable_set</code> type, which is essentially a variable container.</p>
</div>
<div id="xpath_variable_set::add" class="paragraph">
<p>You can add new variables with the following function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-n">xpath_variable</span><span class="tok-o">*</span> <span class="tok-n">xpath_variable_set</span><span class="tok-o">::</span><span class="tok-n">add</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">name</span><span class="tok-p">,</span> <span class="tok-n">xpath_value_type</span> <span class="tok-n">type</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The function tries to add a new variable with the specified name and type; if the variable with such name does not exist in the set, the function adds a new variable and returns the variable handle; if there is already a variable with the specified name, the function returns the variable handle if variable has the specified type. Otherwise the function returns null pointer; it also returns null pointer on allocation failure.</p>
</div>
<div class="paragraph">
<p>New variables are assigned the default value which depends on the type: <code>0</code> for numbers, <code>false</code> for booleans, empty string for strings and empty set for node sets.</p>
</div>
<div id="xpath_variable_set::get" class="paragraph">
<p>You can get the existing variables with the following functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-n">xpath_variable</span><span class="tok-o">*</span> <span class="tok-n">xpath_variable_set</span><span class="tok-o">::</span><span class="tok-n">get</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">name</span><span class="tok-p">);</span>
<span class="tok-k">const</span> <span class="tok-n">xpath_variable</span><span class="tok-o">*</span> <span class="tok-n">xpath_variable_set</span><span class="tok-o">::</span><span class="tok-n">get</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">name</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The functions return the variable handle, or null pointer if the variable with the specified name is not found.</p>
</div>
<div id="xpath_variable_set::set" class="paragraph">
<p>Additionally, there are the helper functions for setting the variable value by name; they try to add the variable with the corresponding type, if it does not exist, and to set the value. If the variable with the same name but with different type is already present, they return <code>false</code>; they also return <code>false</code> on allocation failure. Note that these functions do not perform any type conversions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-kt">bool</span> <span class="tok-n">xpath_variable_set</span><span class="tok-o">::</span><span class="tok-n">set</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">name</span><span class="tok-p">,</span> <span class="tok-kt">bool</span> <span class="tok-n">value</span><span class="tok-p">);</span>
<span class="tok-kt">bool</span> <span class="tok-n">xpath_variable_set</span><span class="tok-o">::</span><span class="tok-n">set</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">name</span><span class="tok-p">,</span> <span class="tok-kt">double</span> <span class="tok-n">value</span><span class="tok-p">);</span>
<span class="tok-kt">bool</span> <span class="tok-n">xpath_variable_set</span><span class="tok-o">::</span><span class="tok-n">set</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">name</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">value</span><span class="tok-p">);</span>
<span class="tok-kt">bool</span> <span class="tok-n">xpath_variable_set</span><span class="tok-o">::</span><span class="tok-n">set</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">name</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-n">xpath_node_set</span><span class="tok-o">&amp;</span> <span class="tok-n">value</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The variable values are copied to the internal variable storage, so you can modify or destroy them after the functions return.</p>
</div>
<div id="xpath_variable" class="paragraph">
<p>If setting variables by name is not efficient enough, or if you have to inspect variable information or get variable values, you can use variable handles. A variable corresponds to the <code>xpath_variable</code> type, and a variable handle is simply a pointer to <code>xpath_variable</code>.</p>
</div>
<div class="paragraph">
<p><a id="xpath_variable::type"></a><a id="xpath_variable::name"></a>
In order to get variable information, you can use one of the following functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">xpath_variable</span><span class="tok-o">::</span><span class="tok-n">name</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-n">xpath_value_type</span> <span class="tok-n">xpath_variable</span><span class="tok-o">::</span><span class="tok-n">type</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that each variable has a distinct type which is specified upon variable creation and can not be changed later.</p>
</div>
<div class="paragraph">
<p><a id="xpath_variable::get_boolean"></a><a id="xpath_variable::get_number"></a><a id="xpath_variable::get_string"></a><a id="xpath_variable::get_node_set"></a>
In order to get variable value, you should use one of the following functions, depending on the variable type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-kt">bool</span> <span class="tok-n">xpath_variable</span><span class="tok-o">::</span><span class="tok-n">get_boolean</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-kt">double</span> <span class="tok-n">xpath_variable</span><span class="tok-o">::</span><span class="tok-n">get_number</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">xpath_variable</span><span class="tok-o">::</span><span class="tok-n">get_string</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-k">const</span> <span class="tok-n">xpath_node_set</span><span class="tok-o">&amp;</span> <span class="tok-n">xpath_variable</span><span class="tok-o">::</span><span class="tok-n">get_node_set</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>These functions return the value of the variable. Note that no type conversions are performed; if the type mismatch occurs, a dummy value is returned (<code>false</code> for booleans, <code>NaN</code> for numbers, empty string for strings and empty set for node sets).</p>
</div>
<div id="xpath_variable::set" class="paragraph">
<p>In order to set variable value, you should use one of the following functions, depending on the variable type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-kt">bool</span> <span class="tok-n">xpath_variable</span><span class="tok-o">::</span><span class="tok-n">set</span><span class="tok-p">(</span><span class="tok-kt">bool</span> <span class="tok-n">value</span><span class="tok-p">);</span>
<span class="tok-kt">bool</span> <span class="tok-n">xpath_variable</span><span class="tok-o">::</span><span class="tok-n">set</span><span class="tok-p">(</span><span class="tok-kt">double</span> <span class="tok-n">value</span><span class="tok-p">);</span>
<span class="tok-kt">bool</span> <span class="tok-n">xpath_variable</span><span class="tok-o">::</span><span class="tok-n">set</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">value</span><span class="tok-p">);</span>
<span class="tok-kt">bool</span> <span class="tok-n">xpath_variable</span><span class="tok-o">::</span><span class="tok-n">set</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xpath_node_set</span><span class="tok-o">&amp;</span> <span class="tok-n">value</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>These functions modify the variable value. Note that no type conversions are performed; if the type mismatch occurs, the functions return <code>false</code>; they also return <code>false</code> on allocation failure. The variable values are copied to the internal variable storage, so you can modify or destroy them after the functions return.</p>
</div>
<div class="paragraph">
<p>This is an example of using variables in XPath queries (<a href="samples/xpath_variables.cpp" class="bare">samples/xpath_variables.cpp</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-c1">// Select nodes via compiled query</span>
<span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xpath_variable_set</span> <span class="tok-n">vars</span><span class="tok-p">;</span>
<span class="tok-n">vars</span><span class="tok-p">.</span><span class="tok-n">add</span><span class="tok-p">(</span><span class="tok-s">&quot;remote&quot;</span><span class="tok-p">,</span> <span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xpath_type_boolean</span><span class="tok-p">);</span>

<span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xpath_query</span> <span class="tok-n">query_remote_tools</span><span class="tok-p">(</span><span class="tok-s">&quot;/Profile/Tools/Tool[@AllowRemote = string($remote)]&quot;</span><span class="tok-p">,</span> <span class="tok-o">&amp;</span><span class="tok-n">vars</span><span class="tok-p">);</span>

<span class="tok-n">vars</span><span class="tok-p">.</span><span class="tok-n">set</span><span class="tok-p">(</span><span class="tok-s">&quot;remote&quot;</span><span class="tok-p">,</span> <span class="tok-nb">true</span><span class="tok-p">);</span>
<span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xpath_node_set</span> <span class="tok-n">tools_remote</span> <span class="tok-o">=</span> <span class="tok-n">query_remote_tools</span><span class="tok-p">.</span><span class="tok-n">evaluate_node_set</span><span class="tok-p">(</span><span class="tok-n">doc</span><span class="tok-p">);</span>

<span class="tok-n">vars</span><span class="tok-p">.</span><span class="tok-n">set</span><span class="tok-p">(</span><span class="tok-s">&quot;remote&quot;</span><span class="tok-p">,</span> <span class="tok-nb">false</span><span class="tok-p">);</span>
<span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xpath_node_set</span> <span class="tok-n">tools_local</span> <span class="tok-o">=</span> <span class="tok-n">query_remote_tools</span><span class="tok-p">.</span><span class="tok-n">evaluate_node_set</span><span class="tok-p">(</span><span class="tok-n">doc</span><span class="tok-p">);</span>

<span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;Remote tool: &quot;</span><span class="tok-p">;</span>
<span class="tok-n">tools_remote</span><span class="tok-p">[</span><span class="tok-mi">2</span><span class="tok-p">].</span><span class="tok-n">node</span><span class="tok-p">().</span><span class="tok-n">print</span><span class="tok-p">(</span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span><span class="tok-p">);</span>

<span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;Local tool: &quot;</span><span class="tok-p">;</span>
<span class="tok-n">tools_local</span><span class="tok-p">[</span><span class="tok-mi">0</span><span class="tok-p">].</span><span class="tok-n">node</span><span class="tok-p">().</span><span class="tok-n">print</span><span class="tok-p">(</span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span><span class="tok-p">);</span>

<span class="tok-c1">// You can pass the context directly to select_nodes/select_node</span>
<span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xpath_node_set</span> <span class="tok-n">tools_local_imm</span> <span class="tok-o">=</span> <span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">select_nodes</span><span class="tok-p">(</span><span class="tok-s">&quot;/Profile/Tools/Tool[@AllowRemote = string($remote)]&quot;</span><span class="tok-p">,</span> <span class="tok-o">&amp;</span><span class="tok-n">vars</span><span class="tok-p">);</span>

<span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;Local tool imm: &quot;</span><span class="tok-p">;</span>
<span class="tok-n">tools_local_imm</span><span class="tok-p">[</span><span class="tok-mi">0</span><span class="tok-p">].</span><span class="tok-n">node</span><span class="tok-p">().</span><span class="tok-n">print</span><span class="tok-p">(</span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="xpath.errors"><a class="anchor" href="#xpath.errors"></a>8.5. Error handling</h3>
<div class="paragraph">
<p>There are two different mechanisms for error handling in XPath implementation; the mechanism used depends on whether exception support is disabled (this is controlled with <a href="#PUGIXML_NO_EXCEPTIONS">PUGIXML_NO_EXCEPTIONS</a> define).</p>
</div>
<div class="paragraph">
<p><a id="xpath_exception"></a><a id="xpath_exception::result"></a><a id="xpath_exception::what"></a>
By default, XPath functions throw <code>xpath_exception</code> object in case of errors; additionally, in the event any memory allocation fails, an <code>std::bad_alloc</code> exception is thrown. Also <code>xpath_exception</code> is thrown if the query is evaluated to a node set, but the return type is not node set. If the query constructor succeeds (i.e. no exception is thrown), the query object is valid. Otherwise you can get the error details via one of the following functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-k">virtual</span> <span class="tok-k">const</span> <span class="tok-kt">char</span><span class="tok-o">*</span> <span class="tok-n">xpath_exception</span><span class="tok-o">::</span><span class="tok-n">what</span><span class="tok-p">()</span> <span class="tok-k">const</span> <span class="tok-k">throw</span><span class="tok-p">();</span>
<span class="tok-k">const</span> <span class="tok-n">xpath_parse_result</span><span class="tok-o">&amp;</span> <span class="tok-n">xpath_exception</span><span class="tok-o">::</span><span class="tok-n">result</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><a id="xpath_query::unspecified_bool_type"></a><a id="xpath_query::result"></a>
If exceptions are disabled, then in the event of parsing failure the query is initialized to invalid state; you can test if the query object is valid by using it in a boolean expression: <code>if (query) { &#8230;&#8203; }</code>. Additionally, you can get parsing result via the result() accessor:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-k">const</span> <span class="tok-n">xpath_parse_result</span><span class="tok-o">&amp;</span> <span class="tok-n">xpath_query</span><span class="tok-o">::</span><span class="tok-n">result</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Without exceptions, evaluating invalid query results in <code>false</code>, empty string, <code>NaN</code> or an empty node set, depending on the type; evaluating a query as a node set results in an empty node set if the return type is not node set.</p>
</div>
<div id="xpath_parse_result" class="paragraph">
<p>The information about parsing result is returned via <code>xpath_parse_result</code> object. It contains parsing status and the offset of last successfully parsed character from the beginning of the source stream:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-k">struct</span> <span class="tok-n">xpath_parse_result</span>
<span class="tok-p">{</span>
    <span class="tok-k">const</span> <span class="tok-kt">char</span><span class="tok-o">*</span> <span class="tok-n">error</span><span class="tok-p">;</span>
    <span class="tok-kt">ptrdiff_t</span> <span class="tok-n">offset</span><span class="tok-p">;</span>

    <span class="tok-k">operator</span> <span class="tok-kt">bool</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-k">const</span> <span class="tok-kt">char</span><span class="tok-o">*</span> <span class="tok-n">description</span><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
<span class="tok-p">};</span></code></pre>
</div>
</div>
<div id="xpath_parse_result::error" class="paragraph">
<p>Parsing result is represented as the error message; it is either a null pointer, in case there is no error, or the error message in the form of ASCII zero-terminated string.</p>
</div>
<div id="xpath_parse_result::description" class="paragraph">
<p><code>description()</code> member function can be used to get the error message; it never returns the null pointer, so you can safely use <code>description()</code> even if query parsing succeeded. Note that <code>description()</code> returns a <code>char</code> string even in <code>PUGIXML_WCHAR_MODE</code>; you&#8217;ll have to call <a href="#as_wide">as_wide</a> to get the <code>wchar_t</code> string.</p>
</div>
<div id="xpath_parse_result::offset" class="paragraph">
<p>In addition to the error message, parsing result has an <code>offset</code> member, which contains the offset of last successfully parsed character. This offset is in units of <a href="#char_t">pugi::char_t</a> (bytes for character mode, wide characters for wide character mode).</p>
</div>
<div id="xpath_parse_result::bool" class="paragraph">
<p>Parsing result object can be implicitly converted to <code>bool</code> like this: <code>if (result) { &#8230;&#8203; } else { &#8230;&#8203; }</code>.</p>
</div>
<div class="paragraph">
<p>This is an example of XPath error handling (<a href="samples/xpath_error.cpp" class="bare">samples/xpath_error.cpp</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-c1">// Exception is thrown for incorrect query syntax</span>
<span class="tok-n">try</span>
<span class="tok-p">{</span>
    <span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">select_nodes</span><span class="tok-p">(</span><span class="tok-s">&quot;//nodes[#true()]&quot;</span><span class="tok-p">);</span>
<span class="tok-p">}</span>
<span class="tok-k">catch</span> <span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xpath_exception</span><span class="tok-o">&amp;</span> <span class="tok-n">e</span><span class="tok-p">)</span>
<span class="tok-p">{</span>
    <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;Select failed: &quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">e</span><span class="tok-p">.</span><span class="tok-n">what</span><span class="tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">endl</span><span class="tok-p">;</span>
<span class="tok-p">}</span>

<span class="tok-c1">// Exception is thrown for incorrect query semantics</span>
<span class="tok-n">try</span>
<span class="tok-p">{</span>
    <span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">select_nodes</span><span class="tok-p">(</span><span class="tok-s">&quot;(123)/next&quot;</span><span class="tok-p">);</span>
<span class="tok-p">}</span>
<span class="tok-k">catch</span> <span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xpath_exception</span><span class="tok-o">&amp;</span> <span class="tok-n">e</span><span class="tok-p">)</span>
<span class="tok-p">{</span>
    <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;Select failed: &quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">e</span><span class="tok-p">.</span><span class="tok-n">what</span><span class="tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">endl</span><span class="tok-p">;</span>
<span class="tok-p">}</span>

<span class="tok-c1">// Exception is thrown for query with incorrect return type</span>
<span class="tok-n">try</span>
<span class="tok-p">{</span>
    <span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">select_nodes</span><span class="tok-p">(</span><span class="tok-s">&quot;123&quot;</span><span class="tok-p">);</span>
<span class="tok-p">}</span>
<span class="tok-k">catch</span> <span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">pugi</span><span class="tok-o">::</span><span class="tok-n">xpath_exception</span><span class="tok-o">&amp;</span> <span class="tok-n">e</span><span class="tok-p">)</span>
<span class="tok-p">{</span>
    <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;Select failed: &quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">e</span><span class="tok-p">.</span><span class="tok-n">what</span><span class="tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">endl</span><span class="tok-p">;</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="xpath.w3c"><a class="anchor" href="#xpath.w3c"></a>8.6. Conformance to W3C specification</h3>
<div class="paragraph">
<p>Because of the differences in document object models, performance considerations and implementation complexity, pugixml does not provide a fully conformant XPath 1.0 implementation. This is the current list of incompatibilities:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Consecutive text nodes sharing the same parent are not merged, i.e. in <code>&lt;node&gt;text1 &lt;![CDATA[data]]&gt; text2&lt;/node&gt;</code> node should have one text node child, but instead has three.</p>
</li>
<li>
<p>Since the document type declaration is not used for parsing, <code>id()</code> function always returns an empty node set.</p>
</li>
<li>
<p>Namespace nodes are not supported (affects <code>namespace::</code> axis).</p>
</li>
<li>
<p>Name tests are performed on QNames in XML document instead of expanded names; for <code>&lt;foo xmlns:ns1='uri' xmlns:ns2='uri'&gt;&lt;ns1:child/&gt;&lt;ns2:child/&gt;&lt;/foo&gt;</code>, query <code>foo/ns1:*</code> will return only the first child, not both of them. Compliant XPath implementations can return both nodes if the user provides appropriate namespace declarations.</p>
</li>
<li>
<p>String functions consider a character to be either a single <code>char</code> value or a single <code>wchar_t</code> value, depending on the library configuration; this means that some string functions are not fully Unicode-aware. This affects <code>substring()</code>, <code>string-length()</code> and <code>translate()</code> functions.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="changes"><a class="anchor" href="#changes"></a>9. Changelog</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="v1.7"><a class="anchor" href="#v1.7"></a>v1.7 <sup>19.10.2015</sup></h3>
<div class="paragraph">
<p>Major release, featuring performance and memory improvements along with some new features. Changes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Compact mode:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Introduced a new tree storage mode that takes significantly less memory (2-5x smaller DOM) at some performance cost.</p>
</li>
<li>
<p>The mode can be enabled using <code>PUGIXML_COMPACT</code> define.</p>
</li>
</ol>
</div>
</li>
<li>
<p>New integer parsing/formatting implementation:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Functions that convert from and to integers (e.g. <code>as_int</code>/<code>set_value</code>) do not rely on CRT any more.</p>
</li>
<li>
<p>New implementation is 3-5x faster and is always correct wrt overflow or underflow. This is a behavior change - where previously <code>as_uint()</code> would return UINT_MAX on a value "-1", it now returns 0.</p>
</li>
</ol>
</div>
</li>
<li>
<p>New features:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>XPath objects (<code>xpath_query</code>, <code>xpath_node_set</code>, <code>xpath_variable_set</code>) are now movable if your compiler supports C++11. Additionally, <code>xpath_variable_set</code> is copyable.</p>
</li>
<li>
<p>Added <code>format_indent_attributes</code> that makes the resulting XML friendlier to line diff/merge tools.</p>
</li>
<li>
<p>Added a variant of <code>xml_node::attribute</code> function with a hint that can improve lookup performance.</p>
</li>
<li>
<p>Custom allocation functions are now allowed (but not required) to throw instead of returning a null pointer.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Bug fixes:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Fix Clang 3.7 crashes in out-of-memory cases (C++ DR 1748)</p>
</li>
<li>
<p>Fix XPath crashes on SPARC64 (and other 32-bit architectures where doubles have to be aligned to 8 bytes)</p>
</li>
<li>
<p>Fix xpath_node_set assignment to provide strong exception guarantee</p>
</li>
<li>
<p>Fix saving for custom xml_writer implementations that can throw from write()</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="v1.6"><a class="anchor" href="#v1.6"></a>v1.6 <sup>10.04.2015</sup></h3>
<div class="paragraph">
<p>Maintenance release. Changes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Specification changes:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Attribute/text values now use more digits when printing floating point numbers to guarantee round-tripping.</p>
</li>
<li>
<p>Text nodes no longer get extra surrounding whitespace when pretty-printing nodes with mixed contents</p>
</li>
</ol>
</div>
</li>
<li>
<p>Bug fixes:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Fixed translate and normalize-space XPath functions to no longer return internal NUL characters</p>
</li>
<li>
<p>Fixed buffer overrun on malformed comments inside DOCTYPE sections</p>
</li>
<li>
<p>DOCTYPE parsing can no longer run out of stack space on malformed inputs (XML parsing is now using bounded stack space)</p>
</li>
<li>
<p>Adjusted processing instruction output to avoid malformed documents if the PI value contains <code>?&gt;</code></p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="v1.5"><a class="anchor" href="#v1.5"></a>v1.5 <sup>27.11.2014</sup></h3>
<div class="paragraph">
<p>Major release, featuring a lot of performance improvements and some new features.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Specification changes:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>xml_document::load(const char_t*)</code> was renamed to <code>load_string</code>; the old method is still available and will be deprecated in a future release</p>
</li>
<li>
<p><code>xml_node::select_single_node</code> was renamed to <code>select_node</code>; the old method is still available and will be deprecated in a future release.</p>
</li>
</ol>
</div>
</li>
<li>
<p>New features:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Added <code>xml_node::append_move</code> and other functions for moving nodes within a document</p>
</li>
<li>
<p>Added <code>xpath_query::evaluate_node</code> for evaluating queries with a single node as a result</p>
</li>
</ol>
</div>
</li>
<li>
<p>Performance improvements:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Optimized XML parsing (10-40% faster with clang/gcc, up to 10% faster with MSVC)</p>
</li>
<li>
<p>Optimized memory consumption when copying nodes in the same document (string contents is now shared)</p>
</li>
<li>
<p>Optimized node copying (10% faster for cross-document copies, 3x faster for inter-document copies; also it now consumes a constant amount of stack space)</p>
</li>
<li>
<p>Optimized node output (60% faster; also it now consumes a constant amount of stack space)</p>
</li>
<li>
<p>Optimized XPath allocation (query evaluation now results in fewer temporary allocations)</p>
</li>
<li>
<p>Optimized XPath sorting (node set sorting is 2-3x faster in some cases)</p>
</li>
<li>
<p>Optimized XPath evaluation (XPathMark suite is 100x faster; some commonly used queries are 3-4x faster)</p>
</li>
</ol>
</div>
</li>
<li>
<p>Compatibility improvements:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Fixed <code>xml_node::offset_debug</code> for corner cases</p>
</li>
<li>
<p>Fixed undefined behavior while calling memcpy in some cases</p>
</li>
<li>
<p>Fixed MSVC 2015 compilation warnings</p>
</li>
<li>
<p>Fixed <code>contrib/foreach.hpp</code> for Boost 1.56.0</p>
</li>
</ol>
</div>
</li>
<li>
<p>Bug fixes</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Adjusted comment output to avoid malformed documents if the comment value contains <code>--</code></p>
</li>
<li>
<p>Fix XPath sorting for documents that were constructed using append_buffer</p>
</li>
<li>
<p>Fix <code>load_file</code> for wide-character paths with non-ASCII characters in MinGW with C&#43;&#43;11 mode enabled</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="v1.4"><a class="anchor" href="#v1.4"></a>v1.4 <sup>27.02.2014</sup></h3>
<div class="paragraph">
<p>Major release, featuring various new features, bug fixes and compatibility improvements.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Specification changes:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Documents without element nodes are now rejected with <code>status_no_document_element</code> error, unless <code>parse_fragment</code> option is used</p>
</li>
</ol>
</div>
</li>
<li>
<p>New features:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Added XML fragment parsing (<code>parse_fragment</code> flag)</p>
</li>
<li>
<p>Added PCDATA whitespace trimming (<code>parse_trim_pcdata</code> flag)</p>
</li>
<li>
<p>Added long long support for <code>xml_attribute</code> and <code>xml_text</code> (<code>as_llong</code>, <code>as_ullong</code> and <code>set_value</code>/<code>set</code> overloads)</p>
</li>
<li>
<p>Added hexadecimal integer parsing support for <code>as_int</code>/<code>as_uint</code>/<code>as_llong</code>/<code>as_ullong</code></p>
</li>
<li>
<p>Added <code>xml_node::append_buffer</code> to improve performance of assembling documents from fragments</p>
</li>
<li>
<p><code>xml_named_node_iterator</code> is now bidirectional</p>
</li>
<li>
<p>Reduced XPath stack consumption during compilation and evaluation (useful for embedded systems)</p>
</li>
</ol>
</div>
</li>
<li>
<p>Compatibility improvements:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Improved support for platforms without wchar_t support</p>
</li>
<li>
<p>Fixed several false positives in clang static analysis</p>
</li>
<li>
<p>Fixed several compilation warnings for various GCC versions</p>
</li>
</ol>
</div>
</li>
<li>
<p>Bug fixes:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Fixed undefined pointer arithmetic in XPath implementation</p>
</li>
<li>
<p>Fixed non-seekable iostream support for certain stream types, i.e. Boost <code>file_source</code> with pipe input</p>
</li>
<li>
<p>Fixed <code>xpath_query::return_type</code> for some expressions</p>
</li>
<li>
<p>Fixed dllexport issues with <code>xml_named_node_iterator</code></p>
</li>
<li>
<p>Fixed <code>find_child_by_attribute</code> assertion for attributes with null name/value</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="v1.2"><a class="anchor" href="#v1.2"></a>v1.2 <sup>1.05.2012</sup></h3>
<div class="paragraph">
<p>Major release, featuring header-only mode, various interface enhancements (i.e. PCDATA manipulation and C&#43;&#43;11 iteration), many other features and compatibility improvements.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>New features:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Added <code>xml_text</code> helper class for working with PCDATA/CDATA contents of an element node</p>
</li>
<li>
<p>Added optional header-only mode (controlled by <code>PUGIXML_HEADER_ONLY</code> define)</p>
</li>
<li>
<p>Added <code>xml_node::children()</code> and <code>xml_node::attributes()</code> for C&#43;&#43;11 ranged for loop or <code>BOOST_FOREACH</code></p>
</li>
<li>
<p>Added support for Latin-1 (ISO-8859-1) encoding conversion during loading and saving</p>
</li>
<li>
<p>Added custom default values for <code>xml_attribute::as_*</code> (they are returned if the attribute does not exist)</p>
</li>
<li>
<p>Added <code>parse_ws_pcdata_single</code> flag for preserving whitespace-only PCDATA in case it&#8217;s the only child</p>
</li>
<li>
<p>Added <code>format_save_file_text</code> for <code>xml_document::save_file</code> to open files as text instead of binary (changes newlines on Windows)</p>
</li>
<li>
<p>Added <code>format_no_escapes</code> flag to disable special symbol escaping (complements <code>~parse_escapes</code>)</p>
</li>
<li>
<p>Added support for loading document from streams that do not support seeking</p>
</li>
<li>
<p>Added <code>PUGIXML_MEMORY_*</code> constants for tweaking allocation behavior (useful for embedded systems)</p>
</li>
<li>
<p>Added <code>PUGIXML_VERSION</code> preprocessor define</p>
</li>
</ol>
</div>
</li>
<li>
<p>Compatibility improvements:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Parser does not require setjmp support (improves compatibility with some embedded platforms, enables <code>/clr:pure</code> compilation)</p>
</li>
<li>
<p>STL forward declarations are no longer used (fixes SunCC/RWSTL compilation, fixes clang compilation in C&#43;&#43;11 mode)</p>
</li>
<li>
<p>Fixed AirPlay SDK, Android, Windows Mobile (WinCE) and C&#43;&#43;/CLI compilation</p>
</li>
<li>
<p>Fixed several compilation warnings for various GCC versions, Intel C&#43;&#43; compiler and Clang</p>
</li>
</ol>
</div>
</li>
<li>
<p>Bug fixes:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Fixed unsafe bool conversion to avoid problems on C&#43;&#43;/CLI</p>
</li>
<li>
<p>Iterator dereference operator is const now (fixes Boost <code>filter_iterator</code> support)</p>
</li>
<li>
<p><code>xml_document::save_file</code> now checks for file I/O errors during saving</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="v1.0"><a class="anchor" href="#v1.0"></a>v1.0 <sup>1.11.2010</sup></h3>
<div class="paragraph">
<p>Major release, featuring many XPath enhancements, wide character filename support, miscellaneous performance improvements, bug fixes and more.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>XPath:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>XPath implementation is moved to <code>pugixml.cpp</code> (which is the only source file now); use <code>PUGIXML_NO_XPATH</code> if you want to disable XPath to reduce code size</p>
</li>
<li>
<p>XPath is now supported without exceptions (<code>PUGIXML_NO_EXCEPTIONS</code>); the error handling mechanism depends on the presence of exception support</p>
</li>
<li>
<p>XPath is now supported without STL (<code>PUGIXML_NO_STL</code>)</p>
</li>
<li>
<p>Introduced variable support</p>
</li>
<li>
<p>Introduced new <code>xpath_query::evaluate_string</code>, which works without STL</p>
</li>
<li>
<p>Introduced new <code>xpath_node_set</code> constructor (from an iterator range)</p>
</li>
<li>
<p>Evaluation function now accept attribute context nodes</p>
</li>
<li>
<p>All internal allocations use custom allocation functions</p>
</li>
<li>
<p>Improved error reporting; now a last parsed offset is returned together with the parsing error</p>
</li>
</ol>
</div>
</li>
<li>
<p>Bug fixes:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Fixed memory leak for loading from streams with stream exceptions turned on</p>
</li>
<li>
<p>Fixed custom deallocation function calling with null pointer in one case</p>
</li>
<li>
<p>Fixed missing attributes for iterator category functions; all functions/classes can now be DLL-exported</p>
</li>
<li>
<p>Worked around Digital Mars compiler bug, which lead to minor read overfetches in several functions</p>
</li>
<li>
<p><code>load_file</code> now works with 2+ Gb files in MSVC/MinGW</p>
</li>
<li>
<p>XPath: fixed memory leaks for incorrect queries</p>
</li>
<li>
<p>XPath: fixed <code>xpath_node()</code> attribute constructor with empty attribute argument</p>
</li>
<li>
<p>XPath: fixed <code>lang()</code> function for non-ASCII arguments</p>
</li>
</ol>
</div>
</li>
<li>
<p>Specification changes:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>CDATA nodes containing <code>]]&gt;</code> are printed as several nodes; while this changes the internal structure, this is the only way to escape CDATA contents</p>
</li>
<li>
<p>Memory allocation errors during parsing now preserve last parsed offset (to give an idea about parsing progress)</p>
</li>
<li>
<p>If an element node has the only child, and it is of CDATA type, then the extra indentation is omitted (previously this behavior only held for PCDATA children)</p>
</li>
</ol>
</div>
</li>
<li>
<p>Additional functionality:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Added <code>xml_parse_result</code> default constructor</p>
</li>
<li>
<p>Added <code>xml_document::load_file</code> and <code>xml_document::save_file</code> with wide character paths</p>
</li>
<li>
<p>Added <code>as_utf8</code> and <code>as_wide</code> overloads for <code>std::wstring</code>/<code>std::string</code> arguments</p>
</li>
<li>
<p>Added DOCTYPE node type (<code>node_doctype</code>) and a special parse flag, <code>parse_doctype</code>, to add such nodes to the document during parsing</p>
</li>
<li>
<p>Added <code>parse_full</code> parse flag mask, which extends <code>parse_default</code> with all node type parsing flags except <code>parse_ws_pcdata</code></p>
</li>
<li>
<p>Added <code>xml_node::hash_value()</code> and <code>xml_attribute::hash_value()</code> functions for use in hash-based containers</p>
</li>
<li>
<p>Added <code>internal_object()</code> and additional constructor for both <code>xml_node</code> and <code>xml_attribute</code> for easier marshalling (useful for language bindings)</p>
</li>
<li>
<p>Added <code>xml_document::document_element()</code> function</p>
</li>
<li>
<p>Added <code>xml_node::prepend_attribute</code>, <code>xml_node::prepend_child</code> and <code>xml_node::prepend_copy</code> functions</p>
</li>
<li>
<p>Added <code>xml_node::append_child</code>, <code>xml_node::prepend_child</code>, <code>xml_node::insert_child_before</code> and <code>xml_node::insert_child_after</code> overloads for element nodes (with name instead of type)</p>
</li>
<li>
<p>Added <code>xml_document::reset()</code> function</p>
</li>
</ol>
</div>
</li>
<li>
<p>Performance improvements:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>xml_node::root()</code> and <code>xml_node::offset_debug()</code> are now O(1) instead of O(logN)</p>
</li>
<li>
<p>Minor parsing optimizations</p>
</li>
<li>
<p>Minor memory optimization for strings in DOM tree (<code>set_name</code>/<code>set_value</code>)</p>
</li>
<li>
<p>Memory optimization for string memory reclaiming in DOM tree (<code>set_name</code>/<code>set_value</code> now reallocate the buffer if memory waste is too big)</p>
</li>
<li>
<p>XPath: optimized document order sorting</p>
</li>
<li>
<p>XPath: optimized child/attribute axis step</p>
</li>
<li>
<p>XPath: optimized number-to-string conversions in MSVC</p>
</li>
<li>
<p>XPath: optimized concat for many arguments</p>
</li>
<li>
<p>XPath: optimized evaluation allocation mechanism: constant and document strings are not heap-allocated</p>
</li>
<li>
<p>XPath: optimized evaluation allocation mechanism: all temporaries' allocations use fast stack-like allocator</p>
</li>
</ol>
</div>
</li>
<li>
<p>Compatibility:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Removed wildcard functions (<code>xml_node::child_w</code>, <code>xml_node::attribute_w</code>, etc.)</p>
</li>
<li>
<p>Removed <code>xml_node::all_elements_by_name</code></p>
</li>
<li>
<p>Removed <code>xpath_type_t</code> enumeration; use <code>xpath_value_type</code> instead</p>
</li>
<li>
<p>Removed <code>format_write_bom_utf8</code> enumeration; use <code>format_write_bom</code> instead</p>
</li>
<li>
<p>Removed <code>xml_document::precompute_document_order</code>, <code>xml_attribute::document_order</code> and <code>xml_node::document_order</code> functions; document order sort optimization is now automatic</p>
</li>
<li>
<p>Removed <code>xml_document::parse</code> functions and <code>transfer_ownership</code> struct; use <code>xml_document::load_buffer_inplace</code> and <code>xml_document::load_buffer_inplace_own</code> instead</p>
</li>
<li>
<p>Removed <code>as_utf16</code> function; use <code>as_wide</code> instead</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="v0.9"><a class="anchor" href="#v0.9"></a>v0.9 <sup>1.07.2010</sup></h3>
<div class="paragraph">
<p>Major release, featuring extended and improved Unicode support, miscellaneous performance improvements, bug fixes and more.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Major Unicode improvements:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Introduced encoding support (automatic/manual encoding detection on load, manual encoding selection on save, conversion from/to UTF8, UTF16 LE/BE, UTF32 LE/BE)</p>
</li>
<li>
<p>Introduced <code>wchar_t</code> mode (you can set <code>PUGIXML_WCHAR_MODE</code> define to switch pugixml internal encoding from UTF8 to <code>wchar_t</code>; all functions are switched to their Unicode variants)</p>
</li>
<li>
<p>Load/save functions now support wide streams</p>
</li>
</ol>
</div>
</li>
<li>
<p>Bug fixes:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Fixed document corruption on failed parsing bug</p>
</li>
<li>
<p>XPath string/number conversion improvements (increased precision, fixed crash for huge numbers)</p>
</li>
<li>
<p>Improved DOCTYPE parsing: now parser recognizes all well-formed DOCTYPE declarations</p>
</li>
<li>
<p>Fixed <code>xml_attribute::as_uint()</code> for large numbers (i.e. 2<sup>32</sup>-1)</p>
</li>
<li>
<p>Fixed <code>xml_node::first_element_by_path</code> for path components that are prefixes of node names, but are not exactly equal to them.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Specification changes:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>parse()</code> API changed to <code>load_buffer</code>/<code>load_buffer_inplace</code>/<code>load_buffer_inplace_own</code>; <code>load_buffer</code> APIs do not require zero-terminated strings.</p>
</li>
<li>
<p>Renamed <code>as_utf16</code> to <code>as_wide</code></p>
</li>
<li>
<p>Changed <code>xml_node::offset_debug</code> return type and <code>xml_parse_result::offset</code> type to <code>ptrdiff_t</code></p>
</li>
<li>
<p>Nodes/attributes with empty names are now printed as <code>:anonymous</code></p>
</li>
</ol>
</div>
</li>
<li>
<p>Performance improvements:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Optimized document parsing and saving</p>
</li>
<li>
<p>Changed internal memory management: internal allocator is used for both metadata and name/value data; allocated pages are deleted if all allocations from them are deleted</p>
</li>
<li>
<p>Optimized memory consumption: <code>sizeof(xml_node_struct)</code> reduced from 40 bytes to 32 bytes on x86</p>
</li>
<li>
<p>Optimized debug mode parsing/saving by order of magnitude</p>
</li>
</ol>
</div>
</li>
<li>
<p>Miscellaneous:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>All STL includes except <code>&lt;exception&gt;</code> in <code>pugixml.hpp</code> are replaced with forward declarations</p>
</li>
<li>
<p><code>xml_node::remove_child</code> and <code>xml_node::remove_attribute</code> now return the operation result</p>
</li>
</ol>
</div>
</li>
<li>
<p>Compatibility:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>parse()</code> and <code>as_utf16</code> are left for compatibility (these functions are deprecated and will be removed in version 1.0)</p>
</li>
<li>
<p>Wildcard functions, <code>document_order</code>/<code>precompute_document_order</code> functions, <code>all_elements_by_name</code> function and <code>format_write_bom_utf8</code> flag are deprecated and will be removed in version 1.0</p>
</li>
<li>
<p><code>xpath_type_t</code> enumeration was renamed to <code>xpath_value_type</code>; <code>xpath_type_t</code> is deprecated and will be removed in version 1.0</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="v0.5"><a class="anchor" href="#v0.5"></a>v0.5 <sup>8.11.2009</sup></h3>
<div class="paragraph">
<p>Major bugfix release. Changes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>XPath bugfixes:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Fixed <code>translate()</code>, <code>lang()</code> and <code>concat()</code> functions (infinite loops/crashes)</p>
</li>
<li>
<p>Fixed compilation of queries with empty literal strings (<code>""</code>)</p>
</li>
<li>
<p>Fixed axis tests: they never add empty nodes/attributes to the resulting node set now</p>
</li>
<li>
<p>Fixed string-value evaluation for node-set (the result excluded some text descendants)</p>
</li>
<li>
<p>Fixed <code>self::</code> axis (it behaved like <code>ancestor-or-self::</code>)</p>
</li>
<li>
<p>Fixed <code>following::</code> and <code>preceding::</code> axes (they included descendent and ancestor nodes, respectively)</p>
</li>
<li>
<p>Minor fix for <code>namespace-uri()</code> function (namespace declaration scope includes the parent element of namespace declaration attribute)</p>
</li>
<li>
<p>Some incorrect queries are no longer parsed now (i.e. <code>foo: *</code>)</p>
</li>
<li>
<p>Fixed <code>text()</code>/etc. node test parsing bug (i.e. <code>foo[text()]</code> failed to compile)</p>
</li>
<li>
<p>Fixed root step (<code>/</code>) - it now selects empty node set if query is evaluated on empty node</p>
</li>
<li>
<p>Fixed string to number conversion (<code>"123 "</code> converted to NaN, <code>"123 .456"</code> converted to 123.456 - now the results are 123 and NaN, respectively)</p>
</li>
<li>
<p>Node set copying now preserves sorted type; leads to better performance on some queries</p>
</li>
</ol>
</div>
</li>
<li>
<p>Miscellaneous bugfixes:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Fixed <code>xml_node::offset_debug</code> for PI nodes</p>
</li>
<li>
<p>Added empty attribute checks to <code>xml_node::remove_attribute</code></p>
</li>
<li>
<p>Fixed <code>node_pi</code> and <code>node_declaration</code> copying</p>
</li>
<li>
<p>Const-correctness fixes</p>
</li>
</ol>
</div>
</li>
<li>
<p>Specification changes:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>xpath_node::select_nodes()</code> and related functions now throw exception if expression return type is not node set (instead of assertion)</p>
</li>
<li>
<p><code>xml_node::traverse()</code> now sets depth to -1 for both <code>begin()</code> and <code>end()</code> callbacks (was 0 at <code>begin()</code> and -1 at <code>end()</code>)</p>
</li>
<li>
<p>In case of non-raw node printing a newline is output after PCDATA inside nodes if the PCDATA has siblings</p>
</li>
<li>
<p>UTF8 &#8594; <code>wchar_t</code> conversion now considers 5-byte UTF8-like sequences as invalid</p>
</li>
</ol>
</div>
</li>
<li>
<p>New features:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Added <code>xpath_node_set::operator[]</code> for index-based iteration</p>
</li>
<li>
<p>Added <code>xpath_query::return_type()</code></p>
</li>
<li>
<p>Added getter accessors for memory-management functions</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="v0.42"><a class="anchor" href="#v0.42"></a>v0.42 <sup>17.09.2009</sup></h3>
<div class="paragraph">
<p>Maintenance release. Changes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Bug fixes:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Fixed deallocation in case of custom allocation functions or if <code>delete[]</code> / <code>free</code> are incompatible</p>
</li>
<li>
<p>XPath parser fixed for incorrect queries (i.e. incorrect XPath queries should now always fail to compile)</p>
</li>
<li>
<p>Const-correctness fixes for <code>find_child_by_attribute</code></p>
</li>
<li>
<p>Improved compatibility (miscellaneous warning fixes, fixed <code>&lt;cstring&gt;</code> include dependency for GCC)</p>
</li>
<li>
<p>Fixed iterator begin/end and print function to work correctly for empty nodes</p>
</li>
</ol>
</div>
</li>
<li>
<p>New features:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Added <code>PUGIXML_API</code>/<code>PUGIXML_CLASS</code>/<code>PUGIXML_FUNCTION</code> configuration macros to control class/function attributes</p>
</li>
<li>
<p>Added <code>xml_attribute::set_value</code> overloads for different types</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="v0.41"><a class="anchor" href="#v0.41"></a>v0.41 <sup>8.02.2009</sup></h3>
<div class="paragraph">
<p>Maintenance release. Changes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Bug fixes:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Fixed bug with node printing (occasionally some content was not written to output stream)</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="v0.4"><a class="anchor" href="#v0.4"></a>v0.4 <sup>18.01.2009</sup></h3>
<div class="paragraph">
<p>Changes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Bug fixes:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Documentation fix in samples for <code>parse()</code> with manual lifetime control</p>
</li>
<li>
<p>Fixed document order sorting in XPath (it caused wrong order of nodes after <code>xpath_node_set::sort</code> and wrong results of some XPath queries)</p>
</li>
</ol>
</div>
</li>
<li>
<p>Node printing changes:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Single quotes are no longer escaped when printing nodes</p>
</li>
<li>
<p>Symbols in second half of ASCII table are no longer escaped when printing nodes; because of this, <code>format_utf8</code> flag is deleted as it&#8217;s no longer needed and <code>format_write_bom</code> is renamed to <code>format_write_bom_utf8</code>.</p>
</li>
<li>
<p>Reworked node printing - now it works via <code>xml_writer</code> interface; implementations for <code>FILE*</code> and <code>std::ostream</code> are available. As a side-effect, <code>xml_document::save_file</code> now works without STL.</p>
</li>
</ol>
</div>
</li>
<li>
<p>New features:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Added unsigned integer support for attributes (<code>xml_attribute::as_uint</code>, <code>xml_attribute::operator=</code>)</p>
</li>
<li>
<p>Now document declaration (<code>&lt;?xml &#8230;&#8203;?&gt;</code>) is parsed as node with type <code>node_declaration</code> when <code>parse_declaration</code> flag is specified (access to encoding/version is performed as if they were attributes, i.e. <code>doc.child("xml").attribute("version").as_float()</code>); corresponding flags for node printing were also added</p>
</li>
<li>
<p>Added support for custom memory management (see <code>set_memory_management_functions</code> for details)</p>
</li>
<li>
<p>Implemented node/attribute copying (see <code>xml_node::insert_copy_*</code> and <code>xml_node::append_copy</code> for details)</p>
</li>
<li>
<p>Added <code>find_child_by_attribute</code> and <code>find_child_by_attribute_w</code> to simplify parsing code in some cases (i.e. COLLADA files)</p>
</li>
<li>
<p>Added file offset information querying for debugging purposes (now you&#8217;re able to determine exact location of any <code>xml_node</code> in parsed file, see <code>xml_node::offset_debug</code> for details)</p>
</li>
<li>
<p>Improved error handling for parsing - now <code>load()</code>, <code>load_file()</code> and <code>parse()</code> return <code>xml_parse_result</code>, which contains error code and last parsed offset; this does not break old interface as <code>xml_parse_result</code> can be implicitly casted to <code>bool</code>.</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="v0.34"><a class="anchor" href="#v0.34"></a>v0.34 <sup>31.10.2007</sup></h3>
<div class="paragraph">
<p>Maintenance release. Changes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Bug fixes:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Fixed bug with loading from text-mode iostreams</p>
</li>
<li>
<p>Fixed leak when <code>transfer_ownership</code> is true and parsing is failing</p>
</li>
<li>
<p>Fixed bug in saving (<code>\r</code> and <code>\n</code> are now escaped in attribute values)</p>
</li>
<li>
<p>Renamed <code>free()</code> to <code>destroy()</code> - some macro conflicts were reported</p>
</li>
</ol>
</div>
</li>
<li>
<p>New features:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Improved compatibility (supported Digital Mars C&#43;&#43;, MSVC 6, CodeWarrior 8, PGI C&#43;&#43;, Comeau, supported PS3 and XBox360)</p>
</li>
<li>
<p><code>PUGIXML_NO_EXCEPTION</code> flag for platforms without exception handling</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="v0.3"><a class="anchor" href="#v0.3"></a>v0.3 <sup>21.02.2007</sup></h3>
<div class="paragraph">
<p>Refactored, reworked and improved version. Changes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Interface:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Added XPath</p>
</li>
<li>
<p>Added tree modification functions</p>
</li>
<li>
<p>Added no STL compilation mode</p>
</li>
<li>
<p>Added saving document to file</p>
</li>
<li>
<p>Refactored parsing flags</p>
</li>
<li>
<p>Removed <code>xml_parser</code> class in favor of <code>xml_document</code></p>
</li>
<li>
<p>Added transfer ownership parsing mode</p>
</li>
<li>
<p>Modified the way <code>xml_tree_walker</code> works</p>
</li>
<li>
<p>Iterators are now non-constant</p>
</li>
</ol>
</div>
</li>
<li>
<p>Implementation:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Support of several compilers and platforms</p>
</li>
<li>
<p>Refactored and sped up parsing core</p>
</li>
<li>
<p>Improved standard compliancy</p>
</li>
<li>
<p>Added XPath implementation</p>
</li>
<li>
<p>Fixed several bugs</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="v0.2"><a class="anchor" href="#v0.2"></a>v0.2 <sup>6.11.2006</sup></h3>
<div class="paragraph">
<p>First public release. Changes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Bug fixes:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Fixed <code>child_value()</code> (for empty nodes)</p>
</li>
<li>
<p>Fixed <code>xml_parser_impl</code> warning at W4</p>
</li>
</ol>
</div>
</li>
<li>
<p>New features:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Introduced <code>child_value(name)</code> and <code>child_value_w(name)</code></p>
</li>
<li>
<p><code>parse_eol_pcdata</code> and <code>parse_eol_attribute</code> flags + <code>parse_minimal</code> optimizations</p>
</li>
<li>
<p>Optimizations of <code>strconv_t</code></p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="v0.1"><a class="anchor" href="#v0.1"></a>v0.1 <sup>15.07.2006</sup></h3>
<div class="paragraph">
<p>First private release for testing purposes</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="apiref"><a class="anchor" href="#apiref"></a>10. API Reference</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is the reference for all macros, types, enumerations, classes and functions in pugixml. Each symbol is a link that leads to the relevant section of the manual.</p>
</div>
<div class="sect2">
<h3 id="apiref.macros"><a class="anchor" href="#apiref.macros"></a>10.1. Macros</h3>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-cp">#define <a href="#PUGIXML_WCHAR_MODE">PUGIXML_WCHAR_MODE</a></span>
<span class="tok-cp">#define <a href="#PUGIXML_COMPACT">PUGIXML_COMPACT</a></span>
<span class="tok-cp">#define <a href="#PUGIXML_NO_XPATH">PUGIXML_NO_XPATH</a></span>
<span class="tok-cp">#define <a href="#PUGIXML_NO_STL">PUGIXML_NO_STL</a></span>
<span class="tok-cp">#define <a href="#PUGIXML_NO_EXCEPTIONS">PUGIXML_NO_EXCEPTIONS</a></span>
<span class="tok-cp">#define <a href="#PUGIXML_API">PUGIXML_API</a></span>
<span class="tok-cp">#define <a href="#PUGIXML_CLASS">PUGIXML_CLASS</a></span>
<span class="tok-cp">#define <a href="#PUGIXML_FUNCTION">PUGIXML_FUNCTION</a></span>
<span class="tok-cp">#define <a href="#PUGIXML_MEMORY_PAGE_SIZE">PUGIXML_MEMORY_PAGE_SIZE</a></span>
<span class="tok-cp">#define <a href="#PUGIXML_MEMORY_OUTPUT_STACK">PUGIXML_MEMORY_OUTPUT_STACK</a></span>
<span class="tok-cp">#define <a href="#PUGIXML_MEMORY_XPATH_PAGE_SIZE">PUGIXML_MEMORY_XPATH_PAGE_SIZE</a></span>
<span class="tok-cp">#define <a href="#PUGIXML_HEADER_ONLY">PUGIXML_HEADER_ONLY</a></span>
<span class="tok-cp">#define <a href="#PUGIXML_HAS_LONG_LONG">PUGIXML_HAS_LONG_LONG</a></span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="apiref.types"><a class="anchor" href="#apiref.types"></a>10.2. Types</h3>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-k">typedef</span> <span class="tok-n">configuration</span><span class="tok-o">-</span><span class="tok-n">defined</span><span class="tok-o">-</span><span class="tok-n">type</span> <a href="#char_t">char_t</a><span class="tok-p">;</span>
<span class="tok-k">typedef</span> <span class="tok-n">configuration</span><span class="tok-o">-</span><span class="tok-n">defined</span><span class="tok-o">-</span><span class="tok-n">type</span> <a href="#string_t">string_t</a><span class="tok-p">;</span>
<span class="tok-k">typedef</span> <span class="tok-kt">void</span><span class="tok-o">*</span> <span class="tok-p">(</span><span class="tok-o">*</span><a href="#allocation_function">allocation_function</a><span class="tok-p">)(</span><span class="tok-kt">size_t</span> <span class="tok-n">size</span><span class="tok-p">);</span>
<span class="tok-k">typedef</span> <span class="tok-nf">void</span> <span class="tok-p">(</span><span class="tok-o">*</span><a href="#deallocation_function">deallocation_function</a><span class="tok-p">)(</span><span class="tok-kt">void</span><span class="tok-o">*</span> <span class="tok-n">ptr</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="apiref.enums"><a class="anchor" href="#apiref.enums"></a>10.3. Enumerations</h3>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-k">enum</span> <a href="#xml_node_type">xml_node_type</a>
    <a href="#node_null">node_null</a>
    <a href="#node_document">node_document</a>
    <a href="#node_element">node_element</a>
    <a href="#node_pcdata">node_pcdata</a>
    <a href="#node_cdata">node_cdata</a>
    <a href="#node_comment">node_comment</a>
    <a href="#node_pi">node_pi</a>
    <a href="#node_declaration">node_declaration</a>
    <a href="#node_doctype">node_doctype</a>

<span class="tok-k">enum</span> <a href="#xml_parse_status">xml_parse_status</a>
    <a href="#status_ok">status_ok</a>
    <a href="#status_file_not_found">status_file_not_found</a>
    <a href="#status_io_error">status_io_error</a>
    <a href="#status_out_of_memory">status_out_of_memory</a>
    <a href="#status_internal_error">status_internal_error</a>
    <a href="#status_unrecognized_tag">status_unrecognized_tag</a>
    <a href="#status_bad_pi">status_bad_pi</a>
    <a href="#status_bad_comment">status_bad_comment</a>
    <a href="#status_bad_cdata">status_bad_cdata</a>
    <a href="#status_bad_doctype">status_bad_doctype</a>
    <a href="#status_bad_pcdata">status_bad_pcdata</a>
    <a href="#status_bad_start_element">status_bad_start_element</a>
    <a href="#status_bad_attribute">status_bad_attribute</a>
    <a href="#status_bad_end_element">status_bad_end_element</a>
    <a href="#status_end_element_mismatch">status_end_element_mismatch</a>
    <a href="#status_append_invalid_root">status_append_invalid_root</a>
    <a href="#status_no_document_element">status_no_document_element</a>

<span class="tok-k">enum</span> <a href="#xml_encoding">xml_encoding</a>
    <a href="#encoding_auto">encoding_auto</a>
    <a href="#encoding_utf8">encoding_utf8</a>
    <a href="#encoding_utf16_le">encoding_utf16_le</a>
    <a href="#encoding_utf16_be">encoding_utf16_be</a>
    <a href="#encoding_utf16">encoding_utf16</a>
    <a href="#encoding_utf32_le">encoding_utf32_le</a>
    <a href="#encoding_utf32_be">encoding_utf32_be</a>
    <a href="#encoding_utf32">encoding_utf32</a>
    <a href="#encoding_wchar">encoding_wchar</a>
    <a href="#encoding_latin1">encoding_latin1</a>

<span class="tok-k">enum</span> <a href="#xpath_value_type">xpath_value_type</a>
    <a href="#xpath_type_none">xpath_type_none</a>
    <a href="#xpath_type_node_set">xpath_type_node_set</a>
    <a href="#xpath_type_number">xpath_type_number</a>
    <a href="#xpath_type_string">xpath_type_string</a>
    <a href="#xpath_type_boolean">xpath_type_boolean</a></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="apiref.constants"><a class="anchor" href="#apiref.constants"></a>10.4. Constants</h3>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-c1">// Formatting options bit flags:</span>
<span class="tok-k">const</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <a href="#format_default">format_default</a>
<span class="tok-k">const</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <a href="#format_indent">format_indent</a>
<span class="tok-k">const</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <a href="#format_indent_attributes">format_indent_attributes</a>
<span class="tok-k">const</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <a href="#format_no_declaration">format_no_declaration</a>
<span class="tok-k">const</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <a href="#format_no_escapes">format_no_escapes</a>
<span class="tok-k">const</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <a href="#format_raw">format_raw</a>
<span class="tok-k">const</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <a href="#format_save_file_text">format_save_file_text</a>
<span class="tok-k">const</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <a href="#format_write_bom">format_write_bom</a>

<span class="tok-c1">// Parsing options bit flags:</span>
<span class="tok-k">const</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <a href="#parse_cdata">parse_cdata</a>
<span class="tok-k">const</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <a href="#parse_comments">parse_comments</a>
<span class="tok-k">const</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <a href="#parse_declaration">parse_declaration</a>
<span class="tok-k">const</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <a href="#parse_default">parse_default</a>
<span class="tok-k">const</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <a href="#parse_doctype">parse_doctype</a>
<span class="tok-k">const</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <a href="#parse_eol">parse_eol</a>
<span class="tok-k">const</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <a href="#parse_escapes">parse_escapes</a>
<span class="tok-k">const</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <a href="#parse_fragment">parse_fragment</a>
<span class="tok-k">const</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <a href="#parse_full">parse_full</a>
<span class="tok-k">const</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <a href="#parse_minimal">parse_minimal</a>
<span class="tok-k">const</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <a href="#parse_pi">parse_pi</a>
<span class="tok-k">const</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <a href="#parse_trim_pcdata">parse_trim_pcdata</a>
<span class="tok-k">const</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <a href="#parse_ws_pcdata">parse_ws_pcdata</a>
<span class="tok-k">const</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <a href="#parse_ws_pcdata_single">parse_ws_pcdata_single</a>
<span class="tok-k">const</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <a href="#parse_wconv_attribute">parse_wconv_attribute</a>
<span class="tok-k">const</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <a href="#parse_wnorm_attribute">parse_wnorm_attribute</a></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="apiref.classes"><a class="anchor" href="#apiref.classes"></a>10.5. Classes</h3>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-k">class</span> <a href="#xml_attribute">xml_attribute</a>
    <a href="#xml_attribute::ctor">xml_attribute</a><span class="tok-p">();</span>

    <span class="tok-kt">bool</span> <a href="#xml_attribute::empty">empty</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-k">operator</span> <a href="#xml_attribute::unspecified_bool_type">unspecified_bool_type</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>

    <span class="tok-kt">bool</span> <a href="#xml_attribute::comparison">operator==</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xml_attribute</span><span class="tok-o">&amp;</span> <span class="tok-n">r</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-kt">bool</span> <a href="#xml_attribute::comparison">operator!=</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xml_attribute</span><span class="tok-o">&amp;</span> <span class="tok-n">r</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-kt">bool</span> <a href="#xml_attribute::comparison">operator&lt;</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xml_attribute</span><span class="tok-o">&amp;</span> <span class="tok-n">r</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-kt">bool</span> <a href="#xml_attribute::comparison">operator&gt;</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xml_attribute</span><span class="tok-o">&amp;</span> <span class="tok-n">r</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-kt">bool</span> <a href="#xml_attribute::comparison">operator&lt;=</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xml_attribute</span><span class="tok-o">&amp;</span> <span class="tok-n">r</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-kt">bool</span> <a href="#xml_attribute::comparison">operator&gt;=</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xml_attribute</span><span class="tok-o">&amp;</span> <span class="tok-n">r</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>

    <span class="tok-kt">size_t</span> <a href="#xml_attribute::hash_value">hash_value</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>

    <span class="tok-n">xml_attribute</span> <a href="#xml_attribute::next_attribute">next_attribute</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-n">xml_attribute</span> <a href="#xml_attribute::previous_attribute">previous_attribute</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>

    <span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <a href="#xml_attribute::name">name</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <a href="#xml_attribute::value">value</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>

    <span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <a href="#xml_attribute::as_string">as_string</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">def</span> <span class="tok-o">=</span> <span class="tok-s">&quot;&quot;</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-kt">int</span> <a href="#xml_attribute::as_int">as_int</a><span class="tok-p">(</span><span class="tok-kt">int</span> <span class="tok-n">def</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <a href="#xml_attribute::as_uint">as_uint</a><span class="tok-p">(</span><span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">def</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-kt">double</span> <a href="#xml_attribute::as_double">as_double</a><span class="tok-p">(</span><span class="tok-kt">double</span> <span class="tok-n">def</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-kt">float</span> <a href="#xml_attribute::as_float">as_float</a><span class="tok-p">(</span><span class="tok-kt">float</span> <span class="tok-n">def</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-kt">bool</span> <a href="#xml_attribute::as_bool">as_bool</a><span class="tok-p">(</span><span class="tok-kt">bool</span> <span class="tok-n">def</span> <span class="tok-o">=</span> <span class="tok-nb">false</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-kt">long</span> <span class="tok-kt">long</span> <a href="#xml_attribute::as_llong">as_llong</a><span class="tok-p">(</span><span class="tok-kt">long</span> <span class="tok-kt">long</span> <span class="tok-n">def</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-kt">unsigned</span> <span class="tok-kt">long</span> <span class="tok-kt">long</span> <a href="#xml_attribute::as_ullong">as_ullong</a><span class="tok-p">(</span><span class="tok-kt">unsigned</span> <span class="tok-kt">long</span> <span class="tok-kt">long</span> <span class="tok-n">def</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>

    <span class="tok-kt">bool</span> <a href="#xml_attribute::set_name">set_name</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
    <span class="tok-kt">bool</span> <a href="#xml_attribute::set_value">set_value</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
    <span class="tok-kt">bool</span> <a href="#xml_attribute::set_value">set_value</a><span class="tok-p">(</span><span class="tok-kt">int</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
    <span class="tok-kt">bool</span> <a href="#xml_attribute::set_value">set_value</a><span class="tok-p">(</span><span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
    <span class="tok-kt">bool</span> <a href="#xml_attribute::set_value">set_value</a><span class="tok-p">(</span><span class="tok-kt">double</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
    <span class="tok-kt">bool</span> <a href="#xml_attribute::set_value">set_value</a><span class="tok-p">(</span><span class="tok-kt">float</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
    <span class="tok-kt">bool</span> <a href="#xml_attribute::set_value">set_value</a><span class="tok-p">(</span><span class="tok-kt">bool</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
    <span class="tok-kt">bool</span> <a href="#xml_attribute::set_value">set_value</a><span class="tok-p">(</span><span class="tok-kt">long</span> <span class="tok-kt">long</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
    <span class="tok-kt">bool</span> <a href="#xml_attribute::set_value">set_value</a><span class="tok-p">(</span><span class="tok-kt">unsigned</span> <span class="tok-kt">long</span> <span class="tok-kt">long</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>

    <span class="tok-n">xml_attribute</span><span class="tok-o">&amp;</span> <a href="#xml_attribute::assign">operator=</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
    <span class="tok-n">xml_attribute</span><span class="tok-o">&amp;</span> <a href="#xml_attribute::assign">operator=</a><span class="tok-p">(</span><span class="tok-kt">int</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
    <span class="tok-n">xml_attribute</span><span class="tok-o">&amp;</span> <a href="#xml_attribute::assign">operator=</a><span class="tok-p">(</span><span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
    <span class="tok-n">xml_attribute</span><span class="tok-o">&amp;</span> <a href="#xml_attribute::assign">operator=</a><span class="tok-p">(</span><span class="tok-kt">double</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
    <span class="tok-n">xml_attribute</span><span class="tok-o">&amp;</span> <a href="#xml_attribute::assign">operator=</a><span class="tok-p">(</span><span class="tok-kt">float</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
    <span class="tok-n">xml_attribute</span><span class="tok-o">&amp;</span> <a href="#xml_attribute::assign">operator=</a><span class="tok-p">(</span><span class="tok-kt">bool</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
    <span class="tok-n">xml_attribute</span><span class="tok-o">&amp;</span> <a href="#xml_attribute::assign">operator=</a><span class="tok-p">(</span><span class="tok-kt">long</span> <span class="tok-kt">long</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
    <span class="tok-n">xml_attribute</span><span class="tok-o">&amp;</span> <a href="#xml_attribute::assign">operator=</a><span class="tok-p">(</span><span class="tok-n">unsnigned</span> <span class="tok-kt">long</span> <span class="tok-kt">long</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>

<span class="tok-k">class</span> <a href="#xml_node">xml_node</a>
    <a href="#xml_node::ctor">xml_node</a><span class="tok-p">();</span>

    <span class="tok-kt">bool</span> <a href="#xml_node::empty">empty</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-k">operator</span> <a href="#xml_node::unspecified_bool_type">unspecified_bool_type</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>

    <span class="tok-kt">bool</span> <a href="#xml_node::comparison">operator==</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xml_node</span><span class="tok-o">&amp;</span> <span class="tok-n">r</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-kt">bool</span> <a href="#xml_node::comparison">operator!=</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xml_node</span><span class="tok-o">&amp;</span> <span class="tok-n">r</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-kt">bool</span> <a href="#xml_node::comparison">operator&lt;</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xml_node</span><span class="tok-o">&amp;</span> <span class="tok-n">r</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-kt">bool</span> <a href="#xml_node::comparison">operator&gt;</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xml_node</span><span class="tok-o">&amp;</span> <span class="tok-n">r</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-kt">bool</span> <a href="#xml_node::comparison">operator&lt;=</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xml_node</span><span class="tok-o">&amp;</span> <span class="tok-n">r</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-kt">bool</span> <a href="#xml_node::comparison">operator&gt;=</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xml_node</span><span class="tok-o">&amp;</span> <span class="tok-n">r</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>

    <span class="tok-kt">size_t</span> <a href="#xml_node::hash_value">hash_value</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>

    <span class="tok-n">xml_node_type</span> <a href="#xml_node::type">type</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>

    <span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <a href="#xml_node::name">name</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <a href="#xml_node::value">value</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>

    <span class="tok-n">xml_node</span> <a href="#xml_node::parent">parent</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-n">xml_node</span> <a href="#xml_node::first_child">first_child</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-n">xml_node</span> <a href="#xml_node::last_child">last_child</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-n">xml_node</span> <a href="#xml_node::next_sibling">next_sibling</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-n">xml_node</span> <a href="#xml_node::previous_sibling">previous_sibling</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>

    <span class="tok-n">xml_attribute</span> <a href="#xml_node::first_attribute">first_attribute</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-n">xml_attribute</span> <a href="#xml_node::last_attribute">last_attribute</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>

    <span class="tok-n">implementation</span><span class="tok-o">-</span><span class="tok-n">defined</span><span class="tok-o">-</span><span class="tok-n">type</span> <a href="#xml_node::children">children</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-n">implementation</span><span class="tok-o">-</span><span class="tok-n">defined</span><span class="tok-o">-</span><span class="tok-n">type</span> <a href="#xml_node::children">children</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">name</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-n">implementation</span><span class="tok-o">-</span><span class="tok-n">defined</span><span class="tok-o">-</span><span class="tok-n">type</span> <a href="#xml_node::attributes">attributes</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>

    <span class="tok-n">xml_node</span> <a href="#xml_node::child">child</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">name</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-n">xml_attribute</span> <a href="#xml_node::attribute">attribute</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">name</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-n">xml_node</span> <a href="#xml_node::next_sibling_name">next_sibling</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">name</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-n">xml_node</span> <a href="#xml_node::previous_sibling_name">previous_sibling</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">name</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-n">xml_node</span> <a href="#xml_node::find_child_by_attribute">find_child_by_attribute</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">name</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">attr_name</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">attr_value</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-n">xml_node</span> <a href="#xml_node::find_child_by_attribute">find_child_by_attribute</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">attr_name</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">attr_value</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>

    <span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <a href="#xml_node::child_value">child_value</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <a href="#xml_node::child_value">child_value</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">name</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-n">xml_text</span> <a href="#xml_node::text">text</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>

    <span class="tok-k">typedef</span> <span class="tok-n">xml_node_iterator</span> <a href="#xml_node_iterator">iterator</a><span class="tok-p">;</span>
    <span class="tok-n">iterator</span> <a href="#xml_node::begin">begin</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-n">iterator</span> <a href="#xml_node::end">end</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>

    <span class="tok-k">typedef</span> <span class="tok-n">xml_attribute_iterator</span> <a href="#xml_attribute_iterator">attribute_iterator</a><span class="tok-p">;</span>
    <span class="tok-n">attribute_iterator</span> <a href="#xml_node::attributes_begin">attributes_begin</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-n">attribute_iterator</span> <a href="#xml_node::attributes_end">attributes_end</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>

    <span class="tok-kt">bool</span> <a href="#xml_node::traverse">traverse</a><span class="tok-p">(</span><span class="tok-n">xml_tree_walker</span><span class="tok-o">&amp;</span> <span class="tok-n">walker</span><span class="tok-p">);</span>

    <span class="tok-k">template</span> <span class="tok-o">&lt;</span><span class="tok-k">typename</span> <span class="tok-n">Predicate</span><span class="tok-o">&gt;</span> <span class="tok-n">xml_attribute</span> <a href="#xml_node::find_attribute">find_attribute</a><span class="tok-p">(</span><span class="tok-n">Predicate</span> <span class="tok-n">pred</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-k">template</span> <span class="tok-o">&lt;</span><span class="tok-k">typename</span> <span class="tok-n">Predicate</span><span class="tok-o">&gt;</span> <span class="tok-n">xml_node</span> <a href="#xml_node::find_child">find_child</a><span class="tok-p">(</span><span class="tok-n">Predicate</span> <span class="tok-n">pred</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-k">template</span> <span class="tok-o">&lt;</span><span class="tok-k">typename</span> <span class="tok-n">Predicate</span><span class="tok-o">&gt;</span> <span class="tok-n">xml_node</span> <a href="#xml_node::find_node">find_node</a><span class="tok-p">(</span><span class="tok-n">Predicate</span> <span class="tok-n">pred</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>

    <span class="tok-kt">string_t</span> <a href="#xml_node::path">path</a><span class="tok-p">(</span><span class="tok-kt">char_t</span> <span class="tok-n">delimiter</span> <span class="tok-o">=</span> <span class="tok-sc">&#39;/&#39;</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-n">xml_node</span> <a href="#xml_node::first_element_by_path">xml_node::first_element_by_path</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">path</span><span class="tok-p">,</span> <span class="tok-kt">char_t</span> <span class="tok-n">delimiter</span> <span class="tok-o">=</span> <span class="tok-sc">&#39;/&#39;</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-n">xml_node</span> <a href="#xml_node::root">root</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-kt">ptrdiff_t</span> <a href="#xml_node::offset_debug">offset_debug</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>

    <span class="tok-kt">bool</span> <a href="#xml_node::set_name">set_name</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
    <span class="tok-kt">bool</span> <a href="#xml_node::set_value">set_value</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>

    <span class="tok-n">xml_attribute</span> <a href="#xml_node::append_attribute">append_attribute</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">name</span><span class="tok-p">);</span>
    <span class="tok-n">xml_attribute</span> <a href="#xml_node::prepend_attribute">prepend_attribute</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">name</span><span class="tok-p">);</span>
    <span class="tok-n">xml_attribute</span> <a href="#xml_node::insert_attribute_after">insert_attribute_after</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">name</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-n">xml_attribute</span><span class="tok-o">&amp;</span> <span class="tok-n">attr</span><span class="tok-p">);</span>
    <span class="tok-n">xml_attribute</span> <a href="#xml_node::insert_attribute_before">insert_attribute_before</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">name</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-n">xml_attribute</span><span class="tok-o">&amp;</span> <span class="tok-n">attr</span><span class="tok-p">);</span>

    <span class="tok-n">xml_node</span> <a href="#xml_node::append_child">append_child</a><span class="tok-p">(</span><span class="tok-n">xml_node_type</span> <span class="tok-n">type</span> <span class="tok-o">=</span> <span class="tok-n">node_element</span><span class="tok-p">);</span>
    <span class="tok-n">xml_node</span> <a href="#xml_node::prepend_child">prepend_child</a><span class="tok-p">(</span><span class="tok-n">xml_node_type</span> <span class="tok-n">type</span> <span class="tok-o">=</span> <span class="tok-n">node_element</span><span class="tok-p">);</span>
    <span class="tok-n">xml_node</span> <a href="#xml_node::insert_child_after">insert_child_after</a><span class="tok-p">(</span><span class="tok-n">xml_node_type</span> <span class="tok-n">type</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-n">xml_node</span><span class="tok-o">&amp;</span> <span class="tok-n">node</span><span class="tok-p">);</span>
    <span class="tok-n">xml_node</span> <a href="#xml_node::insert_child_before">insert_child_before</a><span class="tok-p">(</span><span class="tok-n">xml_node_type</span> <span class="tok-n">type</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-n">xml_node</span><span class="tok-o">&amp;</span> <span class="tok-n">node</span><span class="tok-p">);</span>

    <span class="tok-n">xml_node</span> <a href="#xml_node::append_child">append_child</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">name</span><span class="tok-p">);</span>
    <span class="tok-n">xml_node</span> <a href="#xml_node::prepend_child">prepend_child</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">name</span><span class="tok-p">);</span>
    <span class="tok-n">xml_node</span> <a href="#xml_node::insert_child_after">insert_child_after</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">name</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-n">xml_node</span><span class="tok-o">&amp;</span> <span class="tok-n">node</span><span class="tok-p">);</span>
    <span class="tok-n">xml_node</span> <a href="#xml_node::insert_child_before">insert_child_before</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">name</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-n">xml_node</span><span class="tok-o">&amp;</span> <span class="tok-n">node</span><span class="tok-p">);</span>

    <span class="tok-n">xml_attribute</span> <a href="#xml_node::append_copy">append_copy</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xml_attribute</span><span class="tok-o">&amp;</span> <span class="tok-n">proto</span><span class="tok-p">);</span>
    <span class="tok-n">xml_attribute</span> <a href="#xml_node::prepend_copy">prepend_copy</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xml_attribute</span><span class="tok-o">&amp;</span> <span class="tok-n">proto</span><span class="tok-p">);</span>
    <span class="tok-n">xml_attribute</span> <a href="#xml_node::insert_copy_after">insert_copy_after</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xml_attribute</span><span class="tok-o">&amp;</span> <span class="tok-n">proto</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-n">xml_attribute</span><span class="tok-o">&amp;</span> <span class="tok-n">attr</span><span class="tok-p">);</span>
    <span class="tok-n">xml_attribute</span> <a href="#xml_node::insert_copy_before">insert_copy_before</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xml_attribute</span><span class="tok-o">&amp;</span> <span class="tok-n">proto</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-n">xml_attribute</span><span class="tok-o">&amp;</span> <span class="tok-n">attr</span><span class="tok-p">);</span>

    <span class="tok-n">xml_node</span> <a href="#xml_node::append_copy">append_copy</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xml_node</span><span class="tok-o">&amp;</span> <span class="tok-n">proto</span><span class="tok-p">);</span>
    <span class="tok-n">xml_node</span> <a href="#xml_node::prepend_copy">prepend_copy</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xml_node</span><span class="tok-o">&amp;</span> <span class="tok-n">proto</span><span class="tok-p">);</span>
    <span class="tok-n">xml_node</span> <a href="#xml_node::insert_copy_after">insert_copy_after</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xml_node</span><span class="tok-o">&amp;</span> <span class="tok-n">proto</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-n">xml_node</span><span class="tok-o">&amp;</span> <span class="tok-n">node</span><span class="tok-p">);</span>
    <span class="tok-n">xml_node</span> <a href="#xml_node::insert_copy_before">insert_copy_before</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xml_node</span><span class="tok-o">&amp;</span> <span class="tok-n">proto</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-n">xml_node</span><span class="tok-o">&amp;</span> <span class="tok-n">node</span><span class="tok-p">);</span>

    <span class="tok-n">xml_node</span> <a href="#xml_node::append_move">append_move</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xml_node</span><span class="tok-o">&amp;</span> <span class="tok-n">moved</span><span class="tok-p">);</span>
    <span class="tok-n">xml_node</span> <a href="#xml_node::prepend_move">prepend_move</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xml_node</span><span class="tok-o">&amp;</span> <span class="tok-n">moved</span><span class="tok-p">);</span>
    <span class="tok-n">xml_node</span> <a href="#xml_node::insert_move_after">insert_move_after</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xml_node</span><span class="tok-o">&amp;</span> <span class="tok-n">moved</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-n">xml_node</span><span class="tok-o">&amp;</span> <span class="tok-n">node</span><span class="tok-p">);</span>
    <span class="tok-n">xml_node</span> <a href="#xml_node::insert_move_before">insert_move_before</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xml_node</span><span class="tok-o">&amp;</span> <span class="tok-n">moved</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-n">xml_node</span><span class="tok-o">&amp;</span> <span class="tok-n">node</span><span class="tok-p">);</span>

    <span class="tok-kt">bool</span> <a href="#xml_node::remove_attribute">remove_attribute</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xml_attribute</span><span class="tok-o">&amp;</span> <span class="tok-n">a</span><span class="tok-p">);</span>
    <span class="tok-kt">bool</span> <a href="#xml_node::remove_attribute">remove_attribute</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">name</span><span class="tok-p">);</span>
    <span class="tok-kt">bool</span> <a href="#xml_node::remove_child">remove_child</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xml_node</span><span class="tok-o">&amp;</span> <span class="tok-n">n</span><span class="tok-p">);</span>
    <span class="tok-kt">bool</span> <a href="#xml_node::remove_child">remove_child</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">name</span><span class="tok-p">);</span>

    <span class="tok-n">xml_parse_result</span> <a href="#xml_node::append_buffer">append_buffer</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">void</span><span class="tok-o">*</span> <span class="tok-n">contents</span><span class="tok-p">,</span> <span class="tok-kt">size_t</span> <span class="tok-n">size</span><span class="tok-p">,</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">options</span> <span class="tok-o">=</span> <span class="tok-n">parse_default</span><span class="tok-p">,</span> <span class="tok-n">xml_encoding</span> <span class="tok-n">encoding</span> <span class="tok-o">=</span> <span class="tok-n">encoding_auto</span><span class="tok-p">);</span>

    <span class="tok-kt">void</span> <a href="#xml_node::print">print</a><span class="tok-p">(</span><span class="tok-n">xml_writer</span><span class="tok-o">&amp;</span> <span class="tok-n">writer</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">indent</span> <span class="tok-o">=</span> <span class="tok-s">&quot;</span><span class="tok-se">\t</span><span class="tok-s">&quot;</span><span class="tok-p">,</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">flags</span> <span class="tok-o">=</span> <span class="tok-n">format_default</span><span class="tok-p">,</span> <span class="tok-n">xml_encoding</span> <span class="tok-n">encoding</span> <span class="tok-o">=</span> <span class="tok-n">encoding_auto</span><span class="tok-p">,</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">depth</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-kt">void</span> <a href="#xml_node::print_stream">print</a><span class="tok-p">(</span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">ostream</span><span class="tok-o">&amp;</span> <span class="tok-n">os</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">indent</span> <span class="tok-o">=</span> <span class="tok-s">&quot;</span><span class="tok-se">\t</span><span class="tok-s">&quot;</span><span class="tok-p">,</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">flags</span> <span class="tok-o">=</span> <span class="tok-n">format_default</span><span class="tok-p">,</span> <span class="tok-n">xml_encoding</span> <span class="tok-n">encoding</span> <span class="tok-o">=</span> <span class="tok-n">encoding_auto</span><span class="tok-p">,</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">depth</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-kt">void</span> <a href="#xml_node::print_stream">print</a><span class="tok-p">(</span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">wostream</span><span class="tok-o">&amp;</span> <span class="tok-n">os</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">indent</span> <span class="tok-o">=</span> <span class="tok-s">&quot;</span><span class="tok-se">\t</span><span class="tok-s">&quot;</span><span class="tok-p">,</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">flags</span> <span class="tok-o">=</span> <span class="tok-n">format_default</span><span class="tok-p">,</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">depth</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>

    <span class="tok-n">xpath_node</span> <a href="#xml_node::select_node">select_node</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">query</span><span class="tok-p">,</span> <span class="tok-n">xpath_variable_set</span><span class="tok-o">*</span> <span class="tok-n">variables</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-n">xpath_node</span> <a href="#xml_node::select_node_precomp">select_node</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xpath_query</span><span class="tok-o">&amp;</span> <span class="tok-n">query</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-n">xpath_node_set</span> <a href="#xml_node::select_nodes">select_nodes</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">query</span><span class="tok-p">,</span> <span class="tok-n">xpath_variable_set</span><span class="tok-o">*</span> <span class="tok-n">variables</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-n">xpath_node_set</span> <a href="#xml_node::select_nodes_precomp">select_nodes</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xpath_query</span><span class="tok-o">&amp;</span> <span class="tok-n">query</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>

<span class="tok-k">class</span> <a href="#xml_document">xml_document</a>
    <a href="#xml_document::ctor">xml_document</a><span class="tok-p">();</span>
    <span class="tok-o">~</span><a href="#xml_document::dtor">xml_document</a><span class="tok-p">();</span>

    <span class="tok-kt">void</span> <a href="#xml_document::reset">reset</a><span class="tok-p">();</span>
    <span class="tok-kt">void</span> <a href="#xml_document::reset">reset</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xml_document</span><span class="tok-o">&amp;</span> <span class="tok-n">proto</span><span class="tok-p">);</span>

    <span class="tok-n">xml_parse_result</span> <a href="#xml_document::load_stream">load</a><span class="tok-p">(</span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">istream</span><span class="tok-o">&amp;</span> <span class="tok-n">stream</span><span class="tok-p">,</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">options</span> <span class="tok-o">=</span> <span class="tok-n">parse_default</span><span class="tok-p">,</span> <span class="tok-n">xml_encoding</span> <span class="tok-n">encoding</span> <span class="tok-o">=</span> <span class="tok-n">encoding_auto</span><span class="tok-p">);</span>
    <span class="tok-n">xml_parse_result</span> <a href="#xml_document::load_stream">load</a><span class="tok-p">(</span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">wistream</span><span class="tok-o">&amp;</span> <span class="tok-n">stream</span><span class="tok-p">,</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">options</span> <span class="tok-o">=</span> <span class="tok-n">parse_default</span><span class="tok-p">);</span>

    <span class="tok-n">xml_parse_result</span> <a href="#xml_document::load_string">load_string</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">contents</span><span class="tok-p">,</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">options</span> <span class="tok-o">=</span> <span class="tok-n">parse_default</span><span class="tok-p">);</span>

    <span class="tok-n">xml_parse_result</span> <a href="#xml_document::load_file">load_file</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char</span><span class="tok-o">*</span> <span class="tok-n">path</span><span class="tok-p">,</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">options</span> <span class="tok-o">=</span> <span class="tok-n">parse_default</span><span class="tok-p">,</span> <span class="tok-n">xml_encoding</span> <span class="tok-n">encoding</span> <span class="tok-o">=</span> <span class="tok-n">encoding_auto</span><span class="tok-p">);</span>
    <span class="tok-n">xml_parse_result</span> <a href="#xml_document::load_file_wide">load_file</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">wchar_t</span><span class="tok-o">*</span> <span class="tok-n">path</span><span class="tok-p">,</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">options</span> <span class="tok-o">=</span> <span class="tok-n">parse_default</span><span class="tok-p">,</span> <span class="tok-n">xml_encoding</span> <span class="tok-n">encoding</span> <span class="tok-o">=</span> <span class="tok-n">encoding_auto</span><span class="tok-p">);</span>

    <span class="tok-n">xml_parse_result</span> <a href="#xml_document::load_buffer">load_buffer</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">void</span><span class="tok-o">*</span> <span class="tok-n">contents</span><span class="tok-p">,</span> <span class="tok-kt">size_t</span> <span class="tok-n">size</span><span class="tok-p">,</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">options</span> <span class="tok-o">=</span> <span class="tok-n">parse_default</span><span class="tok-p">,</span> <span class="tok-n">xml_encoding</span> <span class="tok-n">encoding</span> <span class="tok-o">=</span> <span class="tok-n">encoding_auto</span><span class="tok-p">);</span>
    <span class="tok-n">xml_parse_result</span> <a href="#xml_document::load_buffer_inplace">load_buffer_inplace</a><span class="tok-p">(</span><span class="tok-kt">void</span><span class="tok-o">*</span> <span class="tok-n">contents</span><span class="tok-p">,</span> <span class="tok-kt">size_t</span> <span class="tok-n">size</span><span class="tok-p">,</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">options</span> <span class="tok-o">=</span> <span class="tok-n">parse_default</span><span class="tok-p">,</span> <span class="tok-n">xml_encoding</span> <span class="tok-n">encoding</span> <span class="tok-o">=</span> <span class="tok-n">encoding_auto</span><span class="tok-p">);</span>
    <span class="tok-n">xml_parse_result</span> <a href="#xml_document::load_buffer_inplace_own">load_buffer_inplace_own</a><span class="tok-p">(</span><span class="tok-kt">void</span><span class="tok-o">*</span> <span class="tok-n">contents</span><span class="tok-p">,</span> <span class="tok-kt">size_t</span> <span class="tok-n">size</span><span class="tok-p">,</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">options</span> <span class="tok-o">=</span> <span class="tok-n">parse_default</span><span class="tok-p">,</span> <span class="tok-n">xml_encoding</span> <span class="tok-n">encoding</span> <span class="tok-o">=</span> <span class="tok-n">encoding_auto</span><span class="tok-p">);</span>

    <span class="tok-kt">bool</span> <a href="#xml_document::save_file">save_file</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char</span><span class="tok-o">*</span> <span class="tok-n">path</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">indent</span> <span class="tok-o">=</span> <span class="tok-s">&quot;</span><span class="tok-se">\t</span><span class="tok-s">&quot;</span><span class="tok-p">,</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">flags</span> <span class="tok-o">=</span> <span class="tok-n">format_default</span><span class="tok-p">,</span> <span class="tok-n">xml_encoding</span> <span class="tok-n">encoding</span> <span class="tok-o">=</span> <span class="tok-n">encoding_auto</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-kt">bool</span> <a href="#xml_document::save_file_wide">save_file</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">wchar_t</span><span class="tok-o">*</span> <span class="tok-n">path</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">indent</span> <span class="tok-o">=</span> <span class="tok-s">&quot;</span><span class="tok-se">\t</span><span class="tok-s">&quot;</span><span class="tok-p">,</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">flags</span> <span class="tok-o">=</span> <span class="tok-n">format_default</span><span class="tok-p">,</span> <span class="tok-n">xml_encoding</span> <span class="tok-n">encoding</span> <span class="tok-o">=</span> <span class="tok-n">encoding_auto</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>

    <span class="tok-kt">void</span> <a href="#xml_document::save_stream">save</a><span class="tok-p">(</span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">ostream</span><span class="tok-o">&amp;</span> <span class="tok-n">stream</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">indent</span> <span class="tok-o">=</span> <span class="tok-s">&quot;</span><span class="tok-se">\t</span><span class="tok-s">&quot;</span><span class="tok-p">,</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">flags</span> <span class="tok-o">=</span> <span class="tok-n">format_default</span><span class="tok-p">,</span> <span class="tok-n">xml_encoding</span> <span class="tok-n">encoding</span> <span class="tok-o">=</span> <span class="tok-n">encoding_auto</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-kt">void</span> <a href="#xml_document::save_stream">save</a><span class="tok-p">(</span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">wostream</span><span class="tok-o">&amp;</span> <span class="tok-n">stream</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">indent</span> <span class="tok-o">=</span> <span class="tok-s">&quot;</span><span class="tok-se">\t</span><span class="tok-s">&quot;</span><span class="tok-p">,</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">flags</span> <span class="tok-o">=</span> <span class="tok-n">format_default</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>

    <span class="tok-kt">void</span> <a href="#xml_document::save">save</a><span class="tok-p">(</span><span class="tok-n">xml_writer</span><span class="tok-o">&amp;</span> <span class="tok-n">writer</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">indent</span> <span class="tok-o">=</span> <span class="tok-s">&quot;</span><span class="tok-se">\t</span><span class="tok-s">&quot;</span><span class="tok-p">,</span> <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">flags</span> <span class="tok-o">=</span> <span class="tok-n">format_default</span><span class="tok-p">,</span> <span class="tok-n">xml_encoding</span> <span class="tok-n">encoding</span> <span class="tok-o">=</span> <span class="tok-n">encoding_auto</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>

    <span class="tok-n">xml_node</span> <a href="#xml_document::document_element">document_element</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>

<span class="tok-k">struct</span> <a href="#xml_parse_result">xml_parse_result</a>
    <span class="tok-n">xml_parse_status</span> <a href="#xml_parse_result::status">status</a><span class="tok-p">;</span>
    <span class="tok-kt">ptrdiff_t</span> <a href="#xml_parse_result::offset">offset</a><span class="tok-p">;</span>
    <span class="tok-n">xml_encoding</span> <a href="#xml_parse_result::encoding">encoding</a><span class="tok-p">;</span>

    <span class="tok-k">operator</span> <a href="#xml_parse_result::bool">bool</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-k">const</span> <span class="tok-kt">char</span><span class="tok-o">*</span> <a href="#xml_parse_result::description">description</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>

<span class="tok-k">class</span> <a href="#xml_node_iterator">xml_node_iterator</a>
<span class="tok-k">class</span> <a href="#xml_attribute_iterator">xml_attribute_iterator</a>

<span class="tok-k">class</span> <a href="#xml_tree_walker">xml_tree_walker</a>
    <span class="tok-k">virtual</span> <span class="tok-kt">bool</span> <a href="#xml_tree_walker::begin">begin</a><span class="tok-p">(</span><span class="tok-n">xml_node</span><span class="tok-o">&amp;</span> <span class="tok-n">node</span><span class="tok-p">);</span>
    <span class="tok-k">virtual</span> <span class="tok-kt">bool</span> <a href="#xml_tree_walker::for_each">for_each</a><span class="tok-p">(</span><span class="tok-n">xml_node</span><span class="tok-o">&amp;</span> <span class="tok-n">node</span><span class="tok-p">)</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">;</span>
    <span class="tok-k">virtual</span> <span class="tok-kt">bool</span> <a href="#xml_tree_walker::end">end</a><span class="tok-p">(</span><span class="tok-n">xml_node</span><span class="tok-o">&amp;</span> <span class="tok-n">node</span><span class="tok-p">);</span>

    <span class="tok-kt">int</span> <a href="#xml_tree_walker::depth">depth</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>

<span class="tok-k">class</span> <a href="#xml_text">xml_text</a>
    <span class="tok-kt">bool</span> <a href="#xml_text::empty">empty</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-k">operator</span> <a href="#xml_text::unspecified_bool_type">xml_text::unspecified_bool_type</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>

    <span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <a href="#xml_text::get">xml_text::get</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>

    <span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <a href="#xml_text::as_string">as_string</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">def</span> <span class="tok-o">=</span> <span class="tok-s">&quot;&quot;</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-kt">int</span> <a href="#xml_text::as_int">as_int</a><span class="tok-p">(</span><span class="tok-kt">int</span> <span class="tok-n">def</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <a href="#xml_text::as_uint">as_uint</a><span class="tok-p">(</span><span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">def</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-kt">double</span> <a href="#xml_text::as_double">as_double</a><span class="tok-p">(</span><span class="tok-kt">double</span> <span class="tok-n">def</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-kt">float</span> <a href="#xml_text::as_float">as_float</a><span class="tok-p">(</span><span class="tok-kt">float</span> <span class="tok-n">def</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-kt">bool</span> <a href="#xml_text::as_bool">as_bool</a><span class="tok-p">(</span><span class="tok-kt">bool</span> <span class="tok-n">def</span> <span class="tok-o">=</span> <span class="tok-nb">false</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-kt">long</span> <span class="tok-kt">long</span> <a href="#xml_text::as_llong">as_llong</a><span class="tok-p">(</span><span class="tok-kt">long</span> <span class="tok-kt">long</span> <span class="tok-n">def</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-kt">unsigned</span> <span class="tok-kt">long</span> <span class="tok-kt">long</span> <a href="#xml_text::as_ullong">as_ullong</a><span class="tok-p">(</span><span class="tok-kt">unsigned</span> <span class="tok-kt">long</span> <span class="tok-kt">long</span> <span class="tok-n">def</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>

    <span class="tok-kt">bool</span> <a href="#xml_text::set">set</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>

    <span class="tok-kt">bool</span> <a href="#xml_text::set">set</a><span class="tok-p">(</span><span class="tok-kt">int</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
    <span class="tok-kt">bool</span> <a href="#xml_text::set">set</a><span class="tok-p">(</span><span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
    <span class="tok-kt">bool</span> <a href="#xml_text::set">set</a><span class="tok-p">(</span><span class="tok-kt">double</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
    <span class="tok-kt">bool</span> <a href="#xml_text::set">set</a><span class="tok-p">(</span><span class="tok-kt">float</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
    <span class="tok-kt">bool</span> <a href="#xml_text::set">set</a><span class="tok-p">(</span><span class="tok-kt">bool</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
    <span class="tok-kt">bool</span> <a href="#xml_text::set">set</a><span class="tok-p">(</span><span class="tok-kt">long</span> <span class="tok-kt">long</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
    <span class="tok-kt">bool</span> <a href="#xml_text::set">set</a><span class="tok-p">(</span><span class="tok-kt">unsigned</span> <span class="tok-kt">long</span> <span class="tok-kt">long</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>

    <span class="tok-n">xml_text</span><span class="tok-o">&amp;</span> <a href="#xml_text::assign">operator=</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
    <span class="tok-n">xml_text</span><span class="tok-o">&amp;</span> <a href="#xml_text::assign">operator=</a><span class="tok-p">(</span><span class="tok-kt">int</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
    <span class="tok-n">xml_text</span><span class="tok-o">&amp;</span> <a href="#xml_text::assign">operator=</a><span class="tok-p">(</span><span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
    <span class="tok-n">xml_text</span><span class="tok-o">&amp;</span> <a href="#xml_text::assign">operator=</a><span class="tok-p">(</span><span class="tok-kt">double</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
    <span class="tok-n">xml_text</span><span class="tok-o">&amp;</span> <a href="#xml_text::assign">operator=</a><span class="tok-p">(</span><span class="tok-kt">float</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
    <span class="tok-n">xml_text</span><span class="tok-o">&amp;</span> <a href="#xml_text::assign">operator=</a><span class="tok-p">(</span><span class="tok-kt">bool</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
    <span class="tok-n">xml_text</span><span class="tok-o">&amp;</span> <a href="#xml_text::assign">operator=</a><span class="tok-p">(</span><span class="tok-kt">long</span> <span class="tok-kt">long</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>
    <span class="tok-n">xml_text</span><span class="tok-o">&amp;</span> <a href="#xml_text::assign">operator=</a><span class="tok-p">(</span><span class="tok-kt">unsigned</span> <span class="tok-kt">long</span> <span class="tok-kt">long</span> <span class="tok-n">rhs</span><span class="tok-p">);</span>

    <span class="tok-n">xml_node</span> <a href="#xml_text::data">data</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>

<span class="tok-k">class</span> <a href="#xml_writer">xml_writer</a>
    <span class="tok-k">virtual</span> <span class="tok-kt">void</span> <a href="#xml_writer::write">write</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">void</span><span class="tok-o">*</span> <span class="tok-n">data</span><span class="tok-p">,</span> <span class="tok-kt">size_t</span> <span class="tok-n">size</span><span class="tok-p">)</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">;</span>

<span class="tok-k">class</span> <a href="#xml_writer_file">xml_writer_file</a><span class="tok-o">:</span> <span class="tok-k">public</span> <span class="tok-n">xml_writer</span>
    <a href="#xml_writer_file">xml_writer_file</a><span class="tok-p">(</span><span class="tok-kt">void</span><span class="tok-o">*</span> <span class="tok-n">file</span><span class="tok-p">);</span>

<span class="tok-k">class</span> <a href="#xml_writer_stream">xml_writer_stream</a><span class="tok-o">:</span> <span class="tok-k">public</span> <span class="tok-n">xml_writer</span>
    <a href="#xml_writer_stream">xml_writer_stream</a><span class="tok-p">(</span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">ostream</span><span class="tok-o">&amp;</span> <span class="tok-n">stream</span><span class="tok-p">);</span>
    <a href="#xml_writer_stream">xml_writer_stream</a><span class="tok-p">(</span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">wostream</span><span class="tok-o">&amp;</span> <span class="tok-n">stream</span><span class="tok-p">);</span>

<span class="tok-k">struct</span> <a href="#xpath_parse_result">xpath_parse_result</a>
    <span class="tok-k">const</span> <span class="tok-kt">char</span><span class="tok-o">*</span> <a href="#xpath_parse_result::error">error</a><span class="tok-p">;</span>
    <span class="tok-kt">ptrdiff_t</span> <a href="#xpath_parse_result::offset">offset</a><span class="tok-p">;</span>

    <span class="tok-k">operator</span> <a href="#xpath_parse_result::bool">bool</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-k">const</span> <span class="tok-kt">char</span><span class="tok-o">*</span> <a href="#xpath_parse_result::description">description</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>

<span class="tok-k">class</span> <a href="#xpath_query">xpath_query</a>
    <span class="tok-k">explicit</span> <a href="#xpath_query::ctor">xpath_query</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">query</span><span class="tok-p">,</span> <span class="tok-n">xpath_variable_set</span><span class="tok-o">*</span> <span class="tok-n">variables</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">);</span>

    <span class="tok-kt">bool</span> <a href="#xpath_query::evaluate_boolean">evaluate_boolean</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xpath_node</span><span class="tok-o">&amp;</span> <span class="tok-n">n</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-kt">double</span> <a href="#xpath_query::evaluate_number">evaluate_number</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xpath_node</span><span class="tok-o">&amp;</span> <span class="tok-n">n</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-kt">string_t</span> <a href="#xpath_query::evaluate_string">evaluate_string</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xpath_node</span><span class="tok-o">&amp;</span> <span class="tok-n">n</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-kt">size_t</span> <a href="#xpath_query::evaluate_string_buffer">evaluate_string</a><span class="tok-p">(</span><span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">buffer</span><span class="tok-p">,</span> <span class="tok-kt">size_t</span> <span class="tok-n">capacity</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-n">xpath_node</span><span class="tok-o">&amp;</span> <span class="tok-n">n</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-n">xpath_node_set</span> <a href="#xpath_query::evaluate_node_set">evaluate_node_set</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xpath_node</span><span class="tok-o">&amp;</span> <span class="tok-n">n</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-n">xpath_node</span> <a href="#xpath_query::evaluate_node">evaluate_node</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xpath_node</span><span class="tok-o">&amp;</span> <span class="tok-n">n</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>

    <span class="tok-n">xpath_value_type</span> <a href="#xpath_query::return_type">return_type</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>

    <span class="tok-k">const</span> <span class="tok-n">xpath_parse_result</span><span class="tok-o">&amp;</span> <a href="#xpath_query::result">result</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-k">operator</span> <a href="#xpath_query::unspecified_bool_type">unspecified_bool_type</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>

<span class="tok-k">class</span> <a href="#xpath_exception">xpath_exception</a><span class="tok-o">:</span> <span class="tok-k">public</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">exception</span>
    <span class="tok-k">virtual</span> <span class="tok-k">const</span> <span class="tok-kt">char</span><span class="tok-o">*</span> <a href="#xpath_exception::what">what</a><span class="tok-p">()</span> <span class="tok-k">const</span> <span class="tok-k">throw</span><span class="tok-p">();</span>

    <span class="tok-k">const</span> <span class="tok-n">xpath_parse_result</span><span class="tok-o">&amp;</span> <a href="#xpath_exception::result">result</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>

<span class="tok-k">class</span> <a href="#xpath_node">xpath_node</a>
    <a href="#xpath_node::ctor">xpath_node</a><span class="tok-p">();</span>
    <a href="#xpath_node::ctor">xpath_node</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xml_node</span><span class="tok-o">&amp;</span> <span class="tok-n">node</span><span class="tok-p">);</span>
    <a href="#xpath_node::ctor">xpath_node</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xml_attribute</span><span class="tok-o">&amp;</span> <span class="tok-n">attribute</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-n">xml_node</span><span class="tok-o">&amp;</span> <span class="tok-n">parent</span><span class="tok-p">);</span>

    <span class="tok-n">xml_node</span> <a href="#xpath_node::node">node</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-n">xml_attribute</span> <a href="#xpath_node::attribute">attribute</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-n">xml_node</span> <a href="#xpath_node::parent">parent</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>

    <span class="tok-k">operator</span> <a href="#xpath_node::unspecified_bool_type">unspecified_bool_type</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-kt">bool</span> <a href="#xpath_node::comparison">operator==</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xpath_node</span><span class="tok-o">&amp;</span> <span class="tok-n">n</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-kt">bool</span> <a href="#xpath_node::comparison">operator!=</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xpath_node</span><span class="tok-o">&amp;</span> <span class="tok-n">n</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>

<span class="tok-k">class</span> <a href="#xpath_node_set">xpath_node_set</a>
    <a href="#xpath_node_set::ctor">xpath_node_set</a><span class="tok-p">();</span>
    <a href="#xpath_node_set::ctor">xpath_node_set</a><span class="tok-p">(</span><span class="tok-n">const_iterator</span> <span class="tok-n">begin</span><span class="tok-p">,</span> <span class="tok-n">const_iterator</span> <span class="tok-n">end</span><span class="tok-p">,</span> <span class="tok-kt">type_t</span> <span class="tok-n">type</span> <span class="tok-o">=</span> <span class="tok-n">type_unsorted</span><span class="tok-p">);</span>

    <span class="tok-k">typedef</span> <span class="tok-k">const</span> <span class="tok-n">xpath_node</span><span class="tok-o">*</span> <a href="#xpath_node_set::const_iterator">const_iterator</a><span class="tok-p">;</span>
    <span class="tok-n">const_iterator</span> <a href="#xpath_node_set::begin">begin</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-n">const_iterator</span> <a href="#xpath_node_set::end">end</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>

    <span class="tok-k">const</span> <span class="tok-n">xpath_node</span><span class="tok-o">&amp;</span> <a href="#xpath_node_set::index">operator[</a><span class="tok-p">](</span><span class="tok-kt">size_t</span> <span class="tok-n">index</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-kt">size_t</span> <a href="#xpath_node_set::size">size</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-kt">bool</span> <a href="#xpath_node_set::empty">empty</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>

    <span class="tok-n">xpath_node</span> <a href="#xpath_node_set::first">first</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>

    <span class="tok-k">enum</span> <span class="tok-kt">type_t</span> <span class="tok-p">{</span><a href="#xpath_node_set::type_unsorted">type_unsorted</a><span class="tok-p">,</span> <a href="#xpath_node_set::type_sorted">type_sorted</a><span class="tok-p">,</span> <a href="#xpath_node_set::type_sorted_reverse">type_sorted_reverse</a><span class="tok-p">};</span>
    <span class="tok-kt">type_t</span> <a href="#xpath_node_set::type">type</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-kt">void</span> <a href="#xpath_node_set::sort">sort</a><span class="tok-p">(</span><span class="tok-kt">bool</span> <span class="tok-n">reverse</span> <span class="tok-o">=</span> <span class="tok-nb">false</span><span class="tok-p">);</span>

<span class="tok-k">class</span> <a href="#xpath_variable">xpath_variable</a>
    <span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <a href="#xpath_variable::name">name</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-n">xpath_value_type</span> <a href="#xpath_variable::type">type</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>

    <span class="tok-kt">bool</span> <a href="#xpath_variable::get_boolean">get_boolean</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-kt">double</span> <a href="#xpath_variable::get_number">get_number</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <a href="#xpath_variable::get_string">get_string</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>
    <span class="tok-k">const</span> <span class="tok-n">xpath_node_set</span><span class="tok-o">&amp;</span> <a href="#xpath_variable::get_node_set">get_node_set</a><span class="tok-p">()</span> <span class="tok-k">const</span><span class="tok-p">;</span>

    <span class="tok-kt">bool</span> <a href="#xpath_variable::set">set</a><span class="tok-p">(</span><span class="tok-kt">bool</span> <span class="tok-n">value</span><span class="tok-p">);</span>
    <span class="tok-kt">bool</span> <a href="#xpath_variable::set">set</a><span class="tok-p">(</span><span class="tok-kt">double</span> <span class="tok-n">value</span><span class="tok-p">);</span>
    <span class="tok-kt">bool</span> <a href="#xpath_variable::set">set</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">value</span><span class="tok-p">);</span>
    <span class="tok-kt">bool</span> <a href="#xpath_variable::set">set</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">xpath_node_set</span><span class="tok-o">&amp;</span> <span class="tok-n">value</span><span class="tok-p">);</span>

<span class="tok-k">class</span> <a href="#xpath_variable_set">xpath_variable_set</a>
    <span class="tok-n">xpath_variable</span><span class="tok-o">*</span> <a href="#xpath_variable_set::add">add</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">name</span><span class="tok-p">,</span> <span class="tok-n">xpath_value_type</span> <span class="tok-n">type</span><span class="tok-p">);</span>

    <span class="tok-kt">bool</span> <a href="#xpath_variable_set::set">set</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">name</span><span class="tok-p">,</span> <span class="tok-kt">bool</span> <span class="tok-n">value</span><span class="tok-p">);</span>
    <span class="tok-kt">bool</span> <a href="#xpath_variable_set::set">set</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">name</span><span class="tok-p">,</span> <span class="tok-kt">double</span> <span class="tok-n">value</span><span class="tok-p">);</span>
    <span class="tok-kt">bool</span> <a href="#xpath_variable_set::set">set</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">name</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">value</span><span class="tok-p">);</span>
    <span class="tok-kt">bool</span> <a href="#xpath_variable_set::set">set</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">name</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-n">xpath_node_set</span><span class="tok-o">&amp;</span> <span class="tok-n">value</span><span class="tok-p">);</span>

    <span class="tok-n">xpath_variable</span><span class="tok-o">*</span> <a href="#xpath_variable_set::get">get</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">name</span><span class="tok-p">);</span>
    <span class="tok-k">const</span> <span class="tok-n">xpath_variable</span><span class="tok-o">*</span> <a href="#xpath_variable_set::get">get</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char_t</span><span class="tok-o">*</span> <span class="tok-n">name</span><span class="tok-p">)</span> <span class="tok-k">const</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="apiref.functions"><a class="anchor" href="#apiref.functions"></a>10.6. Functions</h3>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">string</span> <a href="#as_utf8">as_utf8</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">wchar_t</span><span class="tok-o">*</span> <span class="tok-n">str</span><span class="tok-p">);</span>
<span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">string</span> <a href="#as_utf8">as_utf8</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">wstring</span><span class="tok-o">&amp;</span> <span class="tok-n">str</span><span class="tok-p">);</span>
<span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">wstring</span> <a href="#as_wide">as_wide</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">char</span><span class="tok-o">*</span> <span class="tok-n">str</span><span class="tok-p">);</span>
<span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">wstring</span> <a href="#as_wide">as_wide</a><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">string</span><span class="tok-o">&amp;</span> <span class="tok-n">str</span><span class="tok-p">);</span>
<span class="tok-kt">void</span> <a href="#set_memory_management_functions">set_memory_management_functions</a><span class="tok-p">(</span><span class="tok-n">allocation_function</span> <span class="tok-n">allocate</span><span class="tok-p">,</span> <span class="tok-n">deallocation_function</span> <span class="tok-n">deallocate</span><span class="tok-p">);</span>
<span class="tok-n">allocation_function</span> <a href="#get_memory_allocation_function">get_memory_allocation_function</a><span class="tok-p">();</span>
<span class="tok-n">deallocation_function</span> <a href="#get_memory_deallocation_function">get_memory_deallocation_function</a><span class="tok-p">();</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnote_1">
<a href="#_footnoteref_1">1</a>. All trademarks used are properties of their respective owners.
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2015-10-19 20:55:20 PDT
</div>
</div>
</body>
</html>