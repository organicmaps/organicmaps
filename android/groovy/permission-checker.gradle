import java.util.regex.Pattern
import javax.inject.Inject

abstract class CheckApkPermissions extends DefaultTask {
  // lazy-set in doFirst, not considered for caching/up-to-date
  @Internal
  File apkPath

  @Input
  abstract ListProperty<Pattern> getAllowedPermissions()

  @InputFile
  abstract Property<File> getAapt2Executable()

  @Inject
  abstract ExecOperations getExecOperations()

  @TaskAction
  void execute() {
    // Get permissions from APK
    def output = new ByteArrayOutputStream()
    def errorOutput = new ByteArrayOutputStream()
    execOperations.exec { spec ->
      spec.commandLine(aapt2Executable.get().absolutePath)
      spec.args("dump", "permissions", apkPath.absolutePath)
      spec.ignoreExitValue = true
      spec.standardOutput = output
      spec.errorOutput = errorOutput
    }
    if (errorOutput.size() > 0) {
      throw new GradleException("Error running aapt2: \n${errorOutput.toString('UTF-8')}")
    }
    def permissions = output.toString('UTF-8')

    def matcher = (permissions =~ /uses-permission: (.+)/)
    def foundPermissions = matcher.collect { it[1] }

    // Check for unexpected permissions
    def unexpectedPermissions = foundPermissions.findAll { perm ->
      !allowedPermissions.get().any { pattern ->
        perm == pattern || perm ==~ pattern
      }
    }

    // Check for missing permissions from whitelist
    def missingPermissions = allowedPermissions.get().findAll { pattern ->
      !foundPermissions.any { perm ->
        perm == pattern || perm ==~ pattern
      }
    }

    if (!unexpectedPermissions.isEmpty() || !missingPermissions.isEmpty()) {
      println "Checking APK: ${apkPath.name}"
      println "Found permissions: ${foundPermissions}"
      println "Allowed permissions: ${allowedPermissions.get()}"
      println "Unexpected permissions: ${unexpectedPermissions}"
      println "Missing permissions: ${missingPermissions}"

      def msg = ""
      if (!unexpectedPermissions.isEmpty())
        msg += "APK contains unexpected permissions: ${unexpectedPermissions}\n"
      if (!missingPermissions.isEmpty())
        msg += "APK is missing permissions from whitelist: ${missingPermissions}\n"
      throw new GradleException(msg)
    }
  }
}

ext.registerCheckApkPermissionsTasks = { Project project, List<String> allowedPermissions ->
  project.android.applicationVariants.all { variant ->
    def variantName = variant.name
    def capitalizedVariantName = variantName.capitalize()
    def taskName = "check${capitalizedVariantName}ApkPermissions"

    project.tasks.register(taskName, CheckApkPermissions) { task ->
      group = "verification"
      description = "Checks that the ${variantName} APK only contains allowed permissions"
      dependsOn "assemble${capitalizedVariantName}"

      task.allowedPermissions = project.objects.listProperty(Pattern).value(
          allowedPermissions.collect { it instanceof Pattern ? it : Pattern.compile(it) }
      )
      aapt2Executable = androidComponents.sdkComponents.aapt2.get().executable.getAsFile()
      doFirst {
        apkPath = variant.outputs*.outputFile?.find { it.exists() }
        if (!apkPath)
          throw new GradleException("APK not found for ${variantName}")
      }
    }

    // Automatically run after assemble<Variant>
    project.tasks.named("assemble${capitalizedVariantName}") {
      finalizedBy(taskName)
    }
  }
}
