#pragma once

#include "base/macros.hpp"
#include "base/newtype.hpp"
#include "base/visitor.hpp"

#include "defines.hpp"

#include <cstdint>
#include <limits>
#include <string>
#include <unordered_map>
#include <vector>

#include "3party/opening_hours/opening_hours.hpp"

namespace routing
{
inline double constexpr kTransitMaxSpeedKMpH = 400.0;
}  // namespace routing

namespace transit
{
// File names for saving resulting data exported from GTFS.
inline std::string const kTransitFileExtension = std::string(TRANSIT_FILE_EXTENSION);
inline std::string const kNetworksFile = "networks" + kTransitFileExtension;
inline std::string const kRoutesFile = "routes" + kTransitFileExtension;
inline std::string const kLinesFile = "lines" + kTransitFileExtension;
inline std::string const kShapesFile = "shapes" + kTransitFileExtension;
inline std::string const kStopsFile = "stops" + kTransitFileExtension;
inline std::string const kEdgesFile = "edges" + kTransitFileExtension;
inline std::string const kEdgesTransferFile = "edges_transfer" + kTransitFileExtension;
inline std::string const kTransfersFile = "transfers" + kTransitFileExtension;
inline std::string const kGatesFile = "gates" + kTransitFileExtension;

// Unique id for transit entities. It is generated by gtfs_converter and is persistent between
// re-runs. Generated based on the unique string hash of the GTFS entity. Lies in the interval
// |routing::FakeFeatureIds::IsTransitFeature()|. If the GTFS entity is renamed or the new GTFS
// feed is added the new id is generated by |IdGenerator::MakeId()|.
using TransitId = uint32_t;
inline TransitId constexpr kInvalidTransitId = std::numeric_limits<TransitId>::max();

// Mapping of language id to text. Language id exists in |StringUtf8Multilang::kLanguages|.
using Translations = std::unordered_map<std::string, std::string>;

struct TimeFromGateToStop
{
  TimeFromGateToStop() = default;
  TimeFromGateToStop(TransitId stopId, size_t timeSeconds)
    : m_stopId(stopId), m_timeSeconds(timeSeconds)
  {
  }
  bool operator==(TimeFromGateToStop const & rhs) const
  {
    return std::tie(m_stopId, m_timeSeconds) == std::tie(rhs.m_stopId, rhs.m_timeSeconds);
  }

  DECLARE_VISITOR_AND_DEBUG_PRINT(TimeFromGateToStop, visitor(m_stopId, "stopId"),
                                  visitor(m_timeSeconds, "timeSeconds"))

  TransitId m_stopId = kInvalidTransitId;
  size_t m_timeSeconds = 0;
};

struct LineInterval
{
  LineInterval() = default;
  LineInterval(size_t headwayS, osmoh::OpeningHours const & timeIntervals)
    : m_headwayS(headwayS), m_timeIntervals(timeIntervals)
  {
  }

  bool operator==(LineInterval const & rhs) const
  {
    return std::tie(m_headwayS, m_timeIntervals) == std::tie(rhs.m_headwayS, rhs.m_timeIntervals);
  }

  DECLARE_VISITOR_AND_DEBUG_PRINT(LineInterval, visitor(m_headwayS, "headwayS"),
                                  visitor(m_timeIntervals, "timeIntervals"))
  // Service interval in seconds between departures from the same stop (headway) for the line,
  // during the time interval specified by |m_timeIntervals|.
  size_t m_headwayS = 0;
  // Time interval for the |m_headwayS|. Multiple headways for the same trip are allowed, but may
  // not overlap in time.
  osmoh::OpeningHours m_timeIntervals;
};

using LineIntervals = std::vector<LineInterval>;
using IdList = std::vector<TransitId>;
using TimeTable = std::unordered_map<TransitId, osmoh::OpeningHours>;
using EdgeWeight = uint32_t;

// Link to the shape: shape id and indexes in the corresponding polyline.
struct ShapeLink
{
  ShapeLink() = default;
  ShapeLink(TransitId id, size_t startIndex, size_t endIndex)
    : m_shapeId(id), m_startIndex(startIndex), m_endIndex(endIndex)
  {
  }

  bool operator==(ShapeLink const & rhs) const
  {
    return std::tie(m_shapeId, m_startIndex, m_endIndex) ==
           std::tie(rhs.m_shapeId, rhs.m_startIndex, rhs.m_endIndex);
  }

  DECLARE_VISITOR_AND_DEBUG_PRINT(ShapeLink, visitor(m_shapeId, "id"),
                                  visitor(m_startIndex, "startIndex"),
                                  visitor(m_endIndex, "endIndex"))

  TransitId m_shapeId = kInvalidTransitId;
  size_t m_startIndex = 0;
  size_t m_endIndex = 0;
};
}  // namespace transit
