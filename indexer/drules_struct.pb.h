// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: drules_struct.proto

#ifndef PROTOBUF_drules_5fstruct_2eproto__INCLUDED
#define PROTOBUF_drules_5fstruct_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_drules_5fstruct_2eproto();
void protobuf_AssignDesc_drules_5fstruct_2eproto();
void protobuf_ShutdownFile_drules_5fstruct_2eproto();

class DashDotProto;
class PathSymProto;
class LineRuleProto;
class LineDefProto;
class AreaRuleProto;
class SymbolRuleProto;
class CaptionDefProto;
class CaptionRuleProto;
class CircleRuleProto;
class PathTextRuleProto;
class ShieldRuleProto;
class DrawElementProto;
class ClassifElementProto;
class ContainerProto;

enum LineJoin {
  ROUNDJOIN = 0,
  BEVELJOIN = 1,
  NOJOIN = 2
};
bool LineJoin_IsValid(int value);
const LineJoin LineJoin_MIN = ROUNDJOIN;
const LineJoin LineJoin_MAX = NOJOIN;
const int LineJoin_ARRAYSIZE = LineJoin_MAX + 1;

enum LineCap {
  ROUNDCAP = 0,
  BUTTCAP = 1,
  SQUARECAP = 2
};
bool LineCap_IsValid(int value);
const LineCap LineCap_MIN = ROUNDCAP;
const LineCap LineCap_MAX = SQUARECAP;
const int LineCap_ARRAYSIZE = LineCap_MAX + 1;

// ===================================================================

class DashDotProto : public ::google::protobuf::MessageLite {
 public:
  DashDotProto();
  virtual ~DashDotProto();

  DashDotProto(const DashDotProto& from);

  inline DashDotProto& operator=(const DashDotProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const DashDotProto& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DashDotProto* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DashDotProto* other);

  // implements Message ----------------------------------------------

  DashDotProto* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DashDotProto& from);
  void MergeFrom(const DashDotProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double dd = 1;
  inline int dd_size() const;
  inline void clear_dd();
  static const int kDdFieldNumber = 1;
  inline double dd(int index) const;
  inline void set_dd(int index, double value);
  inline void add_dd(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      dd() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_dd();

  // optional double offset = 2;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 2;
  inline double offset() const;
  inline void set_offset(double value);

  // @@protoc_insertion_point(class_scope:DashDotProto)
 private:
  inline void set_has_offset();
  inline void clear_has_offset();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< double > dd_;
  double offset_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_drules_5fstruct_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_drules_5fstruct_2eproto();
  #endif
  friend void protobuf_AssignDesc_drules_5fstruct_2eproto();
  friend void protobuf_ShutdownFile_drules_5fstruct_2eproto();

  void InitAsDefaultInstance();
  static DashDotProto* default_instance_;
};
// -------------------------------------------------------------------

class PathSymProto : public ::google::protobuf::MessageLite {
 public:
  PathSymProto();
  virtual ~PathSymProto();

  PathSymProto(const PathSymProto& from);

  inline PathSymProto& operator=(const PathSymProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PathSymProto& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PathSymProto* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PathSymProto* other);

  // implements Message ----------------------------------------------

  PathSymProto* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PathSymProto& from);
  void MergeFrom(const PathSymProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required double step = 2;
  inline bool has_step() const;
  inline void clear_step();
  static const int kStepFieldNumber = 2;
  inline double step() const;
  inline void set_step(double value);

  // optional double offset = 3;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 3;
  inline double offset() const;
  inline void set_offset(double value);

  // @@protoc_insertion_point(class_scope:PathSymProto)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_step();
  inline void clear_has_step();
  inline void set_has_offset();
  inline void clear_has_offset();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  double step_;
  double offset_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_drules_5fstruct_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_drules_5fstruct_2eproto();
  #endif
  friend void protobuf_AssignDesc_drules_5fstruct_2eproto();
  friend void protobuf_ShutdownFile_drules_5fstruct_2eproto();

  void InitAsDefaultInstance();
  static PathSymProto* default_instance_;
};
// -------------------------------------------------------------------

class LineRuleProto : public ::google::protobuf::MessageLite {
 public:
  LineRuleProto();
  virtual ~LineRuleProto();

  LineRuleProto(const LineRuleProto& from);

  inline LineRuleProto& operator=(const LineRuleProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const LineRuleProto& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LineRuleProto* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LineRuleProto* other);

  // implements Message ----------------------------------------------

  LineRuleProto* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LineRuleProto& from);
  void MergeFrom(const LineRuleProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double width = 1;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 1;
  inline double width() const;
  inline void set_width(double value);

  // required uint32 color = 2;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 2;
  inline ::google::protobuf::uint32 color() const;
  inline void set_color(::google::protobuf::uint32 value);

  // optional .DashDotProto dashdot = 3;
  inline bool has_dashdot() const;
  inline void clear_dashdot();
  static const int kDashdotFieldNumber = 3;
  inline const ::DashDotProto& dashdot() const;
  inline ::DashDotProto* mutable_dashdot();
  inline ::DashDotProto* release_dashdot();
  inline void set_allocated_dashdot(::DashDotProto* dashdot);

  // required int32 priority = 4;
  inline bool has_priority() const;
  inline void clear_priority();
  static const int kPriorityFieldNumber = 4;
  inline ::google::protobuf::int32 priority() const;
  inline void set_priority(::google::protobuf::int32 value);

  // optional .PathSymProto pathsym = 5;
  inline bool has_pathsym() const;
  inline void clear_pathsym();
  static const int kPathsymFieldNumber = 5;
  inline const ::PathSymProto& pathsym() const;
  inline ::PathSymProto* mutable_pathsym();
  inline ::PathSymProto* release_pathsym();
  inline void set_allocated_pathsym(::PathSymProto* pathsym);

  // optional .LineJoin join = 6;
  inline bool has_join() const;
  inline void clear_join();
  static const int kJoinFieldNumber = 6;
  inline ::LineJoin join() const;
  inline void set_join(::LineJoin value);

  // optional .LineCap cap = 7;
  inline bool has_cap() const;
  inline void clear_cap();
  static const int kCapFieldNumber = 7;
  inline ::LineCap cap() const;
  inline void set_cap(::LineCap value);

  // @@protoc_insertion_point(class_scope:LineRuleProto)
 private:
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_dashdot();
  inline void clear_has_dashdot();
  inline void set_has_priority();
  inline void clear_has_priority();
  inline void set_has_pathsym();
  inline void clear_has_pathsym();
  inline void set_has_join();
  inline void clear_has_join();
  inline void set_has_cap();
  inline void clear_has_cap();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double width_;
  ::DashDotProto* dashdot_;
  ::google::protobuf::uint32 color_;
  ::google::protobuf::int32 priority_;
  ::PathSymProto* pathsym_;
  int join_;
  int cap_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_drules_5fstruct_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_drules_5fstruct_2eproto();
  #endif
  friend void protobuf_AssignDesc_drules_5fstruct_2eproto();
  friend void protobuf_ShutdownFile_drules_5fstruct_2eproto();

  void InitAsDefaultInstance();
  static LineRuleProto* default_instance_;
};
// -------------------------------------------------------------------

class LineDefProto : public ::google::protobuf::MessageLite {
 public:
  LineDefProto();
  virtual ~LineDefProto();

  LineDefProto(const LineDefProto& from);

  inline LineDefProto& operator=(const LineDefProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const LineDefProto& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LineDefProto* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LineDefProto* other);

  // implements Message ----------------------------------------------

  LineDefProto* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LineDefProto& from);
  void MergeFrom(const LineDefProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double width = 1;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 1;
  inline double width() const;
  inline void set_width(double value);

  // required uint32 color = 2;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 2;
  inline ::google::protobuf::uint32 color() const;
  inline void set_color(::google::protobuf::uint32 value);

  // optional .DashDotProto dashdot = 3;
  inline bool has_dashdot() const;
  inline void clear_dashdot();
  static const int kDashdotFieldNumber = 3;
  inline const ::DashDotProto& dashdot() const;
  inline ::DashDotProto* mutable_dashdot();
  inline ::DashDotProto* release_dashdot();
  inline void set_allocated_dashdot(::DashDotProto* dashdot);

  // optional .PathSymProto pathsym = 4;
  inline bool has_pathsym() const;
  inline void clear_pathsym();
  static const int kPathsymFieldNumber = 4;
  inline const ::PathSymProto& pathsym() const;
  inline ::PathSymProto* mutable_pathsym();
  inline ::PathSymProto* release_pathsym();
  inline void set_allocated_pathsym(::PathSymProto* pathsym);

  // optional .LineJoin join = 6;
  inline bool has_join() const;
  inline void clear_join();
  static const int kJoinFieldNumber = 6;
  inline ::LineJoin join() const;
  inline void set_join(::LineJoin value);

  // optional .LineCap cap = 7;
  inline bool has_cap() const;
  inline void clear_cap();
  static const int kCapFieldNumber = 7;
  inline ::LineCap cap() const;
  inline void set_cap(::LineCap value);

  // @@protoc_insertion_point(class_scope:LineDefProto)
 private:
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_dashdot();
  inline void clear_has_dashdot();
  inline void set_has_pathsym();
  inline void clear_has_pathsym();
  inline void set_has_join();
  inline void clear_has_join();
  inline void set_has_cap();
  inline void clear_has_cap();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double width_;
  ::DashDotProto* dashdot_;
  ::google::protobuf::uint32 color_;
  int join_;
  ::PathSymProto* pathsym_;
  int cap_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_drules_5fstruct_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_drules_5fstruct_2eproto();
  #endif
  friend void protobuf_AssignDesc_drules_5fstruct_2eproto();
  friend void protobuf_ShutdownFile_drules_5fstruct_2eproto();

  void InitAsDefaultInstance();
  static LineDefProto* default_instance_;
};
// -------------------------------------------------------------------

class AreaRuleProto : public ::google::protobuf::MessageLite {
 public:
  AreaRuleProto();
  virtual ~AreaRuleProto();

  AreaRuleProto(const AreaRuleProto& from);

  inline AreaRuleProto& operator=(const AreaRuleProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AreaRuleProto& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AreaRuleProto* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AreaRuleProto* other);

  // implements Message ----------------------------------------------

  AreaRuleProto* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AreaRuleProto& from);
  void MergeFrom(const AreaRuleProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 color = 1;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 1;
  inline ::google::protobuf::uint32 color() const;
  inline void set_color(::google::protobuf::uint32 value);

  // optional .LineDefProto border = 2;
  inline bool has_border() const;
  inline void clear_border();
  static const int kBorderFieldNumber = 2;
  inline const ::LineDefProto& border() const;
  inline ::LineDefProto* mutable_border();
  inline ::LineDefProto* release_border();
  inline void set_allocated_border(::LineDefProto* border);

  // required int32 priority = 3;
  inline bool has_priority() const;
  inline void clear_priority();
  static const int kPriorityFieldNumber = 3;
  inline ::google::protobuf::int32 priority() const;
  inline void set_priority(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:AreaRuleProto)
 private:
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_border();
  inline void clear_has_border();
  inline void set_has_priority();
  inline void clear_has_priority();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::LineDefProto* border_;
  ::google::protobuf::uint32 color_;
  ::google::protobuf::int32 priority_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_drules_5fstruct_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_drules_5fstruct_2eproto();
  #endif
  friend void protobuf_AssignDesc_drules_5fstruct_2eproto();
  friend void protobuf_ShutdownFile_drules_5fstruct_2eproto();

  void InitAsDefaultInstance();
  static AreaRuleProto* default_instance_;
};
// -------------------------------------------------------------------

class SymbolRuleProto : public ::google::protobuf::MessageLite {
 public:
  SymbolRuleProto();
  virtual ~SymbolRuleProto();

  SymbolRuleProto(const SymbolRuleProto& from);

  inline SymbolRuleProto& operator=(const SymbolRuleProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SymbolRuleProto& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SymbolRuleProto* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SymbolRuleProto* other);

  // implements Message ----------------------------------------------

  SymbolRuleProto* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SymbolRuleProto& from);
  void MergeFrom(const SymbolRuleProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 apply_for_type = 2;
  inline bool has_apply_for_type() const;
  inline void clear_apply_for_type();
  static const int kApplyForTypeFieldNumber = 2;
  inline ::google::protobuf::int32 apply_for_type() const;
  inline void set_apply_for_type(::google::protobuf::int32 value);

  // required int32 priority = 3;
  inline bool has_priority() const;
  inline void clear_priority();
  static const int kPriorityFieldNumber = 3;
  inline ::google::protobuf::int32 priority() const;
  inline void set_priority(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SymbolRuleProto)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_apply_for_type();
  inline void clear_has_apply_for_type();
  inline void set_has_priority();
  inline void clear_has_priority();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::int32 apply_for_type_;
  ::google::protobuf::int32 priority_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_drules_5fstruct_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_drules_5fstruct_2eproto();
  #endif
  friend void protobuf_AssignDesc_drules_5fstruct_2eproto();
  friend void protobuf_ShutdownFile_drules_5fstruct_2eproto();

  void InitAsDefaultInstance();
  static SymbolRuleProto* default_instance_;
};
// -------------------------------------------------------------------

class CaptionDefProto : public ::google::protobuf::MessageLite {
 public:
  CaptionDefProto();
  virtual ~CaptionDefProto();

  CaptionDefProto(const CaptionDefProto& from);

  inline CaptionDefProto& operator=(const CaptionDefProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CaptionDefProto& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CaptionDefProto* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CaptionDefProto* other);

  // implements Message ----------------------------------------------

  CaptionDefProto* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CaptionDefProto& from);
  void MergeFrom(const CaptionDefProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 height = 1;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 1;
  inline ::google::protobuf::int32 height() const;
  inline void set_height(::google::protobuf::int32 value);

  // required uint32 color = 2;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 2;
  inline ::google::protobuf::uint32 color() const;
  inline void set_color(::google::protobuf::uint32 value);

  // optional uint32 stroke_color = 3;
  inline bool has_stroke_color() const;
  inline void clear_stroke_color();
  static const int kStrokeColorFieldNumber = 3;
  inline ::google::protobuf::uint32 stroke_color() const;
  inline void set_stroke_color(::google::protobuf::uint32 value);

  // optional int32 offset_x = 4;
  inline bool has_offset_x() const;
  inline void clear_offset_x();
  static const int kOffsetXFieldNumber = 4;
  inline ::google::protobuf::int32 offset_x() const;
  inline void set_offset_x(::google::protobuf::int32 value);

  // optional int32 offset_y = 5;
  inline bool has_offset_y() const;
  inline void clear_offset_y();
  static const int kOffsetYFieldNumber = 5;
  inline ::google::protobuf::int32 offset_y() const;
  inline void set_offset_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CaptionDefProto)
 private:
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_stroke_color();
  inline void clear_has_stroke_color();
  inline void set_has_offset_x();
  inline void clear_has_offset_x();
  inline void set_has_offset_y();
  inline void clear_has_offset_y();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 height_;
  ::google::protobuf::uint32 color_;
  ::google::protobuf::uint32 stroke_color_;
  ::google::protobuf::int32 offset_x_;
  ::google::protobuf::int32 offset_y_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_drules_5fstruct_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_drules_5fstruct_2eproto();
  #endif
  friend void protobuf_AssignDesc_drules_5fstruct_2eproto();
  friend void protobuf_ShutdownFile_drules_5fstruct_2eproto();

  void InitAsDefaultInstance();
  static CaptionDefProto* default_instance_;
};
// -------------------------------------------------------------------

class CaptionRuleProto : public ::google::protobuf::MessageLite {
 public:
  CaptionRuleProto();
  virtual ~CaptionRuleProto();

  CaptionRuleProto(const CaptionRuleProto& from);

  inline CaptionRuleProto& operator=(const CaptionRuleProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CaptionRuleProto& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CaptionRuleProto* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CaptionRuleProto* other);

  // implements Message ----------------------------------------------

  CaptionRuleProto* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CaptionRuleProto& from);
  void MergeFrom(const CaptionRuleProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .CaptionDefProto primary = 1;
  inline bool has_primary() const;
  inline void clear_primary();
  static const int kPrimaryFieldNumber = 1;
  inline const ::CaptionDefProto& primary() const;
  inline ::CaptionDefProto* mutable_primary();
  inline ::CaptionDefProto* release_primary();
  inline void set_allocated_primary(::CaptionDefProto* primary);

  // optional .CaptionDefProto secondary = 2;
  inline bool has_secondary() const;
  inline void clear_secondary();
  static const int kSecondaryFieldNumber = 2;
  inline const ::CaptionDefProto& secondary() const;
  inline ::CaptionDefProto* mutable_secondary();
  inline ::CaptionDefProto* release_secondary();
  inline void set_allocated_secondary(::CaptionDefProto* secondary);

  // required int32 priority = 3;
  inline bool has_priority() const;
  inline void clear_priority();
  static const int kPriorityFieldNumber = 3;
  inline ::google::protobuf::int32 priority() const;
  inline void set_priority(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CaptionRuleProto)
 private:
  inline void set_has_primary();
  inline void clear_has_primary();
  inline void set_has_secondary();
  inline void clear_has_secondary();
  inline void set_has_priority();
  inline void clear_has_priority();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::CaptionDefProto* primary_;
  ::CaptionDefProto* secondary_;
  ::google::protobuf::int32 priority_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_drules_5fstruct_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_drules_5fstruct_2eproto();
  #endif
  friend void protobuf_AssignDesc_drules_5fstruct_2eproto();
  friend void protobuf_ShutdownFile_drules_5fstruct_2eproto();

  void InitAsDefaultInstance();
  static CaptionRuleProto* default_instance_;
};
// -------------------------------------------------------------------

class CircleRuleProto : public ::google::protobuf::MessageLite {
 public:
  CircleRuleProto();
  virtual ~CircleRuleProto();

  CircleRuleProto(const CircleRuleProto& from);

  inline CircleRuleProto& operator=(const CircleRuleProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CircleRuleProto& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CircleRuleProto* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CircleRuleProto* other);

  // implements Message ----------------------------------------------

  CircleRuleProto* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CircleRuleProto& from);
  void MergeFrom(const CircleRuleProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double radius = 1;
  inline bool has_radius() const;
  inline void clear_radius();
  static const int kRadiusFieldNumber = 1;
  inline double radius() const;
  inline void set_radius(double value);

  // required uint32 color = 2;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 2;
  inline ::google::protobuf::uint32 color() const;
  inline void set_color(::google::protobuf::uint32 value);

  // optional .LineDefProto border = 3;
  inline bool has_border() const;
  inline void clear_border();
  static const int kBorderFieldNumber = 3;
  inline const ::LineDefProto& border() const;
  inline ::LineDefProto* mutable_border();
  inline ::LineDefProto* release_border();
  inline void set_allocated_border(::LineDefProto* border);

  // required int32 priority = 4;
  inline bool has_priority() const;
  inline void clear_priority();
  static const int kPriorityFieldNumber = 4;
  inline ::google::protobuf::int32 priority() const;
  inline void set_priority(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CircleRuleProto)
 private:
  inline void set_has_radius();
  inline void clear_has_radius();
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_border();
  inline void clear_has_border();
  inline void set_has_priority();
  inline void clear_has_priority();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double radius_;
  ::LineDefProto* border_;
  ::google::protobuf::uint32 color_;
  ::google::protobuf::int32 priority_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_drules_5fstruct_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_drules_5fstruct_2eproto();
  #endif
  friend void protobuf_AssignDesc_drules_5fstruct_2eproto();
  friend void protobuf_ShutdownFile_drules_5fstruct_2eproto();

  void InitAsDefaultInstance();
  static CircleRuleProto* default_instance_;
};
// -------------------------------------------------------------------

class PathTextRuleProto : public ::google::protobuf::MessageLite {
 public:
  PathTextRuleProto();
  virtual ~PathTextRuleProto();

  PathTextRuleProto(const PathTextRuleProto& from);

  inline PathTextRuleProto& operator=(const PathTextRuleProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PathTextRuleProto& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PathTextRuleProto* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PathTextRuleProto* other);

  // implements Message ----------------------------------------------

  PathTextRuleProto* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PathTextRuleProto& from);
  void MergeFrom(const PathTextRuleProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .CaptionDefProto primary = 1;
  inline bool has_primary() const;
  inline void clear_primary();
  static const int kPrimaryFieldNumber = 1;
  inline const ::CaptionDefProto& primary() const;
  inline ::CaptionDefProto* mutable_primary();
  inline ::CaptionDefProto* release_primary();
  inline void set_allocated_primary(::CaptionDefProto* primary);

  // optional .CaptionDefProto secondary = 2;
  inline bool has_secondary() const;
  inline void clear_secondary();
  static const int kSecondaryFieldNumber = 2;
  inline const ::CaptionDefProto& secondary() const;
  inline ::CaptionDefProto* mutable_secondary();
  inline ::CaptionDefProto* release_secondary();
  inline void set_allocated_secondary(::CaptionDefProto* secondary);

  // required int32 priority = 3;
  inline bool has_priority() const;
  inline void clear_priority();
  static const int kPriorityFieldNumber = 3;
  inline ::google::protobuf::int32 priority() const;
  inline void set_priority(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PathTextRuleProto)
 private:
  inline void set_has_primary();
  inline void clear_has_primary();
  inline void set_has_secondary();
  inline void clear_has_secondary();
  inline void set_has_priority();
  inline void clear_has_priority();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::CaptionDefProto* primary_;
  ::CaptionDefProto* secondary_;
  ::google::protobuf::int32 priority_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_drules_5fstruct_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_drules_5fstruct_2eproto();
  #endif
  friend void protobuf_AssignDesc_drules_5fstruct_2eproto();
  friend void protobuf_ShutdownFile_drules_5fstruct_2eproto();

  void InitAsDefaultInstance();
  static PathTextRuleProto* default_instance_;
};
// -------------------------------------------------------------------

class ShieldRuleProto : public ::google::protobuf::MessageLite {
 public:
  ShieldRuleProto();
  virtual ~ShieldRuleProto();

  ShieldRuleProto(const ShieldRuleProto& from);

  inline ShieldRuleProto& operator=(const ShieldRuleProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ShieldRuleProto& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ShieldRuleProto* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ShieldRuleProto* other);

  // implements Message ----------------------------------------------

  ShieldRuleProto* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ShieldRuleProto& from);
  void MergeFrom(const ShieldRuleProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 height = 1;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 1;
  inline ::google::protobuf::int32 height() const;
  inline void set_height(::google::protobuf::int32 value);

  // required uint32 color = 2;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 2;
  inline ::google::protobuf::uint32 color() const;
  inline void set_color(::google::protobuf::uint32 value);

  // optional uint32 stroke_color = 3;
  inline bool has_stroke_color() const;
  inline void clear_stroke_color();
  static const int kStrokeColorFieldNumber = 3;
  inline ::google::protobuf::uint32 stroke_color() const;
  inline void set_stroke_color(::google::protobuf::uint32 value);

  // required int32 priority = 4;
  inline bool has_priority() const;
  inline void clear_priority();
  static const int kPriorityFieldNumber = 4;
  inline ::google::protobuf::int32 priority() const;
  inline void set_priority(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ShieldRuleProto)
 private:
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_stroke_color();
  inline void clear_has_stroke_color();
  inline void set_has_priority();
  inline void clear_has_priority();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 height_;
  ::google::protobuf::uint32 color_;
  ::google::protobuf::uint32 stroke_color_;
  ::google::protobuf::int32 priority_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_drules_5fstruct_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_drules_5fstruct_2eproto();
  #endif
  friend void protobuf_AssignDesc_drules_5fstruct_2eproto();
  friend void protobuf_ShutdownFile_drules_5fstruct_2eproto();

  void InitAsDefaultInstance();
  static ShieldRuleProto* default_instance_;
};
// -------------------------------------------------------------------

class DrawElementProto : public ::google::protobuf::MessageLite {
 public:
  DrawElementProto();
  virtual ~DrawElementProto();

  DrawElementProto(const DrawElementProto& from);

  inline DrawElementProto& operator=(const DrawElementProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const DrawElementProto& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DrawElementProto* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DrawElementProto* other);

  // implements Message ----------------------------------------------

  DrawElementProto* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DrawElementProto& from);
  void MergeFrom(const DrawElementProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 scale = 1;
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 1;
  inline ::google::protobuf::int32 scale() const;
  inline void set_scale(::google::protobuf::int32 value);

  // repeated .LineRuleProto lines = 2;
  inline int lines_size() const;
  inline void clear_lines();
  static const int kLinesFieldNumber = 2;
  inline const ::LineRuleProto& lines(int index) const;
  inline ::LineRuleProto* mutable_lines(int index);
  inline ::LineRuleProto* add_lines();
  inline const ::google::protobuf::RepeatedPtrField< ::LineRuleProto >&
      lines() const;
  inline ::google::protobuf::RepeatedPtrField< ::LineRuleProto >*
      mutable_lines();

  // optional .AreaRuleProto area = 3;
  inline bool has_area() const;
  inline void clear_area();
  static const int kAreaFieldNumber = 3;
  inline const ::AreaRuleProto& area() const;
  inline ::AreaRuleProto* mutable_area();
  inline ::AreaRuleProto* release_area();
  inline void set_allocated_area(::AreaRuleProto* area);

  // optional .SymbolRuleProto symbol = 4;
  inline bool has_symbol() const;
  inline void clear_symbol();
  static const int kSymbolFieldNumber = 4;
  inline const ::SymbolRuleProto& symbol() const;
  inline ::SymbolRuleProto* mutable_symbol();
  inline ::SymbolRuleProto* release_symbol();
  inline void set_allocated_symbol(::SymbolRuleProto* symbol);

  // optional .CaptionRuleProto caption = 5;
  inline bool has_caption() const;
  inline void clear_caption();
  static const int kCaptionFieldNumber = 5;
  inline const ::CaptionRuleProto& caption() const;
  inline ::CaptionRuleProto* mutable_caption();
  inline ::CaptionRuleProto* release_caption();
  inline void set_allocated_caption(::CaptionRuleProto* caption);

  // optional .CircleRuleProto circle = 6;
  inline bool has_circle() const;
  inline void clear_circle();
  static const int kCircleFieldNumber = 6;
  inline const ::CircleRuleProto& circle() const;
  inline ::CircleRuleProto* mutable_circle();
  inline ::CircleRuleProto* release_circle();
  inline void set_allocated_circle(::CircleRuleProto* circle);

  // optional .PathTextRuleProto path_text = 7;
  inline bool has_path_text() const;
  inline void clear_path_text();
  static const int kPathTextFieldNumber = 7;
  inline const ::PathTextRuleProto& path_text() const;
  inline ::PathTextRuleProto* mutable_path_text();
  inline ::PathTextRuleProto* release_path_text();
  inline void set_allocated_path_text(::PathTextRuleProto* path_text);

  // optional .ShieldRuleProto shield = 8;
  inline bool has_shield() const;
  inline void clear_shield();
  static const int kShieldFieldNumber = 8;
  inline const ::ShieldRuleProto& shield() const;
  inline ::ShieldRuleProto* mutable_shield();
  inline ::ShieldRuleProto* release_shield();
  inline void set_allocated_shield(::ShieldRuleProto* shield);

  // repeated string apply_if = 9;
  inline int apply_if_size() const;
  inline void clear_apply_if();
  static const int kApplyIfFieldNumber = 9;
  inline const ::std::string& apply_if(int index) const;
  inline ::std::string* mutable_apply_if(int index);
  inline void set_apply_if(int index, const ::std::string& value);
  inline void set_apply_if(int index, const char* value);
  inline void set_apply_if(int index, const char* value, size_t size);
  inline ::std::string* add_apply_if();
  inline void add_apply_if(const ::std::string& value);
  inline void add_apply_if(const char* value);
  inline void add_apply_if(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& apply_if() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_apply_if();

  // @@protoc_insertion_point(class_scope:DrawElementProto)
 private:
  inline void set_has_scale();
  inline void clear_has_scale();
  inline void set_has_area();
  inline void clear_has_area();
  inline void set_has_symbol();
  inline void clear_has_symbol();
  inline void set_has_caption();
  inline void clear_has_caption();
  inline void set_has_circle();
  inline void clear_has_circle();
  inline void set_has_path_text();
  inline void clear_has_path_text();
  inline void set_has_shield();
  inline void clear_has_shield();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::LineRuleProto > lines_;
  ::AreaRuleProto* area_;
  ::SymbolRuleProto* symbol_;
  ::CaptionRuleProto* caption_;
  ::CircleRuleProto* circle_;
  ::PathTextRuleProto* path_text_;
  ::ShieldRuleProto* shield_;
  ::google::protobuf::RepeatedPtrField< ::std::string> apply_if_;
  ::google::protobuf::int32 scale_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_drules_5fstruct_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_drules_5fstruct_2eproto();
  #endif
  friend void protobuf_AssignDesc_drules_5fstruct_2eproto();
  friend void protobuf_ShutdownFile_drules_5fstruct_2eproto();

  void InitAsDefaultInstance();
  static DrawElementProto* default_instance_;
};
// -------------------------------------------------------------------

class ClassifElementProto : public ::google::protobuf::MessageLite {
 public:
  ClassifElementProto();
  virtual ~ClassifElementProto();

  ClassifElementProto(const ClassifElementProto& from);

  inline ClassifElementProto& operator=(const ClassifElementProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ClassifElementProto& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClassifElementProto* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClassifElementProto* other);

  // implements Message ----------------------------------------------

  ClassifElementProto* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClassifElementProto& from);
  void MergeFrom(const ClassifElementProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .DrawElementProto element = 2;
  inline int element_size() const;
  inline void clear_element();
  static const int kElementFieldNumber = 2;
  inline const ::DrawElementProto& element(int index) const;
  inline ::DrawElementProto* mutable_element(int index);
  inline ::DrawElementProto* add_element();
  inline const ::google::protobuf::RepeatedPtrField< ::DrawElementProto >&
      element() const;
  inline ::google::protobuf::RepeatedPtrField< ::DrawElementProto >*
      mutable_element();

  // @@protoc_insertion_point(class_scope:ClassifElementProto)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::DrawElementProto > element_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_drules_5fstruct_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_drules_5fstruct_2eproto();
  #endif
  friend void protobuf_AssignDesc_drules_5fstruct_2eproto();
  friend void protobuf_ShutdownFile_drules_5fstruct_2eproto();

  void InitAsDefaultInstance();
  static ClassifElementProto* default_instance_;
};
// -------------------------------------------------------------------

class ContainerProto : public ::google::protobuf::MessageLite {
 public:
  ContainerProto();
  virtual ~ContainerProto();

  ContainerProto(const ContainerProto& from);

  inline ContainerProto& operator=(const ContainerProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ContainerProto& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ContainerProto* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ContainerProto* other);

  // implements Message ----------------------------------------------

  ContainerProto* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ContainerProto& from);
  void MergeFrom(const ContainerProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ClassifElementProto cont = 1;
  inline int cont_size() const;
  inline void clear_cont();
  static const int kContFieldNumber = 1;
  inline const ::ClassifElementProto& cont(int index) const;
  inline ::ClassifElementProto* mutable_cont(int index);
  inline ::ClassifElementProto* add_cont();
  inline const ::google::protobuf::RepeatedPtrField< ::ClassifElementProto >&
      cont() const;
  inline ::google::protobuf::RepeatedPtrField< ::ClassifElementProto >*
      mutable_cont();

  // @@protoc_insertion_point(class_scope:ContainerProto)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ClassifElementProto > cont_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_drules_5fstruct_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_drules_5fstruct_2eproto();
  #endif
  friend void protobuf_AssignDesc_drules_5fstruct_2eproto();
  friend void protobuf_ShutdownFile_drules_5fstruct_2eproto();

  void InitAsDefaultInstance();
  static ContainerProto* default_instance_;
};
// ===================================================================


// ===================================================================

// DashDotProto

// repeated double dd = 1;
inline int DashDotProto::dd_size() const {
  return dd_.size();
}
inline void DashDotProto::clear_dd() {
  dd_.Clear();
}
inline double DashDotProto::dd(int index) const {
  // @@protoc_insertion_point(field_get:DashDotProto.dd)
  return dd_.Get(index);
}
inline void DashDotProto::set_dd(int index, double value) {
  dd_.Set(index, value);
  // @@protoc_insertion_point(field_set:DashDotProto.dd)
}
inline void DashDotProto::add_dd(double value) {
  dd_.Add(value);
  // @@protoc_insertion_point(field_add:DashDotProto.dd)
}
inline const ::google::protobuf::RepeatedField< double >&
DashDotProto::dd() const {
  // @@protoc_insertion_point(field_list:DashDotProto.dd)
  return dd_;
}
inline ::google::protobuf::RepeatedField< double >*
DashDotProto::mutable_dd() {
  // @@protoc_insertion_point(field_mutable_list:DashDotProto.dd)
  return &dd_;
}

// optional double offset = 2;
inline bool DashDotProto::has_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DashDotProto::set_has_offset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DashDotProto::clear_has_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DashDotProto::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline double DashDotProto::offset() const {
  // @@protoc_insertion_point(field_get:DashDotProto.offset)
  return offset_;
}
inline void DashDotProto::set_offset(double value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:DashDotProto.offset)
}

// -------------------------------------------------------------------

// PathSymProto

// required string name = 1;
inline bool PathSymProto::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PathSymProto::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PathSymProto::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PathSymProto::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& PathSymProto::name() const {
  // @@protoc_insertion_point(field_get:PathSymProto.name)
  return *name_;
}
inline void PathSymProto::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:PathSymProto.name)
}
inline void PathSymProto::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:PathSymProto.name)
}
inline void PathSymProto::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PathSymProto.name)
}
inline ::std::string* PathSymProto::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PathSymProto.name)
  return name_;
}
inline ::std::string* PathSymProto::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PathSymProto::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PathSymProto.name)
}

// required double step = 2;
inline bool PathSymProto::has_step() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PathSymProto::set_has_step() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PathSymProto::clear_has_step() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PathSymProto::clear_step() {
  step_ = 0;
  clear_has_step();
}
inline double PathSymProto::step() const {
  // @@protoc_insertion_point(field_get:PathSymProto.step)
  return step_;
}
inline void PathSymProto::set_step(double value) {
  set_has_step();
  step_ = value;
  // @@protoc_insertion_point(field_set:PathSymProto.step)
}

// optional double offset = 3;
inline bool PathSymProto::has_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PathSymProto::set_has_offset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PathSymProto::clear_has_offset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PathSymProto::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline double PathSymProto::offset() const {
  // @@protoc_insertion_point(field_get:PathSymProto.offset)
  return offset_;
}
inline void PathSymProto::set_offset(double value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:PathSymProto.offset)
}

// -------------------------------------------------------------------

// LineRuleProto

// required double width = 1;
inline bool LineRuleProto::has_width() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LineRuleProto::set_has_width() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LineRuleProto::clear_has_width() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LineRuleProto::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline double LineRuleProto::width() const {
  // @@protoc_insertion_point(field_get:LineRuleProto.width)
  return width_;
}
inline void LineRuleProto::set_width(double value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:LineRuleProto.width)
}

// required uint32 color = 2;
inline bool LineRuleProto::has_color() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LineRuleProto::set_has_color() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LineRuleProto::clear_has_color() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LineRuleProto::clear_color() {
  color_ = 0u;
  clear_has_color();
}
inline ::google::protobuf::uint32 LineRuleProto::color() const {
  // @@protoc_insertion_point(field_get:LineRuleProto.color)
  return color_;
}
inline void LineRuleProto::set_color(::google::protobuf::uint32 value) {
  set_has_color();
  color_ = value;
  // @@protoc_insertion_point(field_set:LineRuleProto.color)
}

// optional .DashDotProto dashdot = 3;
inline bool LineRuleProto::has_dashdot() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LineRuleProto::set_has_dashdot() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LineRuleProto::clear_has_dashdot() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LineRuleProto::clear_dashdot() {
  if (dashdot_ != NULL) dashdot_->::DashDotProto::Clear();
  clear_has_dashdot();
}
inline const ::DashDotProto& LineRuleProto::dashdot() const {
  // @@protoc_insertion_point(field_get:LineRuleProto.dashdot)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return dashdot_ != NULL ? *dashdot_ : *default_instance().dashdot_;
#else
  return dashdot_ != NULL ? *dashdot_ : *default_instance_->dashdot_;
#endif
}
inline ::DashDotProto* LineRuleProto::mutable_dashdot() {
  set_has_dashdot();
  if (dashdot_ == NULL) dashdot_ = new ::DashDotProto;
  // @@protoc_insertion_point(field_mutable:LineRuleProto.dashdot)
  return dashdot_;
}
inline ::DashDotProto* LineRuleProto::release_dashdot() {
  clear_has_dashdot();
  ::DashDotProto* temp = dashdot_;
  dashdot_ = NULL;
  return temp;
}
inline void LineRuleProto::set_allocated_dashdot(::DashDotProto* dashdot) {
  delete dashdot_;
  dashdot_ = dashdot;
  if (dashdot) {
    set_has_dashdot();
  } else {
    clear_has_dashdot();
  }
  // @@protoc_insertion_point(field_set_allocated:LineRuleProto.dashdot)
}

// required int32 priority = 4;
inline bool LineRuleProto::has_priority() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LineRuleProto::set_has_priority() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LineRuleProto::clear_has_priority() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LineRuleProto::clear_priority() {
  priority_ = 0;
  clear_has_priority();
}
inline ::google::protobuf::int32 LineRuleProto::priority() const {
  // @@protoc_insertion_point(field_get:LineRuleProto.priority)
  return priority_;
}
inline void LineRuleProto::set_priority(::google::protobuf::int32 value) {
  set_has_priority();
  priority_ = value;
  // @@protoc_insertion_point(field_set:LineRuleProto.priority)
}

// optional .PathSymProto pathsym = 5;
inline bool LineRuleProto::has_pathsym() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LineRuleProto::set_has_pathsym() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LineRuleProto::clear_has_pathsym() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LineRuleProto::clear_pathsym() {
  if (pathsym_ != NULL) pathsym_->::PathSymProto::Clear();
  clear_has_pathsym();
}
inline const ::PathSymProto& LineRuleProto::pathsym() const {
  // @@protoc_insertion_point(field_get:LineRuleProto.pathsym)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return pathsym_ != NULL ? *pathsym_ : *default_instance().pathsym_;
#else
  return pathsym_ != NULL ? *pathsym_ : *default_instance_->pathsym_;
#endif
}
inline ::PathSymProto* LineRuleProto::mutable_pathsym() {
  set_has_pathsym();
  if (pathsym_ == NULL) pathsym_ = new ::PathSymProto;
  // @@protoc_insertion_point(field_mutable:LineRuleProto.pathsym)
  return pathsym_;
}
inline ::PathSymProto* LineRuleProto::release_pathsym() {
  clear_has_pathsym();
  ::PathSymProto* temp = pathsym_;
  pathsym_ = NULL;
  return temp;
}
inline void LineRuleProto::set_allocated_pathsym(::PathSymProto* pathsym) {
  delete pathsym_;
  pathsym_ = pathsym;
  if (pathsym) {
    set_has_pathsym();
  } else {
    clear_has_pathsym();
  }
  // @@protoc_insertion_point(field_set_allocated:LineRuleProto.pathsym)
}

// optional .LineJoin join = 6;
inline bool LineRuleProto::has_join() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LineRuleProto::set_has_join() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LineRuleProto::clear_has_join() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LineRuleProto::clear_join() {
  join_ = 0;
  clear_has_join();
}
inline ::LineJoin LineRuleProto::join() const {
  // @@protoc_insertion_point(field_get:LineRuleProto.join)
  return static_cast< ::LineJoin >(join_);
}
inline void LineRuleProto::set_join(::LineJoin value) {
  assert(::LineJoin_IsValid(value));
  set_has_join();
  join_ = value;
  // @@protoc_insertion_point(field_set:LineRuleProto.join)
}

// optional .LineCap cap = 7;
inline bool LineRuleProto::has_cap() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LineRuleProto::set_has_cap() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LineRuleProto::clear_has_cap() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LineRuleProto::clear_cap() {
  cap_ = 0;
  clear_has_cap();
}
inline ::LineCap LineRuleProto::cap() const {
  // @@protoc_insertion_point(field_get:LineRuleProto.cap)
  return static_cast< ::LineCap >(cap_);
}
inline void LineRuleProto::set_cap(::LineCap value) {
  assert(::LineCap_IsValid(value));
  set_has_cap();
  cap_ = value;
  // @@protoc_insertion_point(field_set:LineRuleProto.cap)
}

// -------------------------------------------------------------------

// LineDefProto

// required double width = 1;
inline bool LineDefProto::has_width() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LineDefProto::set_has_width() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LineDefProto::clear_has_width() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LineDefProto::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline double LineDefProto::width() const {
  // @@protoc_insertion_point(field_get:LineDefProto.width)
  return width_;
}
inline void LineDefProto::set_width(double value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:LineDefProto.width)
}

// required uint32 color = 2;
inline bool LineDefProto::has_color() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LineDefProto::set_has_color() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LineDefProto::clear_has_color() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LineDefProto::clear_color() {
  color_ = 0u;
  clear_has_color();
}
inline ::google::protobuf::uint32 LineDefProto::color() const {
  // @@protoc_insertion_point(field_get:LineDefProto.color)
  return color_;
}
inline void LineDefProto::set_color(::google::protobuf::uint32 value) {
  set_has_color();
  color_ = value;
  // @@protoc_insertion_point(field_set:LineDefProto.color)
}

// optional .DashDotProto dashdot = 3;
inline bool LineDefProto::has_dashdot() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LineDefProto::set_has_dashdot() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LineDefProto::clear_has_dashdot() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LineDefProto::clear_dashdot() {
  if (dashdot_ != NULL) dashdot_->::DashDotProto::Clear();
  clear_has_dashdot();
}
inline const ::DashDotProto& LineDefProto::dashdot() const {
  // @@protoc_insertion_point(field_get:LineDefProto.dashdot)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return dashdot_ != NULL ? *dashdot_ : *default_instance().dashdot_;
#else
  return dashdot_ != NULL ? *dashdot_ : *default_instance_->dashdot_;
#endif
}
inline ::DashDotProto* LineDefProto::mutable_dashdot() {
  set_has_dashdot();
  if (dashdot_ == NULL) dashdot_ = new ::DashDotProto;
  // @@protoc_insertion_point(field_mutable:LineDefProto.dashdot)
  return dashdot_;
}
inline ::DashDotProto* LineDefProto::release_dashdot() {
  clear_has_dashdot();
  ::DashDotProto* temp = dashdot_;
  dashdot_ = NULL;
  return temp;
}
inline void LineDefProto::set_allocated_dashdot(::DashDotProto* dashdot) {
  delete dashdot_;
  dashdot_ = dashdot;
  if (dashdot) {
    set_has_dashdot();
  } else {
    clear_has_dashdot();
  }
  // @@protoc_insertion_point(field_set_allocated:LineDefProto.dashdot)
}

// optional .PathSymProto pathsym = 4;
inline bool LineDefProto::has_pathsym() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LineDefProto::set_has_pathsym() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LineDefProto::clear_has_pathsym() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LineDefProto::clear_pathsym() {
  if (pathsym_ != NULL) pathsym_->::PathSymProto::Clear();
  clear_has_pathsym();
}
inline const ::PathSymProto& LineDefProto::pathsym() const {
  // @@protoc_insertion_point(field_get:LineDefProto.pathsym)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return pathsym_ != NULL ? *pathsym_ : *default_instance().pathsym_;
#else
  return pathsym_ != NULL ? *pathsym_ : *default_instance_->pathsym_;
#endif
}
inline ::PathSymProto* LineDefProto::mutable_pathsym() {
  set_has_pathsym();
  if (pathsym_ == NULL) pathsym_ = new ::PathSymProto;
  // @@protoc_insertion_point(field_mutable:LineDefProto.pathsym)
  return pathsym_;
}
inline ::PathSymProto* LineDefProto::release_pathsym() {
  clear_has_pathsym();
  ::PathSymProto* temp = pathsym_;
  pathsym_ = NULL;
  return temp;
}
inline void LineDefProto::set_allocated_pathsym(::PathSymProto* pathsym) {
  delete pathsym_;
  pathsym_ = pathsym;
  if (pathsym) {
    set_has_pathsym();
  } else {
    clear_has_pathsym();
  }
  // @@protoc_insertion_point(field_set_allocated:LineDefProto.pathsym)
}

// optional .LineJoin join = 6;
inline bool LineDefProto::has_join() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LineDefProto::set_has_join() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LineDefProto::clear_has_join() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LineDefProto::clear_join() {
  join_ = 0;
  clear_has_join();
}
inline ::LineJoin LineDefProto::join() const {
  // @@protoc_insertion_point(field_get:LineDefProto.join)
  return static_cast< ::LineJoin >(join_);
}
inline void LineDefProto::set_join(::LineJoin value) {
  assert(::LineJoin_IsValid(value));
  set_has_join();
  join_ = value;
  // @@protoc_insertion_point(field_set:LineDefProto.join)
}

// optional .LineCap cap = 7;
inline bool LineDefProto::has_cap() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LineDefProto::set_has_cap() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LineDefProto::clear_has_cap() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LineDefProto::clear_cap() {
  cap_ = 0;
  clear_has_cap();
}
inline ::LineCap LineDefProto::cap() const {
  // @@protoc_insertion_point(field_get:LineDefProto.cap)
  return static_cast< ::LineCap >(cap_);
}
inline void LineDefProto::set_cap(::LineCap value) {
  assert(::LineCap_IsValid(value));
  set_has_cap();
  cap_ = value;
  // @@protoc_insertion_point(field_set:LineDefProto.cap)
}

// -------------------------------------------------------------------

// AreaRuleProto

// required uint32 color = 1;
inline bool AreaRuleProto::has_color() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AreaRuleProto::set_has_color() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AreaRuleProto::clear_has_color() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AreaRuleProto::clear_color() {
  color_ = 0u;
  clear_has_color();
}
inline ::google::protobuf::uint32 AreaRuleProto::color() const {
  // @@protoc_insertion_point(field_get:AreaRuleProto.color)
  return color_;
}
inline void AreaRuleProto::set_color(::google::protobuf::uint32 value) {
  set_has_color();
  color_ = value;
  // @@protoc_insertion_point(field_set:AreaRuleProto.color)
}

// optional .LineDefProto border = 2;
inline bool AreaRuleProto::has_border() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AreaRuleProto::set_has_border() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AreaRuleProto::clear_has_border() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AreaRuleProto::clear_border() {
  if (border_ != NULL) border_->::LineDefProto::Clear();
  clear_has_border();
}
inline const ::LineDefProto& AreaRuleProto::border() const {
  // @@protoc_insertion_point(field_get:AreaRuleProto.border)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return border_ != NULL ? *border_ : *default_instance().border_;
#else
  return border_ != NULL ? *border_ : *default_instance_->border_;
#endif
}
inline ::LineDefProto* AreaRuleProto::mutable_border() {
  set_has_border();
  if (border_ == NULL) border_ = new ::LineDefProto;
  // @@protoc_insertion_point(field_mutable:AreaRuleProto.border)
  return border_;
}
inline ::LineDefProto* AreaRuleProto::release_border() {
  clear_has_border();
  ::LineDefProto* temp = border_;
  border_ = NULL;
  return temp;
}
inline void AreaRuleProto::set_allocated_border(::LineDefProto* border) {
  delete border_;
  border_ = border;
  if (border) {
    set_has_border();
  } else {
    clear_has_border();
  }
  // @@protoc_insertion_point(field_set_allocated:AreaRuleProto.border)
}

// required int32 priority = 3;
inline bool AreaRuleProto::has_priority() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AreaRuleProto::set_has_priority() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AreaRuleProto::clear_has_priority() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AreaRuleProto::clear_priority() {
  priority_ = 0;
  clear_has_priority();
}
inline ::google::protobuf::int32 AreaRuleProto::priority() const {
  // @@protoc_insertion_point(field_get:AreaRuleProto.priority)
  return priority_;
}
inline void AreaRuleProto::set_priority(::google::protobuf::int32 value) {
  set_has_priority();
  priority_ = value;
  // @@protoc_insertion_point(field_set:AreaRuleProto.priority)
}

// -------------------------------------------------------------------

// SymbolRuleProto

// required string name = 1;
inline bool SymbolRuleProto::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SymbolRuleProto::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SymbolRuleProto::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SymbolRuleProto::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& SymbolRuleProto::name() const {
  // @@protoc_insertion_point(field_get:SymbolRuleProto.name)
  return *name_;
}
inline void SymbolRuleProto::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:SymbolRuleProto.name)
}
inline void SymbolRuleProto::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:SymbolRuleProto.name)
}
inline void SymbolRuleProto::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SymbolRuleProto.name)
}
inline ::std::string* SymbolRuleProto::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:SymbolRuleProto.name)
  return name_;
}
inline ::std::string* SymbolRuleProto::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SymbolRuleProto::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:SymbolRuleProto.name)
}

// optional int32 apply_for_type = 2;
inline bool SymbolRuleProto::has_apply_for_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SymbolRuleProto::set_has_apply_for_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SymbolRuleProto::clear_has_apply_for_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SymbolRuleProto::clear_apply_for_type() {
  apply_for_type_ = 0;
  clear_has_apply_for_type();
}
inline ::google::protobuf::int32 SymbolRuleProto::apply_for_type() const {
  // @@protoc_insertion_point(field_get:SymbolRuleProto.apply_for_type)
  return apply_for_type_;
}
inline void SymbolRuleProto::set_apply_for_type(::google::protobuf::int32 value) {
  set_has_apply_for_type();
  apply_for_type_ = value;
  // @@protoc_insertion_point(field_set:SymbolRuleProto.apply_for_type)
}

// required int32 priority = 3;
inline bool SymbolRuleProto::has_priority() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SymbolRuleProto::set_has_priority() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SymbolRuleProto::clear_has_priority() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SymbolRuleProto::clear_priority() {
  priority_ = 0;
  clear_has_priority();
}
inline ::google::protobuf::int32 SymbolRuleProto::priority() const {
  // @@protoc_insertion_point(field_get:SymbolRuleProto.priority)
  return priority_;
}
inline void SymbolRuleProto::set_priority(::google::protobuf::int32 value) {
  set_has_priority();
  priority_ = value;
  // @@protoc_insertion_point(field_set:SymbolRuleProto.priority)
}

// -------------------------------------------------------------------

// CaptionDefProto

// required int32 height = 1;
inline bool CaptionDefProto::has_height() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CaptionDefProto::set_has_height() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CaptionDefProto::clear_has_height() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CaptionDefProto::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 CaptionDefProto::height() const {
  // @@protoc_insertion_point(field_get:CaptionDefProto.height)
  return height_;
}
inline void CaptionDefProto::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:CaptionDefProto.height)
}

// required uint32 color = 2;
inline bool CaptionDefProto::has_color() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CaptionDefProto::set_has_color() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CaptionDefProto::clear_has_color() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CaptionDefProto::clear_color() {
  color_ = 0u;
  clear_has_color();
}
inline ::google::protobuf::uint32 CaptionDefProto::color() const {
  // @@protoc_insertion_point(field_get:CaptionDefProto.color)
  return color_;
}
inline void CaptionDefProto::set_color(::google::protobuf::uint32 value) {
  set_has_color();
  color_ = value;
  // @@protoc_insertion_point(field_set:CaptionDefProto.color)
}

// optional uint32 stroke_color = 3;
inline bool CaptionDefProto::has_stroke_color() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CaptionDefProto::set_has_stroke_color() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CaptionDefProto::clear_has_stroke_color() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CaptionDefProto::clear_stroke_color() {
  stroke_color_ = 0u;
  clear_has_stroke_color();
}
inline ::google::protobuf::uint32 CaptionDefProto::stroke_color() const {
  // @@protoc_insertion_point(field_get:CaptionDefProto.stroke_color)
  return stroke_color_;
}
inline void CaptionDefProto::set_stroke_color(::google::protobuf::uint32 value) {
  set_has_stroke_color();
  stroke_color_ = value;
  // @@protoc_insertion_point(field_set:CaptionDefProto.stroke_color)
}

// optional int32 offset_x = 4;
inline bool CaptionDefProto::has_offset_x() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CaptionDefProto::set_has_offset_x() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CaptionDefProto::clear_has_offset_x() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CaptionDefProto::clear_offset_x() {
  offset_x_ = 0;
  clear_has_offset_x();
}
inline ::google::protobuf::int32 CaptionDefProto::offset_x() const {
  // @@protoc_insertion_point(field_get:CaptionDefProto.offset_x)
  return offset_x_;
}
inline void CaptionDefProto::set_offset_x(::google::protobuf::int32 value) {
  set_has_offset_x();
  offset_x_ = value;
  // @@protoc_insertion_point(field_set:CaptionDefProto.offset_x)
}

// optional int32 offset_y = 5;
inline bool CaptionDefProto::has_offset_y() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CaptionDefProto::set_has_offset_y() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CaptionDefProto::clear_has_offset_y() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CaptionDefProto::clear_offset_y() {
  offset_y_ = 0;
  clear_has_offset_y();
}
inline ::google::protobuf::int32 CaptionDefProto::offset_y() const {
  // @@protoc_insertion_point(field_get:CaptionDefProto.offset_y)
  return offset_y_;
}
inline void CaptionDefProto::set_offset_y(::google::protobuf::int32 value) {
  set_has_offset_y();
  offset_y_ = value;
  // @@protoc_insertion_point(field_set:CaptionDefProto.offset_y)
}

// -------------------------------------------------------------------

// CaptionRuleProto

// required .CaptionDefProto primary = 1;
inline bool CaptionRuleProto::has_primary() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CaptionRuleProto::set_has_primary() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CaptionRuleProto::clear_has_primary() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CaptionRuleProto::clear_primary() {
  if (primary_ != NULL) primary_->::CaptionDefProto::Clear();
  clear_has_primary();
}
inline const ::CaptionDefProto& CaptionRuleProto::primary() const {
  // @@protoc_insertion_point(field_get:CaptionRuleProto.primary)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return primary_ != NULL ? *primary_ : *default_instance().primary_;
#else
  return primary_ != NULL ? *primary_ : *default_instance_->primary_;
#endif
}
inline ::CaptionDefProto* CaptionRuleProto::mutable_primary() {
  set_has_primary();
  if (primary_ == NULL) primary_ = new ::CaptionDefProto;
  // @@protoc_insertion_point(field_mutable:CaptionRuleProto.primary)
  return primary_;
}
inline ::CaptionDefProto* CaptionRuleProto::release_primary() {
  clear_has_primary();
  ::CaptionDefProto* temp = primary_;
  primary_ = NULL;
  return temp;
}
inline void CaptionRuleProto::set_allocated_primary(::CaptionDefProto* primary) {
  delete primary_;
  primary_ = primary;
  if (primary) {
    set_has_primary();
  } else {
    clear_has_primary();
  }
  // @@protoc_insertion_point(field_set_allocated:CaptionRuleProto.primary)
}

// optional .CaptionDefProto secondary = 2;
inline bool CaptionRuleProto::has_secondary() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CaptionRuleProto::set_has_secondary() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CaptionRuleProto::clear_has_secondary() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CaptionRuleProto::clear_secondary() {
  if (secondary_ != NULL) secondary_->::CaptionDefProto::Clear();
  clear_has_secondary();
}
inline const ::CaptionDefProto& CaptionRuleProto::secondary() const {
  // @@protoc_insertion_point(field_get:CaptionRuleProto.secondary)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return secondary_ != NULL ? *secondary_ : *default_instance().secondary_;
#else
  return secondary_ != NULL ? *secondary_ : *default_instance_->secondary_;
#endif
}
inline ::CaptionDefProto* CaptionRuleProto::mutable_secondary() {
  set_has_secondary();
  if (secondary_ == NULL) secondary_ = new ::CaptionDefProto;
  // @@protoc_insertion_point(field_mutable:CaptionRuleProto.secondary)
  return secondary_;
}
inline ::CaptionDefProto* CaptionRuleProto::release_secondary() {
  clear_has_secondary();
  ::CaptionDefProto* temp = secondary_;
  secondary_ = NULL;
  return temp;
}
inline void CaptionRuleProto::set_allocated_secondary(::CaptionDefProto* secondary) {
  delete secondary_;
  secondary_ = secondary;
  if (secondary) {
    set_has_secondary();
  } else {
    clear_has_secondary();
  }
  // @@protoc_insertion_point(field_set_allocated:CaptionRuleProto.secondary)
}

// required int32 priority = 3;
inline bool CaptionRuleProto::has_priority() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CaptionRuleProto::set_has_priority() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CaptionRuleProto::clear_has_priority() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CaptionRuleProto::clear_priority() {
  priority_ = 0;
  clear_has_priority();
}
inline ::google::protobuf::int32 CaptionRuleProto::priority() const {
  // @@protoc_insertion_point(field_get:CaptionRuleProto.priority)
  return priority_;
}
inline void CaptionRuleProto::set_priority(::google::protobuf::int32 value) {
  set_has_priority();
  priority_ = value;
  // @@protoc_insertion_point(field_set:CaptionRuleProto.priority)
}

// -------------------------------------------------------------------

// CircleRuleProto

// required double radius = 1;
inline bool CircleRuleProto::has_radius() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CircleRuleProto::set_has_radius() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CircleRuleProto::clear_has_radius() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CircleRuleProto::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline double CircleRuleProto::radius() const {
  // @@protoc_insertion_point(field_get:CircleRuleProto.radius)
  return radius_;
}
inline void CircleRuleProto::set_radius(double value) {
  set_has_radius();
  radius_ = value;
  // @@protoc_insertion_point(field_set:CircleRuleProto.radius)
}

// required uint32 color = 2;
inline bool CircleRuleProto::has_color() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CircleRuleProto::set_has_color() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CircleRuleProto::clear_has_color() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CircleRuleProto::clear_color() {
  color_ = 0u;
  clear_has_color();
}
inline ::google::protobuf::uint32 CircleRuleProto::color() const {
  // @@protoc_insertion_point(field_get:CircleRuleProto.color)
  return color_;
}
inline void CircleRuleProto::set_color(::google::protobuf::uint32 value) {
  set_has_color();
  color_ = value;
  // @@protoc_insertion_point(field_set:CircleRuleProto.color)
}

// optional .LineDefProto border = 3;
inline bool CircleRuleProto::has_border() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CircleRuleProto::set_has_border() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CircleRuleProto::clear_has_border() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CircleRuleProto::clear_border() {
  if (border_ != NULL) border_->::LineDefProto::Clear();
  clear_has_border();
}
inline const ::LineDefProto& CircleRuleProto::border() const {
  // @@protoc_insertion_point(field_get:CircleRuleProto.border)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return border_ != NULL ? *border_ : *default_instance().border_;
#else
  return border_ != NULL ? *border_ : *default_instance_->border_;
#endif
}
inline ::LineDefProto* CircleRuleProto::mutable_border() {
  set_has_border();
  if (border_ == NULL) border_ = new ::LineDefProto;
  // @@protoc_insertion_point(field_mutable:CircleRuleProto.border)
  return border_;
}
inline ::LineDefProto* CircleRuleProto::release_border() {
  clear_has_border();
  ::LineDefProto* temp = border_;
  border_ = NULL;
  return temp;
}
inline void CircleRuleProto::set_allocated_border(::LineDefProto* border) {
  delete border_;
  border_ = border;
  if (border) {
    set_has_border();
  } else {
    clear_has_border();
  }
  // @@protoc_insertion_point(field_set_allocated:CircleRuleProto.border)
}

// required int32 priority = 4;
inline bool CircleRuleProto::has_priority() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CircleRuleProto::set_has_priority() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CircleRuleProto::clear_has_priority() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CircleRuleProto::clear_priority() {
  priority_ = 0;
  clear_has_priority();
}
inline ::google::protobuf::int32 CircleRuleProto::priority() const {
  // @@protoc_insertion_point(field_get:CircleRuleProto.priority)
  return priority_;
}
inline void CircleRuleProto::set_priority(::google::protobuf::int32 value) {
  set_has_priority();
  priority_ = value;
  // @@protoc_insertion_point(field_set:CircleRuleProto.priority)
}

// -------------------------------------------------------------------

// PathTextRuleProto

// required .CaptionDefProto primary = 1;
inline bool PathTextRuleProto::has_primary() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PathTextRuleProto::set_has_primary() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PathTextRuleProto::clear_has_primary() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PathTextRuleProto::clear_primary() {
  if (primary_ != NULL) primary_->::CaptionDefProto::Clear();
  clear_has_primary();
}
inline const ::CaptionDefProto& PathTextRuleProto::primary() const {
  // @@protoc_insertion_point(field_get:PathTextRuleProto.primary)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return primary_ != NULL ? *primary_ : *default_instance().primary_;
#else
  return primary_ != NULL ? *primary_ : *default_instance_->primary_;
#endif
}
inline ::CaptionDefProto* PathTextRuleProto::mutable_primary() {
  set_has_primary();
  if (primary_ == NULL) primary_ = new ::CaptionDefProto;
  // @@protoc_insertion_point(field_mutable:PathTextRuleProto.primary)
  return primary_;
}
inline ::CaptionDefProto* PathTextRuleProto::release_primary() {
  clear_has_primary();
  ::CaptionDefProto* temp = primary_;
  primary_ = NULL;
  return temp;
}
inline void PathTextRuleProto::set_allocated_primary(::CaptionDefProto* primary) {
  delete primary_;
  primary_ = primary;
  if (primary) {
    set_has_primary();
  } else {
    clear_has_primary();
  }
  // @@protoc_insertion_point(field_set_allocated:PathTextRuleProto.primary)
}

// optional .CaptionDefProto secondary = 2;
inline bool PathTextRuleProto::has_secondary() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PathTextRuleProto::set_has_secondary() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PathTextRuleProto::clear_has_secondary() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PathTextRuleProto::clear_secondary() {
  if (secondary_ != NULL) secondary_->::CaptionDefProto::Clear();
  clear_has_secondary();
}
inline const ::CaptionDefProto& PathTextRuleProto::secondary() const {
  // @@protoc_insertion_point(field_get:PathTextRuleProto.secondary)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return secondary_ != NULL ? *secondary_ : *default_instance().secondary_;
#else
  return secondary_ != NULL ? *secondary_ : *default_instance_->secondary_;
#endif
}
inline ::CaptionDefProto* PathTextRuleProto::mutable_secondary() {
  set_has_secondary();
  if (secondary_ == NULL) secondary_ = new ::CaptionDefProto;
  // @@protoc_insertion_point(field_mutable:PathTextRuleProto.secondary)
  return secondary_;
}
inline ::CaptionDefProto* PathTextRuleProto::release_secondary() {
  clear_has_secondary();
  ::CaptionDefProto* temp = secondary_;
  secondary_ = NULL;
  return temp;
}
inline void PathTextRuleProto::set_allocated_secondary(::CaptionDefProto* secondary) {
  delete secondary_;
  secondary_ = secondary;
  if (secondary) {
    set_has_secondary();
  } else {
    clear_has_secondary();
  }
  // @@protoc_insertion_point(field_set_allocated:PathTextRuleProto.secondary)
}

// required int32 priority = 3;
inline bool PathTextRuleProto::has_priority() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PathTextRuleProto::set_has_priority() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PathTextRuleProto::clear_has_priority() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PathTextRuleProto::clear_priority() {
  priority_ = 0;
  clear_has_priority();
}
inline ::google::protobuf::int32 PathTextRuleProto::priority() const {
  // @@protoc_insertion_point(field_get:PathTextRuleProto.priority)
  return priority_;
}
inline void PathTextRuleProto::set_priority(::google::protobuf::int32 value) {
  set_has_priority();
  priority_ = value;
  // @@protoc_insertion_point(field_set:PathTextRuleProto.priority)
}

// -------------------------------------------------------------------

// ShieldRuleProto

// required int32 height = 1;
inline bool ShieldRuleProto::has_height() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShieldRuleProto::set_has_height() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShieldRuleProto::clear_has_height() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShieldRuleProto::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 ShieldRuleProto::height() const {
  // @@protoc_insertion_point(field_get:ShieldRuleProto.height)
  return height_;
}
inline void ShieldRuleProto::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:ShieldRuleProto.height)
}

// required uint32 color = 2;
inline bool ShieldRuleProto::has_color() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShieldRuleProto::set_has_color() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShieldRuleProto::clear_has_color() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShieldRuleProto::clear_color() {
  color_ = 0u;
  clear_has_color();
}
inline ::google::protobuf::uint32 ShieldRuleProto::color() const {
  // @@protoc_insertion_point(field_get:ShieldRuleProto.color)
  return color_;
}
inline void ShieldRuleProto::set_color(::google::protobuf::uint32 value) {
  set_has_color();
  color_ = value;
  // @@protoc_insertion_point(field_set:ShieldRuleProto.color)
}

// optional uint32 stroke_color = 3;
inline bool ShieldRuleProto::has_stroke_color() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShieldRuleProto::set_has_stroke_color() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShieldRuleProto::clear_has_stroke_color() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShieldRuleProto::clear_stroke_color() {
  stroke_color_ = 0u;
  clear_has_stroke_color();
}
inline ::google::protobuf::uint32 ShieldRuleProto::stroke_color() const {
  // @@protoc_insertion_point(field_get:ShieldRuleProto.stroke_color)
  return stroke_color_;
}
inline void ShieldRuleProto::set_stroke_color(::google::protobuf::uint32 value) {
  set_has_stroke_color();
  stroke_color_ = value;
  // @@protoc_insertion_point(field_set:ShieldRuleProto.stroke_color)
}

// required int32 priority = 4;
inline bool ShieldRuleProto::has_priority() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ShieldRuleProto::set_has_priority() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ShieldRuleProto::clear_has_priority() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ShieldRuleProto::clear_priority() {
  priority_ = 0;
  clear_has_priority();
}
inline ::google::protobuf::int32 ShieldRuleProto::priority() const {
  // @@protoc_insertion_point(field_get:ShieldRuleProto.priority)
  return priority_;
}
inline void ShieldRuleProto::set_priority(::google::protobuf::int32 value) {
  set_has_priority();
  priority_ = value;
  // @@protoc_insertion_point(field_set:ShieldRuleProto.priority)
}

// -------------------------------------------------------------------

// DrawElementProto

// required int32 scale = 1;
inline bool DrawElementProto::has_scale() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DrawElementProto::set_has_scale() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DrawElementProto::clear_has_scale() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DrawElementProto::clear_scale() {
  scale_ = 0;
  clear_has_scale();
}
inline ::google::protobuf::int32 DrawElementProto::scale() const {
  // @@protoc_insertion_point(field_get:DrawElementProto.scale)
  return scale_;
}
inline void DrawElementProto::set_scale(::google::protobuf::int32 value) {
  set_has_scale();
  scale_ = value;
  // @@protoc_insertion_point(field_set:DrawElementProto.scale)
}

// repeated .LineRuleProto lines = 2;
inline int DrawElementProto::lines_size() const {
  return lines_.size();
}
inline void DrawElementProto::clear_lines() {
  lines_.Clear();
}
inline const ::LineRuleProto& DrawElementProto::lines(int index) const {
  // @@protoc_insertion_point(field_get:DrawElementProto.lines)
  return lines_.Get(index);
}
inline ::LineRuleProto* DrawElementProto::mutable_lines(int index) {
  // @@protoc_insertion_point(field_mutable:DrawElementProto.lines)
  return lines_.Mutable(index);
}
inline ::LineRuleProto* DrawElementProto::add_lines() {
  // @@protoc_insertion_point(field_add:DrawElementProto.lines)
  return lines_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::LineRuleProto >&
DrawElementProto::lines() const {
  // @@protoc_insertion_point(field_list:DrawElementProto.lines)
  return lines_;
}
inline ::google::protobuf::RepeatedPtrField< ::LineRuleProto >*
DrawElementProto::mutable_lines() {
  // @@protoc_insertion_point(field_mutable_list:DrawElementProto.lines)
  return &lines_;
}

// optional .AreaRuleProto area = 3;
inline bool DrawElementProto::has_area() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DrawElementProto::set_has_area() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DrawElementProto::clear_has_area() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DrawElementProto::clear_area() {
  if (area_ != NULL) area_->::AreaRuleProto::Clear();
  clear_has_area();
}
inline const ::AreaRuleProto& DrawElementProto::area() const {
  // @@protoc_insertion_point(field_get:DrawElementProto.area)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return area_ != NULL ? *area_ : *default_instance().area_;
#else
  return area_ != NULL ? *area_ : *default_instance_->area_;
#endif
}
inline ::AreaRuleProto* DrawElementProto::mutable_area() {
  set_has_area();
  if (area_ == NULL) area_ = new ::AreaRuleProto;
  // @@protoc_insertion_point(field_mutable:DrawElementProto.area)
  return area_;
}
inline ::AreaRuleProto* DrawElementProto::release_area() {
  clear_has_area();
  ::AreaRuleProto* temp = area_;
  area_ = NULL;
  return temp;
}
inline void DrawElementProto::set_allocated_area(::AreaRuleProto* area) {
  delete area_;
  area_ = area;
  if (area) {
    set_has_area();
  } else {
    clear_has_area();
  }
  // @@protoc_insertion_point(field_set_allocated:DrawElementProto.area)
}

// optional .SymbolRuleProto symbol = 4;
inline bool DrawElementProto::has_symbol() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DrawElementProto::set_has_symbol() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DrawElementProto::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DrawElementProto::clear_symbol() {
  if (symbol_ != NULL) symbol_->::SymbolRuleProto::Clear();
  clear_has_symbol();
}
inline const ::SymbolRuleProto& DrawElementProto::symbol() const {
  // @@protoc_insertion_point(field_get:DrawElementProto.symbol)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return symbol_ != NULL ? *symbol_ : *default_instance().symbol_;
#else
  return symbol_ != NULL ? *symbol_ : *default_instance_->symbol_;
#endif
}
inline ::SymbolRuleProto* DrawElementProto::mutable_symbol() {
  set_has_symbol();
  if (symbol_ == NULL) symbol_ = new ::SymbolRuleProto;
  // @@protoc_insertion_point(field_mutable:DrawElementProto.symbol)
  return symbol_;
}
inline ::SymbolRuleProto* DrawElementProto::release_symbol() {
  clear_has_symbol();
  ::SymbolRuleProto* temp = symbol_;
  symbol_ = NULL;
  return temp;
}
inline void DrawElementProto::set_allocated_symbol(::SymbolRuleProto* symbol) {
  delete symbol_;
  symbol_ = symbol;
  if (symbol) {
    set_has_symbol();
  } else {
    clear_has_symbol();
  }
  // @@protoc_insertion_point(field_set_allocated:DrawElementProto.symbol)
}

// optional .CaptionRuleProto caption = 5;
inline bool DrawElementProto::has_caption() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DrawElementProto::set_has_caption() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DrawElementProto::clear_has_caption() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DrawElementProto::clear_caption() {
  if (caption_ != NULL) caption_->::CaptionRuleProto::Clear();
  clear_has_caption();
}
inline const ::CaptionRuleProto& DrawElementProto::caption() const {
  // @@protoc_insertion_point(field_get:DrawElementProto.caption)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return caption_ != NULL ? *caption_ : *default_instance().caption_;
#else
  return caption_ != NULL ? *caption_ : *default_instance_->caption_;
#endif
}
inline ::CaptionRuleProto* DrawElementProto::mutable_caption() {
  set_has_caption();
  if (caption_ == NULL) caption_ = new ::CaptionRuleProto;
  // @@protoc_insertion_point(field_mutable:DrawElementProto.caption)
  return caption_;
}
inline ::CaptionRuleProto* DrawElementProto::release_caption() {
  clear_has_caption();
  ::CaptionRuleProto* temp = caption_;
  caption_ = NULL;
  return temp;
}
inline void DrawElementProto::set_allocated_caption(::CaptionRuleProto* caption) {
  delete caption_;
  caption_ = caption;
  if (caption) {
    set_has_caption();
  } else {
    clear_has_caption();
  }
  // @@protoc_insertion_point(field_set_allocated:DrawElementProto.caption)
}

// optional .CircleRuleProto circle = 6;
inline bool DrawElementProto::has_circle() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DrawElementProto::set_has_circle() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DrawElementProto::clear_has_circle() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DrawElementProto::clear_circle() {
  if (circle_ != NULL) circle_->::CircleRuleProto::Clear();
  clear_has_circle();
}
inline const ::CircleRuleProto& DrawElementProto::circle() const {
  // @@protoc_insertion_point(field_get:DrawElementProto.circle)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return circle_ != NULL ? *circle_ : *default_instance().circle_;
#else
  return circle_ != NULL ? *circle_ : *default_instance_->circle_;
#endif
}
inline ::CircleRuleProto* DrawElementProto::mutable_circle() {
  set_has_circle();
  if (circle_ == NULL) circle_ = new ::CircleRuleProto;
  // @@protoc_insertion_point(field_mutable:DrawElementProto.circle)
  return circle_;
}
inline ::CircleRuleProto* DrawElementProto::release_circle() {
  clear_has_circle();
  ::CircleRuleProto* temp = circle_;
  circle_ = NULL;
  return temp;
}
inline void DrawElementProto::set_allocated_circle(::CircleRuleProto* circle) {
  delete circle_;
  circle_ = circle;
  if (circle) {
    set_has_circle();
  } else {
    clear_has_circle();
  }
  // @@protoc_insertion_point(field_set_allocated:DrawElementProto.circle)
}

// optional .PathTextRuleProto path_text = 7;
inline bool DrawElementProto::has_path_text() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DrawElementProto::set_has_path_text() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DrawElementProto::clear_has_path_text() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DrawElementProto::clear_path_text() {
  if (path_text_ != NULL) path_text_->::PathTextRuleProto::Clear();
  clear_has_path_text();
}
inline const ::PathTextRuleProto& DrawElementProto::path_text() const {
  // @@protoc_insertion_point(field_get:DrawElementProto.path_text)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return path_text_ != NULL ? *path_text_ : *default_instance().path_text_;
#else
  return path_text_ != NULL ? *path_text_ : *default_instance_->path_text_;
#endif
}
inline ::PathTextRuleProto* DrawElementProto::mutable_path_text() {
  set_has_path_text();
  if (path_text_ == NULL) path_text_ = new ::PathTextRuleProto;
  // @@protoc_insertion_point(field_mutable:DrawElementProto.path_text)
  return path_text_;
}
inline ::PathTextRuleProto* DrawElementProto::release_path_text() {
  clear_has_path_text();
  ::PathTextRuleProto* temp = path_text_;
  path_text_ = NULL;
  return temp;
}
inline void DrawElementProto::set_allocated_path_text(::PathTextRuleProto* path_text) {
  delete path_text_;
  path_text_ = path_text;
  if (path_text) {
    set_has_path_text();
  } else {
    clear_has_path_text();
  }
  // @@protoc_insertion_point(field_set_allocated:DrawElementProto.path_text)
}

// optional .ShieldRuleProto shield = 8;
inline bool DrawElementProto::has_shield() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DrawElementProto::set_has_shield() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DrawElementProto::clear_has_shield() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DrawElementProto::clear_shield() {
  if (shield_ != NULL) shield_->::ShieldRuleProto::Clear();
  clear_has_shield();
}
inline const ::ShieldRuleProto& DrawElementProto::shield() const {
  // @@protoc_insertion_point(field_get:DrawElementProto.shield)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return shield_ != NULL ? *shield_ : *default_instance().shield_;
#else
  return shield_ != NULL ? *shield_ : *default_instance_->shield_;
#endif
}
inline ::ShieldRuleProto* DrawElementProto::mutable_shield() {
  set_has_shield();
  if (shield_ == NULL) shield_ = new ::ShieldRuleProto;
  // @@protoc_insertion_point(field_mutable:DrawElementProto.shield)
  return shield_;
}
inline ::ShieldRuleProto* DrawElementProto::release_shield() {
  clear_has_shield();
  ::ShieldRuleProto* temp = shield_;
  shield_ = NULL;
  return temp;
}
inline void DrawElementProto::set_allocated_shield(::ShieldRuleProto* shield) {
  delete shield_;
  shield_ = shield;
  if (shield) {
    set_has_shield();
  } else {
    clear_has_shield();
  }
  // @@protoc_insertion_point(field_set_allocated:DrawElementProto.shield)
}

// repeated string apply_if = 9;
inline int DrawElementProto::apply_if_size() const {
  return apply_if_.size();
}
inline void DrawElementProto::clear_apply_if() {
  apply_if_.Clear();
}
inline const ::std::string& DrawElementProto::apply_if(int index) const {
  // @@protoc_insertion_point(field_get:DrawElementProto.apply_if)
  return apply_if_.Get(index);
}
inline ::std::string* DrawElementProto::mutable_apply_if(int index) {
  // @@protoc_insertion_point(field_mutable:DrawElementProto.apply_if)
  return apply_if_.Mutable(index);
}
inline void DrawElementProto::set_apply_if(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:DrawElementProto.apply_if)
  apply_if_.Mutable(index)->assign(value);
}
inline void DrawElementProto::set_apply_if(int index, const char* value) {
  apply_if_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:DrawElementProto.apply_if)
}
inline void DrawElementProto::set_apply_if(int index, const char* value, size_t size) {
  apply_if_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DrawElementProto.apply_if)
}
inline ::std::string* DrawElementProto::add_apply_if() {
  return apply_if_.Add();
}
inline void DrawElementProto::add_apply_if(const ::std::string& value) {
  apply_if_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:DrawElementProto.apply_if)
}
inline void DrawElementProto::add_apply_if(const char* value) {
  apply_if_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:DrawElementProto.apply_if)
}
inline void DrawElementProto::add_apply_if(const char* value, size_t size) {
  apply_if_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:DrawElementProto.apply_if)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DrawElementProto::apply_if() const {
  // @@protoc_insertion_point(field_list:DrawElementProto.apply_if)
  return apply_if_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DrawElementProto::mutable_apply_if() {
  // @@protoc_insertion_point(field_mutable_list:DrawElementProto.apply_if)
  return &apply_if_;
}

// -------------------------------------------------------------------

// ClassifElementProto

// required string name = 1;
inline bool ClassifElementProto::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClassifElementProto::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClassifElementProto::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClassifElementProto::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ClassifElementProto::name() const {
  // @@protoc_insertion_point(field_get:ClassifElementProto.name)
  return *name_;
}
inline void ClassifElementProto::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:ClassifElementProto.name)
}
inline void ClassifElementProto::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:ClassifElementProto.name)
}
inline void ClassifElementProto::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ClassifElementProto.name)
}
inline ::std::string* ClassifElementProto::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ClassifElementProto.name)
  return name_;
}
inline ::std::string* ClassifElementProto::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ClassifElementProto::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ClassifElementProto.name)
}

// repeated .DrawElementProto element = 2;
inline int ClassifElementProto::element_size() const {
  return element_.size();
}
inline void ClassifElementProto::clear_element() {
  element_.Clear();
}
inline const ::DrawElementProto& ClassifElementProto::element(int index) const {
  // @@protoc_insertion_point(field_get:ClassifElementProto.element)
  return element_.Get(index);
}
inline ::DrawElementProto* ClassifElementProto::mutable_element(int index) {
  // @@protoc_insertion_point(field_mutable:ClassifElementProto.element)
  return element_.Mutable(index);
}
inline ::DrawElementProto* ClassifElementProto::add_element() {
  // @@protoc_insertion_point(field_add:ClassifElementProto.element)
  return element_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DrawElementProto >&
ClassifElementProto::element() const {
  // @@protoc_insertion_point(field_list:ClassifElementProto.element)
  return element_;
}
inline ::google::protobuf::RepeatedPtrField< ::DrawElementProto >*
ClassifElementProto::mutable_element() {
  // @@protoc_insertion_point(field_mutable_list:ClassifElementProto.element)
  return &element_;
}

// -------------------------------------------------------------------

// ContainerProto

// repeated .ClassifElementProto cont = 1;
inline int ContainerProto::cont_size() const {
  return cont_.size();
}
inline void ContainerProto::clear_cont() {
  cont_.Clear();
}
inline const ::ClassifElementProto& ContainerProto::cont(int index) const {
  // @@protoc_insertion_point(field_get:ContainerProto.cont)
  return cont_.Get(index);
}
inline ::ClassifElementProto* ContainerProto::mutable_cont(int index) {
  // @@protoc_insertion_point(field_mutable:ContainerProto.cont)
  return cont_.Mutable(index);
}
inline ::ClassifElementProto* ContainerProto::add_cont() {
  // @@protoc_insertion_point(field_add:ContainerProto.cont)
  return cont_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ClassifElementProto >&
ContainerProto::cont() const {
  // @@protoc_insertion_point(field_list:ContainerProto.cont)
  return cont_;
}
inline ::google::protobuf::RepeatedPtrField< ::ClassifElementProto >*
ContainerProto::mutable_cont() {
  // @@protoc_insertion_point(field_mutable_list:ContainerProto.cont)
  return &cont_;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_drules_5fstruct_2eproto__INCLUDED
